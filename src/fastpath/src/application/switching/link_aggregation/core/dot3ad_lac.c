
/*********************************************************************
*
* (C) Copyright Broadcom Corporation 2001-2007
*
**********************************************************************
*
* @filename    dot3ad_lac.c
* @purpose     802.3ad link aggregation, LAC private functions
* @component   dot3ad
* @comments    none
* @create      06/04/2001
* @author      djohnson
* @end
*             
**********************************************************************/

#define L7_MAC_ENET_BCAST /* for the broadcast address */

#include "dot3ad_include.h"
#include "log.h"
#include "defaultconfig.h"
#include "dot3ad_sid.h"
#include "l7_packet.h"
#include "cardmgr_api.h"
#include "buff_api.h"
#include "dot3ad_debug.h"
#include "dot3ad_exports.h"
#include "dot3ad_helper.h"
#include "dot3ad_transport.h"
#ifdef L7_NSF_PACKAGE
 #include "dot3ad_nsf.h"
#endif
#include "logger.h"

dot3ad_stats_t dot3ad_stats[L7_MAX_INTERFACE_COUNT];
dot3ad_system_t dot3adSystem;

dot3ad_LagCnt_t dot3adLagCnt;
void * dot3adCreateSyncSema = L7_NULLPTR;
void * dot3adTimerSyncSema = L7_NULLPTR;
void * dot3adTaskSyncSema = L7_NULLPTR;
void * dot3adAggIntfCreateSema = L7_NULLPTR;
extern void * dot3adQueueSyncSema;

extern dot3adCfg_t dot3adCfg;    /* Configuration File Overlay */
extern L7_uint32   dot3adPortIdx[L7_MAX_PORT_COUNT + 1];
extern dot3ad_agg_t    dot3adAgg[L7_MAX_NUM_LAG_INTF];
extern L7_uint32 dot3adAggIdx[L7_MAX_INTERFACE_COUNT];
extern L7_uint32 dot3adSwitchoverInProgress;

extern dot3ad_nsfFuncPtr_t dot3adNsfFuncTable;
extern dot3ad_stats_t  dot3ad_stats[L7_MAX_INTERFACE_COUNT];
void *dot3ad_queue;  /* reference to the LAC message queue */
void *dot3ad_timer_queue; /* reference to the timer message queue */

extern L7_uint32 dot3adBufferPoolId;
extern dot3adOperPort_t dot3adOperPort[L7_MAX_PORT_COUNT + 1];

extern int interface_is_TA48boards_protection_LAG_member(L7_uint32 intIfNum);// PTin added


/* prototype for cnfgr processor */
void dot3adApiCnfgrCommandProcess( L7_CNFGR_CMD_DATA_t *pCmdData );
extern L7_BOOL dot3adCnfgrIsRestartTypeWarm();

/* Set a bit to true whenever core has information to send to helper on that port*/
DOT3AD_PORTLIST_t coreTxBitMask;

/*********************************************************************
* @purpose  Handles events generated by NIM
*
* @param    eventInfo   event information         
* @returns  void
*
* @notes    There exist the possibility that the processing may not be complete
*           even though the nimCallback has been performed.  Since we are working
*           on the LAC_TASK and all other events will be processed on the LAC_TASK
*           we know that future NIM events will be handled after this event has 
*           completed.
*       
* @end
*********************************************************************/
L7_uint32 dot3adIntfChangeCallBackProcess(NIM_EVENT_COMPLETE_INFO_t eventInfo)
{
  dot3ad_port_t *p;
  L7_RC_t rc = L7_SUCCESS;
  L7_uint32 intIfNum, event;
  NIM_CORRELATOR_t  correlator;
  L7_BOOL performNimCallback = L7_TRUE; /* assume all processing is done here */
  L7_uint32 adminMode;
  L7_uint32 linkState;
  L7_RC_t tempRc = L7_SUCCESS;

  intIfNum    = eventInfo.intIfNum;
  event       = eventInfo.event;
  correlator  = eventInfo.correlator;

  LOG_INFO(LOG_CTX_PTIN_INTF, "dot3adIntfChangeCallBackProcess: event=%u, intIfNum=%u", event, intIfNum);

  if (dot3adIsValidIntf(intIfNum) == L7_FALSE)
  {
    /* 
     * not an interface Type LAG is interested with 
     * set the return code for the callback 
     */
    rc = L7_SUCCESS;
    LOG_INFO(LOG_CTX_PTIN_INTF, "Not Valid interface: intIfNum=%u", intIfNum);
  }
  else
  {
    tempRc = nimGetIntfAdminState(intIfNum, &adminMode);
    if (tempRc != L7_SUCCESS)
    {
	 rc = L7_SUCCESS;
     LOG_INFO(LOG_CTX_PTIN_INTF, "Error: intIfNum=%u", intIfNum);
    }
    tempRc = nimGetIntfLinkState(intIfNum, &linkState);
    if (tempRc != L7_SUCCESS)
    {
	  rc = L7_SUCCESS;
      LOG_INFO(LOG_CTX_PTIN_INTF, "Error: intIfNum=%u", intIfNum);
    }

    if (tempRc == L7_SUCCESS)
    {
    LOG_INFO(LOG_CTX_PTIN_INTF, "switch: event=%u, intIfNum=%u", event, intIfNum);
    dot3adIntfEventTrace(intIfNum,event);
    switch (event)
    {
    /* E2 */
	case L7_PORT_ENABLE:
             /* Process only for Lag interface
               For physical ports a fall through
             */
            if (dot3adIsLag(intIfNum) == L7_TRUE)
            {
            aggAdminModeSet(intIfNum, L7_ENABLE, L7_TRUE);
              break;
            }
    case L7_UP:
            /* PTin added */
            if (interface_is_TA48boards_protection_LAG_member(intIfNum)) {//do nothing
              rc = L7_SUCCESS;
              break;
            }/* PTin added */

             /* Only care about physical interface */
            if (dot3adIsLag(intIfNum) == L7_TRUE)
            {
              rc = L7_SUCCESS;
              break;
            }

            if (dot3adLihIntfSpeedGet(intIfNum, &dot3adOperPort[intIfNum].linkSpeed) != L7_SUCCESS)
            {
              rc = L7_SUCCESS;
              break;
            }

            dot3adOperPort[intIfNum].fullDuplex = dot3adLihIsIntfSpeedFullDuplex(intIfNum);

            /* only process UP events on Physical intf that are part of a LAG */
            if (dot3adIsLagMember(intIfNum) == L7_FALSE)
            {
              rc = L7_SUCCESS;
              break;
            }

            if (adminMode == L7_ENABLE && linkState == L7_UP)
            {
                /* return set to success for callback*/
                (void)dot3adIntfProcessIntfUp(intIfNum);
                rc = L7_SUCCESS;
            }
      break;

      /* E3 */
	case L7_PORT_DISABLE:
            /* Process only for Lag interface
               For physical ports a fall through
             */
            if (dot3adIsLag(intIfNum) == L7_TRUE)
            {
            aggAdminModeSet(intIfNum, L7_DISABLE, L7_TRUE);
              break;
            }
    case L7_DOWN:
        /* PTin added */
        if (interface_is_TA48boards_protection_LAG_member(intIfNum)) {//do nothing
          rc = L7_SUCCESS;
          break;
        }/* PTin added */

        /* only process DOWN events on Physical intf that are part of a LAG */
        if (dot3adIsLagMember(intIfNum) == L7_FALSE)
        {
          rc = L7_SUCCESS;
          break;
        }
            (void)dot3adIntfProcessIntfDown(intIfNum);
    
        break;

      case L7_CREATE:
            rc = dot3adIntfCreate(intIfNum);
        break;

      case L7_ATTACH:
            rc = dot3adIntfAttach(intIfNum);
            if (rc != L7_SUCCESS)
            {
                L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
                nimGetIntfName(intIfNum, L7_SYSNAME, ifName);

                L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT3AD_COMPONENT_ID,
                      "%s:dot3adIntfAttach failed Rc is %d for intf %s",
                         __FUNCTION__, rc, ifName);
                rc = L7_SUCCESS;
            }
        break;

      case L7_DETACH:
        rc = dot3adIntfDetach(intIfNum,&eventInfo,&performNimCallback);
        break;

      case L7_DELETE:
        rc = dot3adIntfDelete(intIfNum,&eventInfo,&performNimCallback);
        break;

	  case L7_SPEED_CHANGE:
		p = dot3adPortIntfFind(intIfNum);

        /* nothing to do, perform callback */
        if (p == L7_NULL)
        {
          rc = L7_SUCCESS;
          break;
        }

		if (dot3adLihIntfSpeedGet(intIfNum, &dot3adOperPort[intIfNum].linkSpeed) != L7_SUCCESS)
		{
		  rc = L7_SUCCESS;
		  break;
		}
		dot3adOperPort[intIfNum].fullDuplex = dot3adLihIsIntfSpeedFullDuplex(intIfNum);
        
		rc = L7_SUCCESS;
		break;

      default:
        rc = L7_SUCCESS;
    } /* switch */
    } /* tempRc*/

  } /* valid interface */

  LOG_INFO(LOG_CTX_PTIN_INTF, "finishing: rc=%u, performNimCallback=%u", rc, performNimCallback);

  if (performNimCallback == L7_TRUE)
  {
    LOG_INFO(LOG_CTX_PTIN_INTF, "Going to call nimEventStatusCallback: intIfNum=%u", intIfNum);

    eventInfo.response.rc = rc;
    eventInfo.response.reason = NIM_ERR_RC_UNUSED;

    /* tell NIM that we are done processing the event */
    nimEventStatusCallback(eventInfo);

    LOG_INFO(LOG_CTX_PTIN_INTF, "nimEventStatusCallback called: intIfNum=%u", intIfNum);
  }
  else
  {
    LOG_INFO(LOG_CTX_PTIN_INTF, "nimEventStatusCallback NOT called: intIfNum=%u", intIfNum);
  }

  return L7_SUCCESS;

}
/*********************************************************************
* @purpose  Handles events generated by NIM
*
* @param    intIfNum      interface number
* @param    event         event 
* @param    correlator    correlator for the event
* @returns  void
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t dot3adIntfChangeCallBack(L7_uint32 intIfNum, L7_uint32 event,NIM_CORRELATOR_t correlator)
{
  L7_RC_t rc;
  dot3adMsg_t msg;
  NIM_EVENT_COMPLETE_INFO_t status;



  LOG_INFO(LOG_CTX_PTIN_INTF, "dot3adIntfChangeCallBack: event=%u, intIfNum=%u", event, intIfNum);

  if (event != L7_PORT_ENABLE &&
      event != L7_UP &&
      event != L7_PORT_DISABLE &&
      event != L7_DOWN &&
      event != L7_CREATE &&
      event != L7_ATTACH &&
      event != L7_DETACH &&
      event != L7_DELETE &&
      event != L7_SPEED_CHANGE)
  {
    status.intIfNum     = intIfNum;
    status.component    = L7_DOT3AD_COMPONENT_ID;
    status.response.rc  = L7_SUCCESS;
    status.response.reason = NIM_ERR_RC_UNUSED;
    status.event        = event;
    status.correlator   = correlator;

    LOG_INFO(LOG_CTX_PTIN_INTF, "Error: event=%u, intIfNum=%u", event, intIfNum);

    nimEventStatusCallback(status);
    return L7_SUCCESS;
  }



  memset((void *)&msg,0,sizeof(dot3adMsg_t));

  /* store the info for the event */
  msg.event = lacNimIntfChange;
  msg.intf  = intIfNum;
  msg.intfData.nimInfo.intIfNum     = intIfNum;
  msg.intfData.nimInfo.component    = L7_DOT3AD_COMPONENT_ID;
  msg.intfData.nimInfo.event        = event;
  msg.intfData.nimInfo.correlator   = correlator;

  LOG_INFO(LOG_CTX_PTIN_INTF, "Going to send message: event=%u, intIfNum=%u", event, intIfNum);

  rc = osapiMessageSend(dot3ad_queue, &msg, (L7_uint32)DOT3AD_MSG_SIZE, L7_NO_WAIT, L7_MSG_PRIORITY_NORM);

  return rc;
}

/*********************************************************************
* @purpose  Process the startup callback notification for all the interfaces from NIM
*
* @param    NIM_STARTUP_PHASE_t the startup phase NIM_INTERFACE_CREATE_STARTUP for create
*           NIM_INTERFACE_ACTIVATE_STARTUP for activate.
*
* @returns  void
*
* @notes    
*       
* @end
*********************************************************************/
void dot3adIntfStartupCallback(NIM_STARTUP_PHASE_t startup_phase)
{
  L7_RC_t rc = L7_FAILURE;
  dot3adMsg_t msg;

  memset((void *)&msg,0,sizeof(dot3adMsg_t));
  msg.event = lacNimIntfStartup;
  msg.intfData.p = startup_phase;


  rc = osapiMessageSend(dot3ad_queue, &msg, (L7_uint32)DOT3AD_MSG_SIZE, L7_NO_WAIT, L7_MSG_PRIORITY_NORM);
  if (rc != L7_SUCCESS)
  {
    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT3AD_COMPONENT_ID, 
           "Cannot send message to Dot3ad Queue rc(%d)", rc);
  }

  return;

}
/*********************************************************************
* @purpose  Process the startup callback notification for all the interfaces from NIM
*
* @param    NIM_STARTUP_PHASE_t the startup phase NIM_INTERFACE_CREATE_STARTUP for create
*           NIM_INTERFACE_ACTIVATE_STARTUP for activate.
*
* @returns  void
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t dot3adIntfStartupCallbackProcess(NIM_STARTUP_PHASE_t startup_phase)
{
  L7_RC_t rc;
  L7_uint32 intIfNum;
  PORTEVENT_MASK_t nimEventMask;

  DOT3AD_DEBUG_NSF_PRINT_DEBUG(DOT3AD_DEBUG_NSF_NIM_TRACE, "%s ", 
                               __FUNCTION__);

  memset(&nimEventMask, 0, sizeof(nimEventMask));
  switch (startup_phase)
  {
    case NIM_INTERFACE_CREATE_STARTUP:
      rc = nimFirstValidIntfNumber(&intIfNum);
      
      while (rc == L7_SUCCESS)
      {
          if (dot3adIntfCreate(intIfNum) != L7_SUCCESS)
          {
              L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
              nimGetIntfName(intIfNum, L7_SYSNAME, ifName);

              L7_LOGF(L7_LOG_SEVERITY_ERROR,L7_DOT3AD_COMPONENT_ID, 
                      "Error in creating Intf %s ", ifName);
              continue;
          }
          rc = nimNextValidIntfNumber(intIfNum, &intIfNum);
      }
      
      PORTEVENT_SETMASKBIT(nimEventMask, L7_CREATE);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_DELETE);
      nimRegisterIntfEvents(L7_DOT3AD_COMPONENT_ID, nimEventMask);
      break;

    case NIM_INTERFACE_ACTIVATE_STARTUP:
      rc = dot3adNimActivateStartup();
       /* Now ask NIM to send any future changes for these event types */
      PORTEVENT_SETMASKBIT(nimEventMask, L7_CREATE);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_DELETE);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_ATTACH);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_DETACH);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_PORT_ENABLE);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_PORT_DISABLE);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_UP);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_DOWN);
      PORTEVENT_SETMASKBIT(nimEventMask, L7_SPEED_CHANGE);
      nimRegisterIntfEvents(L7_DOT3AD_COMPONENT_ID, nimEventMask);
      break;
      
    default:
      break;
  }

  nimStartupEventDone(L7_DOT3AD_COMPONENT_ID);
  DOT3AD_DEBUG_NSF_PRINT_DEBUG(DOT3AD_DEBUG_NSF_NIM_TRACE, "%s ", __FUNCTION__);
  
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Perform a cold start on an interface
*
* @param    NIM_STARTUP_PHASE_t the startup phase NIM_INTERFACE_CREATE_STARTUP for create
*           NIM_INTERFACE_ACTIVATE_STARTUP for activate.
*
* @returns  void
*
* @notes    Clear out all the known information for an interface (if any)
*           and initiate the structure with default values.
*       
* @end
*********************************************************************/
void dot3adIntfColdRestart(L7_uint32 intIfNum)
{
  L7_RC_t rc;
  L7_BOOL adminMode = L7_ENABLE;
  L7_uint32 linkState;
  dot3ad_port_t *p;
  dot3ad_agg_t *agg;

  do
  {
    rc = dot3adIntfAttach(intIfNum);

    if (nimGetIntfLinkState(intIfNum,&linkState) != L7_SUCCESS)
    {
      linkState = L7_DOWN;
    }

    nimGetIntfAdminState(intIfNum,&adminMode);

    if ((linkState == L7_UP) || (adminMode == L7_ENABLE))
    {
      p = dot3adPortIntfFind(intIfNum);
  

      /* nothing to do, perform callback */
      if (p == L7_NULL)
      {
        rc = L7_SUCCESS;
        break;
      }

      if (dot3adLihIntfSpeedGet(intIfNum, &dot3adOperPort[intIfNum].linkSpeed) != L7_SUCCESS)
      {
        rc = L7_SUCCESS;
        break;
      }
      dot3adOperPort[intIfNum].fullDuplex = dot3adLihIsIntfSpeedFullDuplex(intIfNum);
      
      /* only process UP events on Physical intf that are part of a LAG */
      if (dot3adIsLagMember(intIfNum) == L7_FALSE)
      {
        rc = L7_SUCCESS;
        break;
      }

      
      if (linkState == L7_UP && adminMode == L7_ENABLE)
      {
        p->portEnabled = L7_TRUE;
        /* check if aggregator of the port is static and send lacpPortEnabledStaticLag 
           instead of lacpPortEnabledLacpEnabled or lacpPortEnabledLacpDisabled accordingly*/
        agg=dot3adAggKeyFind(p->actorOperPortKey);
        if (agg == L7_NULLPTR)
        {
          /* error , port belongs to a Lag, but we cannot find aggregate */
          /* Log error and break */
          /* return set to success for callback*/
          rc = L7_SUCCESS;
          break;
        }
        rc = LACIssueCmd(lacpBegin, p->actorPortNum, L7_NULL);
        if (agg->isStatic == L7_TRUE)
        {
          rc = LACIssueCmd(lacpPortEnabledStaticLag,p->actorPortNum,L7_NULL);
        }
        else
        {
          if (p ->lacpEnabled == L7_FALSE)
          {
            rc = LACIssueCmd(lacpPortEnabledLacpDisabled, p->actorPortNum, L7_NULL);
          }
          else if (p ->lacpEnabled == L7_TRUE)
          {
            rc = LACIssueCmd(lacpPortEnabledLacpEnabled, p->actorPortNum, L7_NULL);
          }
         
        }/* mode = static*/
      }
    } /* Link state is up or admin enabled*/

  }
  while (L7_FALSE);

}

/*********************************************************************
* @purpose  Process an ACTIVATE callback during startup
*
* @param    
*
* @returns  L7_SUCCESS   if succesful
*
* @notes    Get a list of valid interfaces from NIM, for each interface
*           If the restart is warm use check pointed data and reconcile
*           if not perform a cold restart on that interface.
*           notify nim about interested events to begin receiving those notifications
*       
* @end
*********************************************************************/
L7_RC_t dot3adNimActivateStartup()
{
  L7_RC_t rc;
  L7_uint32 intIfNum;
  L7_uint32 startTime;

  startTime = osapiTimeMillisecondsGet();

  DOT3AD_DEBUG_NSF_PRINT_DEBUG(DOT3AD_DEBUG_NSF_NIM_TRACE,
               "Begining Activate startup for dot3ad restart type %s\n",
               (dot3adCnfgrIsRestartTypeWarm() == L7_TRUE) ? "WARM" : "COLD");
 
  rc = nimFirstValidIntfNumber(&intIfNum);
      
  while (rc == L7_SUCCESS)
  {

#ifdef L7_NSF_PACKAGE
    if (dot3adCnfgrIsRestartTypeWarm() == L7_TRUE)
        dot3adIntfReconcile(intIfNum);
    else
#endif
       dot3adIntfColdRestart(intIfNum);

    rc = nimNextValidIntfNumber(intIfNum, &intIfNum);
  }

#ifdef L7_NSF_PACKAGE
  if (dot3adCnfgrIsRestartTypeWarm() == L7_TRUE)
  {
    L7_int32 timeout = L7_WAIT_FOREVER;

    if (cnfgrHwTallyTimeoutGet(L7_CNFGR_HW_APPLY_CONFIG, &timeout) != L7_SUCCESS)
    {
      L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DOT3AD_COMPONENT_ID,
              "Failed to get the Hw Tally timeout value for phase %d\n",
              L7_CNFGR_HW_APPLY_CONFIG);
    } 

    /* Wait for the driver to catch up*/
    dtlDot3adSynchronize(timeout);

    dot3adSwitchoverInProgress = L7_FALSE;
    dot3adCheckPtDataClean();
    dot3adTransportBcastHelperCtlMsg(DOT3AD_HELPER_SWITCHOVER_DONE);
  }
#endif

  cnfgrApiComponentHwUpdateDone(L7_DOT3AD_COMPONENT_ID, L7_CNFGR_HW_APPLY_CONFIG);
  
  DOT3AD_DEBUG_NSF_PRINT_DEBUG(DOT3AD_DEBUG_NSF_NIM_TRACE,
                               "Dot3ad reconcile done in %d ms\n",
                               (osapiTimeMillisecondsGet() - startTime));
  return L7_SUCCESS;

}

/*********************************************************************
* @purpose  dot3ad task which serves the request queue
*
* @param    
*
* @returns  void
*
* @notes    User-interface writes and LACPDUs are serviced off
*           of the dot3ad_queue
*       
* @end
*********************************************************************/
void dot3ad_lac_task()
{
  dot3adMsg_t msg;
  L7_uint32 status;
  L7_RC_t rc;

  dot3ad_queue = (void*)osapiMsgQueueCreate("dot3ad_queue", dot3adSidTimerMsgCountGet(),
                                            (L7_uint32)DOT3AD_MSG_SIZE);

  rc = osapiTaskInitDone(L7_DOT3AD_CORE_TASK_SYNC);

  if (dot3ad_queue == L7_NULLPTR)
  {
    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
            "LAG: Unable to create msg queue for dot3ad_lac_task\n");
    return;
  }

  for (;;)
  {

    status = (L7_uint32)osapiMessageReceive(dot3ad_queue,
                                            (void*)&msg,
                                            (L7_uint32)DOT3AD_MSG_SIZE,
                                            L7_WAIT_FOREVER);

    rc = osapiSemaTake(dot3adTaskSyncSema, L7_WAIT_FOREVER);
    rc = LACDispatchCmd(msg);
	rc = osapiSemaGive(dot3adTaskSyncSema);
  }
}

/*********************************************************************
* @purpose  dot3ad timer task which serves the expired timers
*
* @param    
*
* @returns  void
*
* @notes    
*           
*       
* @end
*********************************************************************/
void dot3ad_timer_task()
{
  dot3adTimerMsg_t msg;
  L7_uint32 status;
  L7_RC_t rc;

  dot3ad_timer_queue = (void*)osapiMsgQueueCreate("dot3ad_timer_queue", dot3adSidTimerMsgCountGet(),
                                                  (L7_uint32)sizeof(dot3adTimerMsg_t));

  rc = osapiTaskInitDone(L7_DOT3AD_TIMER_TASK_SYNC);

  if (dot3ad_timer_queue == L7_NULLPTR)
  {
    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
            "LAG: Unable to create msg queue for dot3ad_timer_task\n");
    return;
  }

  for (;;)
  {

    status = (L7_uint32)osapiMessageReceive(dot3ad_timer_queue,
                                            (void*)&msg,
                                            (L7_uint32)sizeof(dot3adTimerMsg_t),
                                            L7_WAIT_FOREVER);
	rc = osapiSemaTake(dot3adTaskSyncSema, L7_WAIT_FOREVER);
    switch (msg.msgId)
	{
	  case PERIODIC_EXPIRED:
		rc = dot3adPeriodicTimerExpired(msg.parm1, msg.parm2);
		break;
	  case NTT_EXPIRED:
	    rc = dot3adNttTimerExpired(msg.parm1, msg.parm2);
		break;
	  case CURRENT_EXPIRED:
		rc = dot3adCurrentWhileTimerExpired(msg.parm1, msg.parm2);
		break;
	  case WAIT_EXPIRED:
		rc = dot3adWaitWhileTimerExpired(msg.parm1, msg.parm2);
		break;

	  default:
		break;
	}
	rc = osapiSemaGive(dot3adTaskSyncSema);
  }
}


/*********************************************************************
* @purpose  Send a command to LAC
*
* @param    event       Event type
* @param    *data       pointer to data
*
* @returns  L7_SUCCESS or L7_FALIURE
*
* @notes    Command will be queued for service
*       
* @end
*********************************************************************/
L7_RC_t LACIssueCmd(L7_uint32 event, L7_uint32 intf, void* data)
{
  L7_RC_t rc;

  /* find storage for new msg, possibly add to another queue */
  dot3adMsg_t msg;
  dot3ad_port_t *p;
  dot3ad_agg_t *a;
  L7_uint32 adminMode = L7_ENABLE;

  /* copy event, intf, data ptr to msg struct */
  msg.event = event;
  msg.intf = intf;
  /*find if the intf in a port intf or a agg intf*/
  /*find if the agg is administratively disabled*/
  if (event != AGG_STATIC_MODE)
  {
  p = dot3adPortIntfFind(intf);
  if (p == L7_NULLPTR)
  {
    a = dot3adAggIntfFind(intf);
    if (a == L7_NULLPTR)
    {
      return L7_FAILURE;
    }
    else
    {
      adminMode = a->adminMode;
    }
  }
  else
  {
    a = dot3adAggIntfFind(p->actorPortWaitSelectedAggId);
    if (a != L7_NULLPTR)
    {
      adminMode = a->adminMode;
    }
  }
  }

  if (adminMode == L7_ENABLE || 
	  event == NIM_INTF_CHANGE ||
          event == AGG_ADMIN_MODE ||
	  event == AGG_STATIC_MODE)
  {

	if (data != L7_NULL && data != L7_NULLPTR)
	  (void)dot3adFillMessage(data,&msg);

    /* For messages that involve configuration must set the data chnaged flag */
    if ((event >= AGG_ACTOR_SYSTEM_PRIORITY &&
         event != LACPDU_RECEIVE &&
         event != NIM_INTF_CHANGE) ||
        event == lacDeletePort)
    {
      dot3adCfg.hdr.dataChanged = L7_TRUE;
    }

    /* send msg */
    rc = osapiMessageSend(dot3ad_queue, &msg, (L7_uint32)DOT3AD_MSG_SIZE, L7_NO_WAIT, L7_MSG_PRIORITY_NORM);

    return rc;
  }
  else
    /* return a L7_SUCCESS as nim needs to know that the event was
	 * successfully dealt with. If a failure is returned nim logs 
	 * an error and resets the device
	 */
	return L7_SUCCESS;

}

/*********************************************************************
* @purpose  Save the data in a message to a shared memory
*
* @param    event       Event type
* @param    *data       pointer to data
*
* @returns  L7_SUCCESS or L7_FALIURE
*
* @notes    Once the message is serviced, this variable size data will
*           be retrieved
*       
* @end
*********************************************************************/
L7_RC_t dot3adFillMessage(void* data, dot3adMsg_t *msg)
{

  switch (msg->event)
  {
  case AGG_ACTOR_SYSTEM_PRIORITY:
  case PORT_ACTOR_SYSTEM_PRIORITY:
  case PORT_PARTNER_ADMIN_SYSTEM_PRIORITY:
  case AGG_ACTOR_ADMIN_KEY:
  case PORT_PARTNER_ADMIN_KEY:
  case PORT_ACTOR_PORT_PRIORITY:
  case PORT_PARTNER_ADMIN_PORT:
  case PORT_PARTNER_ADMIN_PORT_PRIORITY:
  case PORT_ACTOR_ADMIN_KEY:
  case PORT_ACTOR_OPER_KEY:
  case AGG_COLLECTOR_MAX_DELAY:
  case AGG_INUSE:
  case AGG_STATIC_MODE:
    /* add to queue L7_uint32 size */
    memcpy(&msg->intfData.p, data, sizeof(L7_uint32));
    break;

  case AGG_ADMIN_MODE:
    memcpy(&msg->intfData.adminMode, data, sizeof(msg->intfData.adminMode));
    break;

  case PORT_PARTNER_ADMIN_SYSTEM_ID:
  case PORT_PARTNER_OPER_SYSTEM_ID:
    /* add to queue mac address */
    memcpy(&msg->intfData.mac, data, sizeof(L7_enetMacAddr_t));
    break;

  case PORT_ACTOR_ADMIN_STATE:
  case PORT_PARTNER_ADMIN_STATE:  
    /* add to queue one byte */
    memcpy(&msg->intfData.state, data, sizeof(L7_uchar8));
    break;

  case LACPDU_RECEIVE:
    /* add to queue a bufhandle */
    msg->intfData.bufHandle = data;
    break;

  case AGG_NAME:
    /* add to queue agg name */
    memcpy(&msg->intfData.name, data, L7_DOT3AD_MAX_NAME);
    break;

  case AGG_HASHMODE_SET:
    /* add to queue hashMode */
    memcpy(&msg->intfData.p, data, sizeof(L7_uint32));
    break;

  default:
    /* unmatched event */
    break;

  }

  return L7_SUCCESS;

}

/*********************************************************************
* @purpose  Route the event to a handling function and grab the parms
*
* @param    event       Event type
* @param    intf        Interface
* @param    *data       pointer to data
*
* @returns  L7_SUCCESS or L7_FALIURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t LACDispatchCmd(dot3adMsg_t msg)
{
  L7_RC_t rc;
  dot3ad_port_t *p;
  L7_uint32 nullBuf = 0;             /* buffer not needed in call to dot3adReceiveMachine */

  switch (msg.event)
  {
  /* 4 byte priorities/keys/ports */
  case AGG_ACTOR_SYSTEM_PRIORITY:
    rc = aggActorSystemPrioritySet(msg.intf, msg.intfData.p);
    break;

  case PORT_ACTOR_SYSTEM_PRIORITY:
    rc = aggPortActorSystemPrioritySet(msg.intf, msg.intfData.p);
    break;

  case PORT_PARTNER_ADMIN_SYSTEM_PRIORITY:
    rc = aggPortPartnerAdminSystemPrioritySet(msg.intf, msg.intfData.p);
    break;

  case AGG_ACTOR_ADMIN_KEY:
    rc = aggActorAdminKeySet(msg.intf, msg.intfData.p);
    break;

  case PORT_PARTNER_ADMIN_KEY:
    rc = aggPortPartnerAdminKeySet(msg.intf, msg.intfData.p);
    break;

  case PORT_ACTOR_PORT_PRIORITY:
    rc = aggPortActorPortPrioritySet(msg.intf, msg.intfData.p);
    break;

  case PORT_PARTNER_ADMIN_PORT:
    rc = aggPortPartnerAdminPortSet(msg.intf, msg.intfData.p);
    break;

  case PORT_PARTNER_ADMIN_PORT_PRIORITY:
    rc = aggPortPartnerAdminPortPrioritySet(msg.intf, msg.intfData.p);
    break;

  case PORT_ACTOR_ADMIN_KEY:
    rc = aggPortActorAdminKeySet(msg.intf, msg.intfData.p);
    break;

  case PORT_ACTOR_OPER_KEY:
    rc = aggPortActorOperKeySet(msg.intf, msg.intfData.p);
    break;

  case AGG_COLLECTOR_MAX_DELAY:
    rc = aggCollectorMaxDelaySet(msg.intf, msg.intfData.p);
    break;
/****
  case lacAttach:
  case lacDetach:
    rc = aggLACAttach(msg.intf);
    break;
****/

  case lacCollDistEnable:
    rc = aggCollDistEnable(msg.intf);
    break;
  case lacCollDistDisable:
    rc = aggCollDistDisable(msg.intf);
    break;

    /* 6 byte IDs */
  case PORT_PARTNER_ADMIN_SYSTEM_ID:
    rc = aggPortPartnerAdminSystemIDSet(msg.intf, msg.intfData.mac);
    break;

  case PORT_PARTNER_OPER_SYSTEM_ID:
    rc = aggPortPartnerOperSystemIDSet(msg.intf, msg.intfData.mac);
    break;

    /* 1 byte states */
  case PORT_ACTOR_ADMIN_STATE:
    rc = aggPortActorAdminStateSet(msg.intf, msg.intfData.state);
    break;

  case PORT_PARTNER_ADMIN_STATE:
    rc = aggPortPartnerAdminStateSet(msg.intf, msg.intfData.state);
    break;

  case LACPDU_RECEIVE:
    rc = LACPDUReceive(msg.intf, msg.intfData.bufHandle);
    break;

  case AGG_INUSE:
    rc = aggInuseSet(msg.intf, msg.intfData.p);
    break;

  case AGG_NAME:
    rc = aggPortNameSet(msg.intf, msg.intfData.name);
    break;

  case AGG_ADMIN_MODE:
    rc = aggAdminModeSet(msg.intf, msg.intfData.adminMode.status, msg.intfData.adminMode.updateConfig);
    break;

  case AGG_STATIC_MODE:
      rc = aggStaticModeSet(msg.intf, msg.intfData.p);
      break;

  case lacDeletePort:
    rc = aggPortDelete(msg.intf);
    break;

  case AGG_HASHMODE_SET:
    rc = aggPortHashModeSet(msg.intf, msg.intfData.p);
    break;

  case lacpBegin:
  case lacpPortEnabledLacpDisabled:
  case lacpPortEnabledLacpEnabled:
  case lacpPortEnabledStaticLag:
  case lacpPortDisabled:
  case lacpBeginFalsePortDisabledPortMovedFalse:
  case lacpDisabled:
  case lacpPortMoved:
  case lacpCurrentWhileTimerExpired:
  case lacpDisablePerMachine:
  case lacpEnablePerMachine:
  case lacpShortTimeOut:
  case lacpLongTimeOut:
  case lacpSelectedPartnerSyncTrue:
  case lacpPartnerSyncFalse:
  case lacpStandby:
  case lacpSelected:
  case lacpUnselected:
  case lacpSelectedReady:
  case lacpAttached:
  case lacpDetached:
    p = dot3adPortIntfFind(msg.intf);
      if (p == L7_NULLPTR)
      {
	    return L7_FAILURE;
      }
    rc = dot3adLacpClassifier(msg.event, p, (void *)&nullBuf);
    break;

    case lacNimIntfChange:
      LOG_INFO(LOG_CTX_PTIN_INTF, "Going to call dot3adIntfChangeCallBackProcess: event=%u, intIfNum=%u", msg.intfData.nimInfo.event, msg.intfData.nimInfo.intIfNum);
      rc = dot3adIntfChangeCallBackProcess(msg.intfData.nimInfo);
      break;

    case lacNimIntfStartup:
      rc = dot3adIntfStartupCallbackProcess(msg.intfData.p);
      break;

    case lacCnfgrChange:
      dot3adApiCnfgrCommandProcess(&msg.intfData.cnfgrInfo);
      rc = L7_SUCCESS;
      break;

  default:
    rc = L7_FAILURE;

  }
  if (msg.event >= AGG_ACTOR_SYSTEM_PRIORITY && msg.event != LACPDU_RECEIVE)
  {
	dot3adTablesLastChangedRecord();
  }
  return rc;

}

/*********************************************************************
* @purpose  Disable collection distribution on an interface
*
* @param    intf         internal interface that was changed
*
* @returns  L7_SUCCESS   
*           L7_FALIURE   
*
* @notes    Refreshes the active list and sends it to DTL
*           --removes this interface from the active list
*           
*       
* @end
*********************************************************************/
L7_RC_t aggCollDistDisable(L7_uint32 intf)
{
  dot3ad_port_t *p;
  dot3ad_port_t *attached_port;
  dot3ad_agg_t  *a;
  L7_uint32 tmpList[L7_MAX_MEMBERS_PER_LAG];
  L7_uint32 tmpCount=0;
  L7_uint32 i;
  L7_RC_t rc,rc1;
  L7_uint32 adminMode;
  L7_NIM_QUERY_DATA_t nimQueryData;

  p = dot3adPortIntfFind(intf);
  if (p == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  a = dot3adAggPortFind(intf);
  if (a == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  /* If the port is transitioning from disabled state
     then intf is not active member of a lag. no need to do anything
  */
  if (dot3adIsLagActiveMember(intf) != L7_TRUE)
  {
    return L7_SUCCESS;
  }

   /* inspect collection bits of the attached list members */
  for (i=0;i<a->currNumMembers;i++)
  {
    attached_port = dot3adPortIntfFind(a->aggPortList[i]);
    if (attached_port == L7_NULLPTR)
    {
      return L7_FAILURE;  
    }

    /* if collection bit is set on this attached port */
    if ((attached_port->actorOperPortState & DOT3AD_STATE_COLLECTING) != 0)
    {
      /* add it to the active list */
      /*tmpList[tmpCount] = a->aggPortList[i];*/
      tmpCount++;
    }
  }
  /*
  dtlLagConfig(a->aggId, a->currNumMembers, a->aggPortList,
               tmpCount,          tmpList);
               */
  /*
  dtlLagConfig(a->aggId, tmpCount, tmpList,
               tmpCount, tmpList);
  */

  tmpList[0] = intf;

  nimQueryData.intIfNum = intf;
  nimQueryData.request = L7_NIM_QRY_RQST_STATE;

  if (nimIntfQuery(&nimQueryData) != L7_SUCCESS)
  {
    /* should never get here */
    return L7_FAILURE;
  }
  else if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
           (nimQueryData.data.state == L7_INTF_DETACHING) ||
           (nimQueryData.data.state == L7_INTF_ATTACHED))
  {
    /* only talk to the hardware when the hardware is valid */
  rc = dtlDot3adPortDelete(a->aggId,1,tmpList, a->hashMode);
  if (rc == L7_REQUEST_DENIED || 
	  rc == L7_FAILURE || 
	  rc == L7_ERROR)
  {
	return rc;
  }
  }
  

  if (dot3adNsfFuncTable.dot3adCallCheckpointService)
  {
    dot3adNsfFuncTable.dot3adCallCheckpointService(intf,DOT3AD_NSF_OPCODE_DELETE);
  }

  /*dot3adLihMacroPortAssignmentReset(intf);*/
  /*Remove this port from the active list for this agg*/
  rc1 = dot3adAggActivePortDelete(a->aggId,intf);
  if (rc1 == L7_SUCCESS)
  {
  rc = dot3adLihNotifySystem(a->aggId, L7_SPEED_CHANGE);
  }


  /*delete this interface from the lag interface stats*/
  rc = dot3adCounterMutlingDelete(a->aggId, intf);
  dot3adLihNotifySystem(intf, L7_LAG_RELEASE);
  if (tmpCount == 0)/*no members in trunk table*/
  { 
    if (rc1 == L7_SUCCESS)
    {
    rc = dot3adLihNotifySystem(a->aggId, L7_DOWN);  
    }
    /*trace call*/
    dot3adAggTrace(a->aggId, DOT3AD_TRACE_LAG_DOWN);
  }
  
  rc = nimGetIntfAdminState(intf, &adminMode);
  if (rc == L7_SUCCESS && (adminMode == L7_DISABLE || adminMode == L7_DIAG_DISABLE))
  {
    if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
        (nimQueryData.data.state == L7_INTF_DETACHING) ||
        (nimQueryData.data.state == L7_INTF_ATTACHED))
    {
      /* only talk to the hardware when the hardware is valid */
    rc = dtlIntfAdminStateSet(intf, adminMode);
  }
  }

  return L7_SUCCESS;


}
/*********************************************************************
* @purpose  Enables collection distribution on an interface
*
* @param    intf         internal interface that was changed
*
* @returns  L7_SUCCESS   
*           L7_FALIURE   
*
* @notes    Refreshes the active list and sends it to DTL
*           --adds this interface from the active list
*       
* @end
*********************************************************************/
L7_RC_t aggCollDistEnable(L7_uint32 intf)
{
  dot3ad_port_t *p;
  dot3ad_port_t *attached_port = 0;
  dot3ad_agg_t  *a;
  L7_uint32 tmpList[L7_MAX_MEMBERS_PER_LAG];
  L7_uint32 tmpCount=0;
  L7_uint32 i;
  L7_RC_t rc;
  L7_NIM_QUERY_DATA_t nimQueryData;
  
  p = dot3adPortIntfFind(intf);
  if (p == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  a = dot3adAggPortFind(intf);
  if (a == L7_NULLPTR)
  {
    return L7_FAILURE;
  }
  /* inspect distribution bits of the attached list members */
  for (i=0;i<a->currNumMembers;i++)
  {
    attached_port = dot3adPortIntfFind(a->aggPortList[i]);
    if (attached_port == L7_NULLPTR)
    {
      return L7_FAILURE;  
    }

    /* if distribution bit is set on this attached port */
    if ((attached_port->actorOperPortState & DOT3AD_STATE_DISTRIBUTING) != 0)
    {
      /* add it to the active list */
      /*tmpList[tmpCount] = a->aggPortList[i];*/
      tmpCount++;
    }
  }
  /*
  dtlLagConfig(a->aggId, a->currNumMembers, a->aggPortList,
               tmpCount,          tmpList);
               */
  /*
  dtlLagConfig(a->aggId, tmpCount, tmpList,
               tmpCount, tmpList);
  */

  tmpList[0] = intf;

  nimQueryData.intIfNum = intf;
  nimQueryData.request = L7_NIM_QRY_RQST_STATE;

  if (nimIntfQuery(&nimQueryData) != L7_SUCCESS)
  {
    /* should never get here */
    return L7_FAILURE;
  }
  else if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
           (nimQueryData.data.state == L7_INTF_DETACHING) ||
           (nimQueryData.data.state == L7_INTF_ATTACHED))
  {
    /* only talk to the hardware when the hardware is valid */
  rc = dtlDot3adPortAdd(a->aggId,1,tmpList, a->hashMode);
  if (rc == L7_REQUEST_DENIED || 
	  rc == L7_FAILURE || 
	  rc == L7_ERROR)
  {
	return rc;
  }
  }
  
  if (dot3adNsfFuncTable.dot3adCallCheckpointService)
  {
    dot3adNsfFuncTable.dot3adCallCheckpointService(intf,DOT3AD_NSF_OPCODE_ADD);
  }
  
  /*Add this interface to the active port list for this agg*/
  rc = dot3adAggActivePortAdd(a->aggId, intf);
  
  rc = dot3adLihMacroPortAssignmentSet(a->aggId,intf);
  rc = dot3adLihNotifySystem(a->aggId, L7_SPEED_CHANGE);


  rc = dot3adCounterMutlingAdd(a->aggId, intf);

  rc = dot3adLihNotifySystem(intf, L7_LAG_ACQUIRE);
  if (tmpCount == 1)/*first member in the trunk table*/
  {
    rc = dot3adLihNotifySystem(a->aggId, L7_UP);
    /*trace call*/
    dot3adAggTrace(a->aggId, DOT3AD_TRACE_LAG_UP);
  }
  
  
  return L7_SUCCESS;
}
/*********************************************************************
* @purpose  Given a ports interface number, attach it to its selected
*           aggregator
*
* @param    intf         aggregator interface
*
* @returns  L7_SUCCESS   if all members attached
*           L7_FALIURE   if failure (agg doesn't exist)
*
* @notes    If attached list has members (configured) that aren't
*           yet functioning in the aggregation, this will add them in
*       
* @end
*********************************************************************/
L7_RC_t aggLACAttach(L7_uint32 intf)
{
/***
  
  dot3ad_agg_t *a;

  a = dot3adAggPortFind(intf);
  if (a == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  return dtlLagConfig(intf, a->currNumSelectedMembers, a->aggSelectedPortList,
                      a->currNumMembers,         a->aggPortList);

***/
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Decodes and services an incoming request from the stats
*           manager for a dot3ad statistic
*
* @param    c           Pointer to storage allocated by stats
                        manager to hold the results
*
* @returns  L7_SUCCESS or L7_FALIURE
*
* @notes    Only called by stats manager
*       
* @end
*********************************************************************/
void dot3adStatGet(void *statHandle)
{
  pCounterValue_entry_t c = (pCounterValue_entry_t)statHandle;
  c->status = L7_SUCCESS;
  c->cSize = C32_BITS;

  switch (c->cId)
  {
  case L7_PLATFORM_CTR_LAC_PDUS_RX:
    c->cValue.low = dot3ad_stats[c->cKey].LACPDUsRx;
    break;
  case L7_PLATFORM_CTR_MARKER_PDUS_RX:
    c->cValue.low = dot3ad_stats[c->cKey].MarkerPDUsRx;
    break;
  case L7_PLATFORM_CTR_UNKNOWN_RX:
    c->cValue.low = dot3ad_stats[c->cKey].UnknownRx;
    break;
  case L7_PLATFORM_CTR_ILLEGAL_RX:
    c->cValue.low = dot3ad_stats[c->cKey].IllegalRx;
    break;
  case L7_PLATFORM_CTR_LACP_PDUS_TX:
    c->cValue.low = dot3ad_stats[c->cKey].LACPDUsTx;
    break;
  case L7_PLATFORM_CTR_MARKER_RESPONSE_PDUS_TX:
    c->cValue.low = dot3ad_stats[c->cKey].MarkerPDUsTx;
    break;
  default:
    c->status = L7_FAILURE;
  }
}

/*********************************************************************
* @purpose  Clears the port statistics. 
*          
* @param    intIfNum @b{(input)} Internal Interface Number of the port
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments Clears all the LACPDU stats associated with this port. 
*
* @end
*********************************************************************/
L7_RC_t dot3adPortStatsClear(L7_uint32 intIfNum)
{
  L7_RC_t rc = L7_SUCCESS;

  dot3ad_stats[intIfNum].LACPDUsRx = L7_NULL;
  dot3ad_stats[intIfNum].MarkerPDUsRx = L7_NULL;
  dot3ad_stats[intIfNum].MarkerResponsePDUsRx = L7_NULL;
  dot3ad_stats[intIfNum].UnknownRx = L7_NULL;
  dot3ad_stats[intIfNum].IllegalRx = L7_NULL;
  dot3ad_stats[intIfNum].LACPDUsTx = L7_NULL;
  dot3ad_stats[intIfNum].MarkerPDUsTx = L7_NULL;
  dot3ad_stats[intIfNum].MarkerResponsePDUsTx = L7_NULL;
  dot3ad_stats[intIfNum].RxLACPDUsDropped = L7_NULL;

  return rc;
}
/*********************************************************************
* @purpose  Gets the internal Interface number given an agg Index
*
* @param    aggIndex    the index of the aggregator 
* @param    *agg_intf    pointer to aggregator internal interface number value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    AggIndex ranges from 0 to L7_MAX_NUM_LAG_INTF -1. 
*           (It is different from the aggId 1 - L7_MAX_NUM_LAG_INTF.)
*
* @end
*********************************************************************/
L7_RC_t aggIfNumFromIndexGet(L7_uint32 aggIndex, L7_uint32 * aggIntIfNum)
{
  dot3ad_agg_t *agg = L7_NULLPTR;

  agg = &dot3adAgg[aggIndex];
  if ((agg == L7_NULLPTR) || (agg->inuse != L7_TRUE))
  {
      /* Log message */
       *aggIntIfNum = L7_NULL;
       return L7_FAILURE;
  }

  *aggIntIfNum = agg->aggId;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Gets the aggIndex from agg internal Interface number
*
* @param    agg_intf     aggregator internal interface number
* @param    *aggIndex    pointer to aggIndex value.
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    AggIndex ranges from 0 to L7_MAX_NUM_LAG_INTF -1.
*
* @end
*********************************************************************/
L7_RC_t aggIndexFromIntfNumGet(L7_uint32 aggIntIfNum, L7_uint32 *aggIndex)
{
  if ( L7_NULLPTR == dot3adAggIntfFind(aggIntIfNum) )
  {
    return L7_FAILURE;
  }

  *aggIndex = dot3adAggIdx[aggIntIfNum] ;
  return L7_SUCCESS;

}

/*********************************************************************
* @purpose  Sets the aggregator in use flag.  If an aggregator is 
*           in-use, it has been created but may not be active or have
*           members.
*
* @param    agg_intf     aggregator internal interface number
* @param    status       in use or not
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/

L7_RC_t aggInuseSet(L7_uint32 agg_intf, L7_BOOL status)
{
  dot3ad_agg_t *a;
  L7_RC_t rc;

  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    a->inuse = status;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    rc = dot3adCounterReset(agg_intf);

    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the aggregator in use flag.  If an aggregator is 
*           in-use, it has been created but may not be active or have
*           members.
*
* @param    agg_intf     aggregator internal interface number
* @param    *status      in use or not
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggInuseGet(L7_uint32 agg_intf, L7_BOOL *status)
{
  dot3ad_agg_t *a;

  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    *status = a->inuse;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}
/*********************************************************************
* @purpose  Sets the aggregator admin mode flag.  If an aggregator is 
*           disabled then all the member ports will not be forwarding
*           traffic. lacpdus will be exchanged to maitain the aggregation.
*
* @param    agg_intf     aggregator internal interface number
* @param    status       L7_ENABLE or L7_DISABLE
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggAdminModeSet(L7_uint32 agg_intf, L7_uint32 status, L7_BOOL updateConfig)
{
  dot3ad_agg_t *a;
  L7_uint32 i;
  L7_BOOL fromDtoE = L7_FALSE;
  L7_RC_t rc;
  dot3ad_port_t *p;
  
  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    if (a->adminMode == L7_DISABLE && status == L7_ENABLE)
      fromDtoE = L7_TRUE;

    if (status == L7_ENABLE)
    {
	  /* We are enabling a lag port */
	  /* Update the adminMode with current status */
	  a->adminMode = status;

	  /* Nim will send out a notification of port enable for the lag port.
	   * No need to explicitly send out a port enable vent 
	   */
      
	  /* Enable all the configured members. Ensure the nim/dtl call is made */
        for (i = 0; i< a->currNumWaitSelectedMembers; i++)
          {
            p = dot3adPortIntfFind(a->aggWaitSelectedPortList[i]);

            if (p != L7_NULLPTR)
            {
          rc = dot3adLihIntfAdminStateSet(p->actorPortNum, L7_ENABLE, updateConfig);
        }
	  }
	  
	  /* When dot3ad receives the individual port enable and link ups the 
	   * port will moved to the next states.
	   */
	}
              else
	{
	  /* We are disabling a lag port */
	  /* Delete Active members and send out lag release notifications*/
      for (i = 0; i< a->activeNumMembers; i++)
	  {
		p = dot3adPortIntfFind(a->aggActivePortList[i]);

		if (p != L7_NULLPTR)
        {
                p->portEnabled = L7_FALSE;

		  rc = LACIssueCmd(lacpPortDisabled, p->actorPortNum, L7_NULL);


		  if ((p -> begin == L7_FALSE) && (p -> aggPortMoved == L7_FALSE))
		  {
			rc = LACIssueCmd(lacpBeginFalsePortDisabledPortMovedFalse, p->actorPortNum, L7_NULL);
		  }

		  (void)dot3adSelectionLogicUnselect(p);
		  (void)dot3adSelectionLogicUnselect(p);
		}
	  }
      
	  /* Admin Disable all the configured members. Ensure nim/dtl call is made */
	  for (i = 0; i< a->currNumWaitSelectedMembers; i++)
	  {
		p = dot3adPortIntfFind(a->aggWaitSelectedPortList[i]);

		if (p != L7_NULLPTR)
        {
          rc = dot3adLihIntfAdminStateSet(p->actorPortNum, L7_DISABLE, updateConfig);
        }
	  }

	  /* Update the adminMode with the current status*/
	  a->adminMode = status;
	  /* Nim will send a port disable notification to the system and 
	   * while deleting the last active member a link down would have
	   * also been sent if there had been an active member. So there 
	   * is no need to explicitly send a port disable or a link down 
	   * event.
	   */
	  
	}
	
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}
/*********************************************************************
* @purpose  Gets the aggregator admin mode flag.  
*
* @param    agg_intf     aggregator internal interface number
* @param    *status      admin mode
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggAdminModeGet(L7_uint32 agg_intf, L7_uint32 *status)
{
  dot3ad_agg_t *a;

  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    *status = a->adminMode;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the text name associated with this aggregator
*
* @param    agg_intf     aggregator internal interface number
* @param    *name        pointer to allocated storage
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    max length of L7_DOT3AD_MAX_NAME characters
*       
* @end
*********************************************************************/
L7_RC_t aggPortNameGet(L7_uint32 agg_intf, L7_uchar8 *name)
{
  dot3ad_agg_t *a;

  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    strcpy((L7_char8 *)name, (L7_char8 *)a->name);
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the text name for this aggregator
*
* @param    agg_intf     aggregator internal interface number
* @param    *name        pointer to L7_DOT3AD_MAX_NAME characters
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortNameSet(L7_uint32 agg_intf, L7_uchar8 *name)
{
  dot3ad_agg_t *a;

  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    osapiStrncpySafe((L7_char8 *)a->name, (L7_char8 *)name, sizeof(a->name));
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the Hash Mode for a LAG.
*
* @param    agg_intf     aggregator internal interface number
* @param    hashMode     Hash Mode value, enumerated by L7_DOT3AD_HASH_MODE_t
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
*********************************************************************/
L7_RC_t aggPortHashModeSet(L7_uint32 agg_intf, L7_uint32 hashMode)
{
  dot3ad_agg_t *a;
  L7_RC_t rc = L7_FAILURE;

  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    rc = dtlDot3adHashModeSet (agg_intf, hashMode);
    if (rc == L7_SUCCESS)
    {
      a->hashMode = hashMode;
      /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    }
  }

  return rc;
}

/*********************************************************************
* @purpose  Gets the Hash Mode for a LAG.
*
* @param    agg_intf     aggregator internal interface number
* @param    *hashMode    pointer to Hash Mode value, enumerated by L7_DOT3AD_HASH_MODE_t
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
*********************************************************************/
L7_RC_t aggPortHashModeGet(L7_uint32 agg_intf, L7_uint32 * hashMode)
{
  dot3ad_agg_t *a = L7_NULLPTR;
  L7_RC_t rc = L7_FAILURE;

  a = dot3adAggIntfFind(agg_intf);
  if (a != L7_NULLPTR)
  {
    *(hashMode) = a->hashMode;

    rc = L7_SUCCESS;
  }

  return rc;
}

/*********************************************************************
* @purpose  Gets the most recent change to the dot3adAggTable,
*           dot3adAggPortListTable or the dot3adAggPortTable
*
* @param    *time      time of last change
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t tablesLastChangedGet(L7_timespec *time)
{
  memcpy((void*)time, (void*)&dot3adSystem.timeOfLastTableChange, sizeof(L7_timespec));
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Gets the MAC address assigned to the aggregator
*
* @param    InterfaceIndex  interface
* @param    *mac            MAC address, L7_MAC_ADDR_LEN in length
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggMACAddressGet(L7_uint32 InterfaceIndex, L7_uchar8 *mac)
{
  dot3ad_agg_t *p;
  L7_RC_t rc = L7_FAILURE;

  p = dot3adAggIntfFind(InterfaceIndex);

  if (p != L7_NULLPTR)
  {
    rc = nimGetIntfAddress(InterfaceIndex,L7_NULL,mac);
  }

  return rc;
}

/*********************************************************************
* @purpose  Gets the priority value associated with the system's actor ID
*
* @param    InterfaceIndex  interface
* @param    *priority       priority, 0-64k
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggActorSystemPriorityGet(L7_uint32 InterfaceIndex, L7_uint32 *priority)
{

  *priority = dot3adSystem.actorSysPriority;

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Sets the priority value associated with the system's actor ID
*
* @param    InterfaceIndex  interface
* @param    priority        priority, 0-64k
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggActorSystemPrioritySet(L7_uint32 InterfaceIndex, L7_uint32 priority)
{
  dot3adSystem.actorSysPriority = priority;

  /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Gets the MAC address used as a unique identifier for the 
*           system that contains this aggregator
*
* @param    InterfaceIndex  interface
* @param    *mac            MAC identifier
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggActorSystemIDGet(L7_uint32 InterfaceIndex, L7_enetMacAddr_t *mac)
{
  memcpy(mac, &dot3adSystem.actorSys, sizeof(L7_enetMacAddr_t));
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Determines if the aggregator represents an aggregate or 
*           an individual link
*
* @param    InterfaceIndex  interface
* @param    *link           L7_TRUE: aggregate
*                           L7_FALISE: individual
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggActorAggregateOrIndividualGet(L7_uint32 InterfaceIndex, L7_BOOL *link)
{
  dot3ad_agg_t *p;

  p = dot3adAggIntfFind(InterfaceIndex);
  if (p != L7_NULLPTR)
  {
    *link = p->individualAgg;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the current administrative value of the Key for the
*           aggregator 
*
* @param    InterfaceIndex  interface
* @param    *key            key value, 16bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    admin and oper key may differ
*       
* @end
*********************************************************************/
L7_RC_t aggActorAdminKeyGet(L7_uint32 InterfaceIndex, L7_uint32 *key)
{
  dot3ad_agg_t *p;

  p = dot3adAggIntfFind(InterfaceIndex);
  if (p != L7_NULLPTR)
  {
    *key = p->actorAdminAggKey;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the current administrative value of the Key for the
*           aggregator 
*
* @param    InterfaceIndex  interface
* @param    key             key value, 16bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    admin and oper key may differ
*       
* @end
*********************************************************************/
L7_RC_t aggActorAdminKeySet(L7_uint32 InterfaceIndex, L7_uint32 key)
{
  dot3ad_agg_t *a;
  L7_uint32 i;

  a = dot3adAggIntfFind(InterfaceIndex);
  if (a != L7_NULLPTR)
  {
    a->actorAdminAggKey = key;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    for (i=0;i<a->currNumWaitSelectedMembers;i++)
    {
      /*return the added members in waiting to be selected list*/
      aggPortActorOperKeySet(a->aggWaitSelectedPortList[i], key);
    }

    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the current operational value of the Key for the
*           aggregator 
*
* @param    InterfaceIndex  interface
* @param    *key            key value, 16bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    admin and oper key may differ
*       
* @end
*********************************************************************/
L7_RC_t aggActorOperKeyGet(L7_uint32 InterfaceIndex, L7_uint32 *key)
{
  dot3ad_agg_t *p;

  p = dot3adAggIntfFind(InterfaceIndex);
  if (p != L7_NULLPTR)
  {
    *key = p->actorOperAggKey;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  MAC address of current partner of aggregator
*
* @param    InterfaceIndex  interface
* @param    *mac            MAC address
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    a value 0 indicates there is no known partner
*       
* @end
*********************************************************************/
L7_RC_t aggPartnerSystemIDGet(L7_uint32 InterfaceIndex, L7_uint32 *mac)
{
  dot3ad_agg_t *p;

  p = dot3adAggIntfFind(InterfaceIndex);
  if (p != L7_NULLPTR)
  {
    memcpy(mac,&p->partnerSys,sizeof(L7_enetMacAddr_t));
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Priority value associated with partner's system ID
*
* @param    InterfaceIndex  interface
* @param    *priority       priority value, 16bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    If the aggregation is manually configured, it will be a
*           value assigned by the local system
*       
* @end
*********************************************************************/
L7_RC_t aggPartnerSystemPriorityGet(L7_uint32 InterfaceIndex, L7_uint32 *priority)
{
  dot3ad_agg_t *p;

  p = dot3adAggIntfFind(InterfaceIndex);
  if (p != L7_NULLPTR)
  {
    *priority = p->partnerSysPri;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  The current operational value of the key for the aggregators
*           current protocol partner. aggregator parser and either
*           delivering it to a MAC client or discarding it
*
* @param    InterfaceIndex  interface
* @param    *key            operational key
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    If the aggregation is manually configured, it will be a
*           value assigned by the local system
*       
* @end
*********************************************************************/
L7_RC_t aggPartnerOperKeyGet(L7_uint32 InterfaceIndex, L7_uint32 *key)
{
  dot3ad_agg_t *p;

  p = dot3adAggIntfFind(InterfaceIndex);
  if (p != L7_NULLPTR)
  {
    *key = p->partnerOperAggKey;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Delay that can be imposed on the frame collector between
*           receving a frame from and aggregator parser and either
*           delivering it to a MAC client or discarding it
*
* @param    intf            interface
* @param    *delay          10s of usecs
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggCollectorMaxDelayGet(L7_uint32 intf, L7_uint32 *delay)
{
  dot3ad_agg_t *a;

  a = dot3adAggIntfFind(intf);
  if (a != L7_NULLPTR)
  {
    *delay = a->collectorMaxDelay;
    return L7_SUCCESS;
  }
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Delay that can be imposed on the frame collector between
*           receving a frame from and aggregator parser and either
*           delivering it to a MAC client or discarding it
*
* @param    intf            interface
* @param    *delay          10s of usecs
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggCollectorMaxDelaySet(L7_uint32 intf, L7_uint32 delay)
{
  dot3ad_agg_t *a;

  a = dot3adAggIntfFind(intf);
  if (a != L7_NULLPTR)
  {
    a->collectorMaxDelay = delay;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the priority value associated with the system actor's ID
*
* @param    intf            interface
* @param    *priority       0..255
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorSystemPriorityGet(L7_uint32 intf, L7_uint32 *priority)
{
  *priority = dot3adSystem.actorSysPriority;

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Sets the priority value associated with the system actor's ID
*
* @param    intf            interface
* @param    *priority       0..255
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorSystemPrioritySet(L7_uint32 intf, L7_uint32 priority)
{
  dot3adSystem.actorSysPriority = priority;
  /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Gets the system id for the system that contains this 
*           aggregation port
*
* @param    intf            interface
* @param    *mac            system id
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorSystemIDGet(L7_uint32 intf, L7_uint32 *mac)
{
  memcpy(mac, &dot3adSystem.actorSys, sizeof(L7_enetMacAddr_t));
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Gets current administrative value of the key for the
*           aggregation port
*
* @param    intf            interface
* @param    *key            key, 16 bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorAdminKeyGet(L7_uint32 intf, L7_uint32 *key)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *key = p->actorAdminPortKey;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}


/*********************************************************************
* @purpose  Sets current administrative value of the key for the
*           aggregation port
*
* @param    intf            interface
* @param    key             key, 16 bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorAdminKeySet(L7_uint32 intf, L7_uint32 key)
{
  dot3ad_port_t *p;
  dot3ad_agg_t  *a;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    p->actorAdminPortKey = key;
    if (key == L7_NULL)
    {
      a = dot3adAggIntfFind(p->actorPortWaitSelectedAggId);
      if (a != L7_NULL)
      {
        key = a->actorAdminAggKey;
      }
  
    }
    return aggPortActorOperKeySet(intf, key);

  }

    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets current operational value of the key for the
*           aggregation port
*
* @param    intf            interface
* @param    *key             key, 16 bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorOperKeyGet(L7_uint32 intf, L7_uint32 *key)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *key = p->actorOperPortKey;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets current operational value of the key for the
*           aggregation port
*
* @param    intf            interface
* @param    key             key, 16 bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorOperKeySet(L7_uint32 intf, L7_uint32 key)
{
  dot3ad_port_t *p;
  dot3ad_agg_t  *a;
  L7_uint32 linkState;
  L7_RC_t rc;


  p = dot3adPortIntfFind(intf);

  if (p != L7_NULLPTR)
  {
    /*set the new operational key */
    p->actorOperPortKey = key;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/

    rc = nimGetIntfLinkState(p->actorPortNum,&linkState);
    if (linkState == L7_UP)
      p->portEnabled = L7_TRUE;
    else
      p->portEnabled = L7_FALSE;

    if (dot3adSwitchoverInProgress == L7_TRUE)
    {
      return L7_SUCCESS;
    }
    rc = LACIssueCmd(lacpBegin, p->actorPortNum, L7_NULL);
    if (linkState == L7_UP)
    {
      /* check if mode = static , send lacpPortEnabledStaticLag event */
      a = dot3adAggKeyFind(key);
      if ((a != L7_NULLPTR) &&
        (a->isStatic == L7_TRUE))
      {
        rc= LACIssueCmd(lacpPortEnabledStaticLag,p->actorPortNum,L7_NULL);
      }
      else
      {
        if (p->lacpEnabled == L7_TRUE)
          rc = LACIssueCmd(lacpPortEnabledLacpEnabled, p->actorPortNum, L7_NULL);
        else
          rc = LACIssueCmd(lacpPortEnabledLacpDisabled, p->actorPortNum , L7_NULL);
      }/* mode != static*/


      return L7_SUCCESS;
    }
  }

  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the current administrative priority associated
*           with the partner's system ID
*
* @param    intf            interface
* @param    priority        priority 0..255
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminSystemPriorityGet(L7_uint32 intf, L7_uint32 *priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *priority = p->partnerAdminSysPri;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the current administrative priority associated
*           with the partner's system ID
*
* @param    intf            interface
* @param    priority        priority 0..255
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminSystemPrioritySet(L7_uint32 intf, L7_uint32 priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    p->partnerAdminSysPri = priority;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the current operational priority associated
*           with the partner's system ID
*
* @param    intf            interface
* @param    priority        priority 0..255
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerOperSystemPriorityGet(L7_uint32 intf, L7_uint32 *priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *priority = p->partnerOperSysPri;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the aggregation port's partner system ID (administrative)
*
* @param    intf            interface
* @param    *mac            ID
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminSystemIDGet(L7_uint32 intf, L7_enetMacAddr_t *mac)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    memcpy(mac, &p->partnerAdminSys, sizeof(L7_enetMacAddr_t));
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the aggregation port's partner system ID (administrative)
*
* @param    intf            interface
* @param    mac             ID
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminSystemIDSet(L7_uint32 intf, L7_enetMacAddr_t mac)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    memcpy(&p->partnerAdminSys, &mac, sizeof(L7_enetMacAddr_t));
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the aggregation port's partner system ID (administrative)
*
* @param    intf            interface
* @param    *mac            ID
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerOperSystemIDGet(L7_uint32 intf, L7_enetMacAddr_t *mac)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    memcpy(mac, &p->partnerOperSys, sizeof(L7_enetMacAddr_t));
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the aggregation port's partner system ID (operational)
*
* @param    intf            interface
* @param    mac             ID
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerOperSystemIDSet(L7_uint32 intf, L7_enetMacAddr_t mac)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    memcpy(&p->partnerOperSys, &mac, sizeof(L7_enetMacAddr_t));
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the aggregation port's partner system ID (administrative)
*
* @param    intf            interface
* @param    *key            key, 16 bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminKeyGet(L7_uint32 intf, L7_uint32 *key)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *key = p->partnerAdminKey;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Sets the aggregation port's partner system ID (administrative)
*
* @param    intf            interface
* @param    key             key, 16 bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminKeySet(L7_uint32 intf, L7_uint32 key)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    p->partnerAdminKey = key; 
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the aggregation port's partner system ID (operational)
*
* @param    intf            interface
* @param    *key            key, 16 bit
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerOperKeyGet(L7_uint32 intf, L7_uint32 *key)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *key = p->partnerOperKey ;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  The aggregrator this port has selected
*
* @param    intf            interface
* @param    *agg            aggregrator
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    0 means the port has not selected and aggregator
*       
* @end
*********************************************************************/
L7_RC_t aggPortSelectedAggIDGet(L7_uint32 intf, L7_uint32 *agg)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p == L7_NULLPTR)
  {
    *agg = 0;
    return L7_FAILURE;
  }

  /* actorPortSelectedAggId should be set to 0 if the port has yet
     to select an aggregator */
  *agg = p->actorPortSelectedAggId;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  The identifier value of the aggregrator this port is 
*           currently attached to
*
* @param    intf            interface
* @param    *id             id value of aggregator
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    0 means the port is not attached to an aggregator
*       
* @end
*********************************************************************/
L7_RC_t aggPortAttachedAggIDGet(L7_uint32 intf, L7_uint32 *id)
{

  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p == L7_NULLPTR)
  {
    return L7_FAILURE;
  }
  /*
  if (p->portAttached == L7_FALSE)
  {
    *id = 0;
    return L7_SUCCESS;
  }
  */
  *id = p ->actorPortAggId;
  return L7_SUCCESS;

}

/*********************************************************************
* @purpose  The port number locally assigned to this aggregation port
*
* @param    intf            interface
* @param    *port           port actor 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    0 means the port has not attached to an aggregrator
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorPortGet(L7_uint32 intf, L7_uint32 *port)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *port = p->actorPortNum;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the priority assigned to this aggregation port
*
* @param    intf            interface
* @param    *priority       priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorPortPriorityGet(L7_uint32 intf, L7_uint32 *priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *priority = p->actorPortPri;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Set the priority assigned to this aggregation port
*
* @param    intf            interface
* @param    priority       priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorPortPrioritySet(L7_uint32 intf, L7_uint32 priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    p->actorPortPri = priority;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the administrative value of the port number for the partner
*
* @param    intf            interface
* @param    *port           port
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminPortGet(L7_uint32 intf, L7_uint32 *port)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *port = p->partnerAdminPortNumber;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the administrative value of the port number for the partner
*
* @param    intf            interface
* @param    port            port
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminPortSet(L7_uint32 intf, L7_uint32 port)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    p->partnerAdminPortNumber = port;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the administrative value of the port number for the partner
*
* @param    intf            interface
* @param    *port           port
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerOperPortGet(L7_uint32 intf, L7_uint32 *port)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *port = p->partnerOperPortNumber;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the administrative value of the port priority of the partner
*
* @param    intf            interface
* @param    *priority       priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminPortPriorityGet(L7_uint32 intf, L7_uint32 *priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *priority = p->partnerAdminPortPri;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Set the administrative value of the port priority of the partner
*
* @param    intf            interface
* @param    *priority       priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminPortPrioritySet(L7_uint32 intf, L7_uint32 priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    p->partnerAdminPortPri = priority;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the priority value assigned to this aggregation port
*           by the partner
*
* @param    intf            interface
* @param    *priority       priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerOperPortPriorityGet(L7_uint32 intf, L7_uint32 *priority)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *priority = p->partnerOperPortPri;
    return L7_SUCCESS;
  }
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get 8 bits corresponding to the admin values of actor_state
*
* @param    intf            interface
* @param    *state          state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    activity,timeout,aggregation,synch,collecting,distributing,
*           defaulted,expired
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorAdminStateGet(L7_uint32 intf, L7_uchar8 *state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *state = p->actorAdminPortState;
    return L7_SUCCESS;
  }
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Set 8 bits corresponding to the admin values of actor_state
*
* @param    intf            interface
* @param    *state          state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    activity,timeout,aggregation,synch,collecting,distributing,
*           defaulted,expired
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorAdminStateSet(L7_uint32 intf, L7_uchar8 state)
{
  dot3ad_port_t *p;
  L7_uchar8 tmp_state, tmp_state2;
  L7_BOOL prevAggBit, currAggBit;
  L7_RC_t rc;
  L7_uint32 linkState = L7_DOWN;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
	rc = nimGetIntfLinkState(p->actorPortNum,&linkState);
    
	if (p->actorAdminPortState & DOT3AD_STATE_AGGREGATION)
	{
	  prevAggBit = L7_TRUE;
	}
	else
	{
	  prevAggBit = L7_FALSE;
	}
    
    p->actorAdminPortState = state;

	if (p->actorAdminPortState & DOT3AD_STATE_AGGREGATION)
	{
	  currAggBit = L7_TRUE;
	}
	else
	{
	  currAggBit = L7_FALSE;
	}


    /* set first 3 bits */
    tmp_state             =  (L7_uchar8)((DOT3AD_STATE_LACP_ACTIVITY |
                              DOT3AD_STATE_LACP_TIMEOUT | 
                              DOT3AD_STATE_AGGREGATION) & state);

    /* preserve last 5 bits */
    tmp_state2            =  (L7_uchar8)(0xF8 & p->actorOperPortState);

    /* build result */
    p->actorOperPortState = (tmp_state | tmp_state2);
	
	if (prevAggBit != currAggBit)
	{
	/* update p->portIndividualAgg based on the DOT3AD_STATE_AGGREGATION bit */
	if (p->actorOperPortState & DOT3AD_STATE_AGGREGATION)
	{
	  p->portIndividualAgg = L7_TRUE;
		if (p->selected == UNSELECTED && linkState == L7_UP)
		{
		  (void)dot3adSelectionLogicSelect(p);
		}
	  }
	else
	{
	  p->portIndividualAgg = L7_FALSE;
	  if (p->selected == SELECTED)
	  {
		/* this port has just been deemed individual 
		   need to send lacpunselected via the state machine
		   to remove this from any attached lag
			 send unselect twice to get the mux state machine to 
			 the DETACHED state
		*/
		  (void)dot3adSelectionLogicUnselect(p);
		  (void)dot3adSelectionLogicUnselect(p);
	    }
	  }
	}
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get 8 bits corresponding to the admin values of actor_state
*
* @param    intf            interface
* @param    *state          state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    activity,timeout,aggregation,synch,collecting,distributing,
*           defaulted,expired
*       
* @end
*********************************************************************/
L7_RC_t aggPortActorOperStateGet(L7_uint32 intf, L7_uchar8 *state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *state = p->actorOperPortState;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get 8 bits corresponding to the current values of the
*           actor_state from the most recently received LACPDU (by the partner)
*
* @param    intf            interface
* @param    *state          state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    activity,timeout,aggregation,synch,collecting,distributing,
*           defaulted,expired
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerOperStateGet(L7_uint32 intf, L7_uchar8 *state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *state = p->partnerOperPortState;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get 8 bits corresponding to the current administrative 
*           value of the actor_state for the protocol partner
*
* @param    intf            interface
* @param    *state          state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    activity,timeout,aggregation,synch,collecting,distributing,
*           defaulted,expired
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminStateGet(L7_uint32 intf, L7_uchar8 *state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *state = p->partnerAdminPortState;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Set 8 bits corresponding to the current administrative 
*           value of the actor_state for the protocol partner
*
* @param    intf            interface
* @param    *state          state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    activity,timeout,aggregation,synch,collecting,distributing,
*           defaulted,expired
*       
* @end
*********************************************************************/
L7_RC_t aggPortPartnerAdminStateSet(L7_uint32 intf, L7_uchar8 state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    p->partnerAdminPortState = state;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get whether an aggregation port is able to aggregate
*
* @param    intf            interface
* @param    *state          state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortAggregateOrIndividualGet(L7_uint32 intf, L7_BOOL *state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    *state = p->portIndividualAgg;
    return L7_SUCCESS;
  }

  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the number of valid LACPDUs received on this aggregation port
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortStatsLACPDUsRxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].LACPDUsRx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the number of marker PDUs received on this aggregation port
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortStatsMarkerPDUsRxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].MarkerPDUsRx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the number of marker response PDUs received ont this 
*           aggregation port
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortStatsMarkerResponsePDUsRxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].MarkerResponsePDUsRx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the number of unknown frames
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    type=slow protocol but unknown PDU or
*           addressed to the slow protocols group but dont have the
*           type set
*       
* @end
*********************************************************************/
L7_RC_t aggPortStatsUnknownRxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].UnknownRx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the number of badly formed PDUs
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortStatsIllegalRxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].IllegalRx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the number of valid LACPDUs transmitted on this 
*           aggregation port
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortStatsLACPDUsTxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].LACPDUsTx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the number of marker PDUs transmitted on this 
*           aggregation port
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortStatsMarkerPDUsTxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].MarkerPDUsTx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the number of marker response PDUs transmitted on this 
*           aggregation port
*
* @param    port            physical port
* @param    *stat           value of statistic
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/ 
L7_RC_t aggPortStatsMarkerResponsePDUsTxGet(L7_uint32 port, L7_uint32 *stat)
{
  *stat = dot3ad_stats[port].MarkerResponsePDUsTx;
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get a bitwise list of ports included in an aggregator
*
* @param    agg_intf        internal interface number of aggregator
* @param    *list           portlist, bits sent are included
* @param    *length         length in bytes of the portlist
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortListGet(L7_uint32 agg_intf, L7_uchar8 *list, L7_uint32 *length)
{
  dot3ad_agg_t *p;
  DOT3AD_PORTLIST_t PortList;
  DOT3AD_PORTLIST_t out;
  L7_uint32 i,j,k;


  bzero((char*)&PortList, (L7_int32)sizeof(PortList));
  bzero((char*)&out,      (L7_int32)sizeof(out));

  p = dot3adAggIntfFind(agg_intf);
  if (p == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  for (i=0;i<L7_MAX_MEMBERS_PER_LAG;i++)
  {
    if (p->aggWaitSelectedPortList[i] != 0)
      DOT3AD_PORT_SETMASKBIT(PortList, p->aggWaitSelectedPortList[i]);
  }

  /* now reverse the bits */
  for (k=0;k<DOT3AD_PORT_INDICES;k++) /* for all bytes */
  {
    for (j=1;j<=8;j++) /* interfaces 1 to 8 in a byte */
    {
      if (DOT3AD_PORT_ISMASKBITSET(PortList, 8*k + j))
        DOT3AD_PORT_SETMASKBIT(out, 8*k + (8-j+1));
      else
        DOT3AD_PORT_CLRMASKBIT(out, 8*k + (8-j+1));
    }
  }

  memcpy(list, &out, DOT3AD_PORT_INDICES);
  *length = DOT3AD_PORT_INDICES;

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get the current state of the state machine for this port 
*
* @param    port            physical port
* @param    *state          one of 6 bits set representing a state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugRxStateGet(L7_uint32 port, L7_uchar8 *state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(port);
  if (p != L7_NULLPTR)
  {
    *state = p->rxState;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the last time a LACPDU was received on this port
*
* @param    port            physical port
* @param    *time           time of reception
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugLastRxTimeGet(L7_uint32 port, L7_timespec *time)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets the state of the MUX state machine
*
* @param    port            physical port
* @param    *state          one of 6 bits set representing state
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugMuxStateGet(L7_uint32 port, L7_uchar8 *state)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(port);
  if (p != L7_NULLPTR)
  {
    *state = p->muxState;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Gets a text string indicating the reason for the most
*           recent state change in the MUX machine
*
* @param    port            physical port
* @param    *reason         textual reason
* @param    *length         length of string
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugMuxReasonGet(L7_uint32 port, L7_char8 *reason, L7_uint32 *length)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  The state of the actor churn machine for this agg. port
*
* @param    port            physical port
* @param    *churnstate     churn state, 3 bits
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugActorChurnStateGet(L7_uint32 port, L7_uchar8 *churnstate)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  The state of the partner churn machine for this agg. port
*
* @param    port            physical port
* @param    *churnstate     churn state, 3 bits
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugPartnerChurnStateGet(L7_uint32 port, L7_uchar8 *churnstate)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  A count of the number of times the churn machine entered
*           the ACTOR_CHURN state
*
* @param    port            physical port
* @param    *churncount     churn count
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugActorChurnCountGet(L7_uint32 port, L7_uint32 *churncount)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  A count of the number of times the churn machine entered
*           the PARTNER_CHURN state
*
* @param    port            physical port
* @param    *churncount     churn count
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugPartnerChurnCountGet(L7_uint32 port, L7_uint32 *churncount)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  A count of the number of times the actor's mux machine entered
*           the IN_SYNC state
*
* @param    port            physical port
* @param    *count          transition count
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugActorSyncTransitionCountGet(L7_uint32 port, L7_uint32 *count)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  A count of the number of times the actor's mux machine entered
*           the IN_SYNC state
*
* @param    port            physical port
* @param    *count          transition count
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugPartnerSyncTransitionCountGet(L7_uint32 port, L7_uint32 *count)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  A count of the number of times the actor's perception of 
*           the LAG ID for this aggregation port has changed
*
* @param    port            physical port
* @param    *count          transition count
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugActorChangeCountGet(L7_uint32 port, L7_uint32 *count)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  A count of the number of times the partner's perception of 
*           the LAG ID for this aggregation port has changed
*
* @param    port            physical port
* @param    *count          transition count
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortDebugPartnerChangeCountGet(L7_uint32 port, L7_uint32 *count)
{
  return L7_FAILURE;
}

/*********************************************************************
* @purpose  Get the LACP status on a per-port basis
*
* @param    port            physical port
* @param    *status         L7_TRUE/L7_FALSE 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE      if port not found
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortLacpEnabledGet(L7_uint32 port, L7_BOOL *status)
{
  dot3ad_port_t *p;

  p = dot3adPortIntfFind(port);
  if (p != L7_NULLPTR)
  {
    *status = p->lacpEnabled;
    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}


/*********************************************************************
* @purpose  Set the LACP status on a per-port basis
*
* @param    port            physical port
* @param    status         L7_TRUE/L7_FALSE 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE      if port not found
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t aggPortLacpEnabledSet(L7_uint32 port, L7_BOOL status)
{
  dot3ad_port_t *p;
  L7_RC_t rc;
  L7_NIM_QUERY_DATA_t nimQueryData;
  dot3ad_agg_t *agg;

  p = dot3adPortIntfFind(port);
  if (p != L7_NULLPTR)
  {
	if (p->lacpEnabled == status)
	{
	  return L7_SUCCESS;
	}
    p->lacpEnabled = status;
    /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/

    if (dot3adSwitchoverInProgress == L7_TRUE)
    {
      return L7_SUCCESS;
    }
    /* if port not attached to a lag */
    if (p->actorOperPortKey != p->actorPortNum)
    {
     /* do not send lacpPortEnabledLacpEnabled or lacpPortEnabledLacpDisabled if 
      aggregator is static*/
      agg = dot3adAggKeyFind(p->actorOperPortKey);
      if (agg != L7_NULLPTR)
      {
        if (agg->isStatic == L7_FALSE)
        {
          rc = LACIssueCmd(lacpBegin, p->actorPortNum, L7_NULLPTR);
          if (p->portEnabled == L7_TRUE)
          {
            if (p->lacpEnabled == L7_TRUE)
              rc = LACIssueCmd(lacpPortEnabledLacpEnabled, p->actorPortNum, L7_NULL);
            else
              rc = LACIssueCmd(lacpPortEnabledLacpDisabled, p->actorPortNum , L7_NULL);
      
          }
         }
       }/* agg != NULL */
       else
       {
         return L7_ERROR;
       }
      }/* p->actorOperPortKey != port */
      else
      {
        rc = LACIssueCmd(lacpBegin, p->actorPortNum, L7_NULLPTR);
        if (p->portEnabled == L7_TRUE)
        {
          if (p->lacpEnabled == L7_TRUE)
            rc = LACIssueCmd(lacpPortEnabledLacpEnabled, p->actorPortNum, L7_NULL);
          else
            rc = LACIssueCmd(lacpPortEnabledLacpDisabled, p->actorPortNum , L7_NULL);

      }
    }
    nimQueryData.intIfNum = port;
    nimQueryData.request = L7_NIM_QRY_RQST_STATE;

    if (nimIntfQuery(&nimQueryData) != L7_SUCCESS)
    {
      /* should never get here */
      return L7_FAILURE;
    }
    else if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
             (nimQueryData.data.state == L7_INTF_DETACHING) ||
             (nimQueryData.data.state == L7_INTF_ATTACHED))
    {
      /* only talk to the hardware when the hardware is valid */
    /* E2 */
    if (status == L7_TRUE)
    {
      rc = dtlDot3adLacpSet(p->actorPortNum,L7_ENABLE);
      /*LACIssueCmd(lacpEnablePerMachine, p->actorPortNum, L7_NULL);*/
    }
    /* E3 */
    else
    {
      rc = dtlDot3adLacpSet(p->actorPortNum,L7_DISABLE);
      /*LACIssueCmd(lacpDisablePerMachine, p->actorPortNum, L7_NULL);*/
    }
    }

    return L7_SUCCESS;
  }
  else
    return L7_FAILURE;
}

/*********************************************************************
* @purpose  Forwards a LACPDU onto LACP
*
* @param    intf            interface number received on
* @param    bufHandle       handle to the PDU location in DTL
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE      if port not found
*
* @notes    
*       
* @end
*********************************************************************/
L7_RC_t LACPDUReceive(L7_uint32 intf, void * bufHandle)
{
  dot3ad_port_t *p;
  L7_RC_t rc;
  dot3ad_agg_t *agg;

  /* Send PDU to debug routine */
  
  dot3adDebugPacketRxTrace(intf, (dot3ad_pdu_t *)bufHandle);

  p = dot3adPortIntfFind(intf);
  if (p != L7_NULLPTR)
  {
    /* Drop the received PDU if the port's aggregator is static */
    /* Get the aggregator first */
    agg = dot3adAggKeyFind(p->actorOperPortKey);
    if (agg == L7_NULLPTR)
    {
      bufferPoolFree(dot3adBufferPoolId, bufHandle);
      return L7_FAILURE;
    }
    if (agg->isStatic == L7_TRUE)
    {
      dot3ad_stats[intf].RxLACPDUsDropped++;
      bufferPoolFree(dot3adBufferPoolId, bufHandle);
      return L7_SUCCESS;
    }
    /* E4 */
    rc = dot3adLacpClassifier(lacpPduRx, p, bufHandle);
	  bufferPoolFree(dot3adBufferPoolId, bufHandle);
	  return rc;

  }
  else
  {
    bufferPoolFree(dot3adBufferPoolId, bufHandle);
    return L7_FAILURE;
  }
}
/*********************************************************************
* @purpose  Reset all default values in the port entry
*
* @param    p            pointer to the port entry
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE      if port not found
*
* @notes    This routine frees all timers , removes port from attached 
*           list and the selected list, brings to initial state
*       
* @end
*********************************************************************/
L7_RC_t aggPortResetValues(dot3ad_port_t *p)
{
  L7_uint32 portNum;
  L7_RC_t rc;

  portNum = p->actorPortNum;

  rc = osapiSemaTake(dot3adTimerSyncSema, L7_WAIT_FOREVER);
  /*release all timers*/
  if (p->currentWhileTimer)
  {
    osapiTimerFree(p->currentWhileTimer);
    p->currentWhileTimer = L7_NULLPTR;
  }
  if (p->nttTimer)
  {
    osapiTimerFree(p->nttTimer);
    p->nttTimer = L7_NULLPTR;
  }
  if (p->periodicTimer)
  {
    osapiTimerFree(p->periodicTimer);
    p->periodicTimer = L7_NULLPTR;
  }
  if (p->waitWhileTimer)
  {
    osapiTimerFree(p->waitWhileTimer);
    p->waitWhileTimer = L7_NULLPTR;
  }
  rc = osapiSemaGive(dot3adTimerSyncSema);

  /*remove from attached list*/
  rc = dot3adAggAttachedDelete(p->actorPortAggId,p->actorPortNum);
  p->actorPortAggId = 0;
  /*need to detach from lag*/
  if (rc == L7_SUCCESS)
    rc = aggCollDistDisable(p->actorPortNum);
  /*remove from selected list*/
  rc = dot3adAggSelectedDelete(p->actorPortSelectedAggId,p->actorPortNum);
  p->actorPortSelectedAggId = 0;
  p->selected = 0;



  /*p->lacpEnabled = L7_TRUE;*/
  p->begin = L7_FALSE;
  p->actorPortNum = portNum;
  /*p->portIndividualAgg = L7_TRUE;*/
  /*
  p->actorOperPortState = DOT3AD_STATE_LACP_ACTIVITY |
                          DOT3AD_STATE_LACP_TIMEOUT |
                          DOT3AD_STATE_AGGREGATION;
                          */
  if (p->actorAdminPortKey != L7_NULL)
  {
    p->actorOperPortKey = p->actorAdminPortKey;
  }
  /*
  p->actorAdminPortState = DOT3AD_STATE_LACP_ACTIVITY |
                           DOT3AD_STATE_LACP_TIMEOUT |
                           DOT3AD_STATE_AGGREGATION;
                           */
  p->actorOperPortState = p->actorAdminPortState;
  p->txCount = 0;
  p->readyN = L7_FALSE;

  /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/

  return L7_SUCCESS;
}
/*********************************************************************
* @purpose  Deletes Port from a LAG
*
* @param    intIfNum            Internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE      if port not found
*
* @notes    
*           
*       
* @end
*********************************************************************/
L7_RC_t aggPortDelete(L7_uint32 intIfNum)
{
  dot3ad_port_t *p;
  L7_RC_t rc;
  dot3ad_agg_t *agg;
  L7_uint32 nullBuf = 0;             /* buffer not needed in call to dot3adReceiveMachine */
  
  p = dot3adPortIntfFind(intIfNum);
  if (p == L7_NULLPTR || dot3adIsLagMember(intIfNum) == L7_FALSE)
  {
    return L7_FAILURE;
  }
  agg = dot3adAggKeyFind(p->actorOperPortKey);
  if (agg == L7_NULLPTR)
  {
    return L7_FAILURE;
  }
  /*reset receive machine*/
  rc = dot3adLacpClassifier(lacpBeginFalsePortDisabledPortMovedFalse,p,(void *)&nullBuf);
  /*reset periodic machine*/
  rc = dot3adLacpClassifier(lacpPortDisabled,p,(void *)&nullBuf);
  /*reset mux machine*/
  /*send unselected twice to ensure the mux machine is in detached state*/
  rc = dot3adLacpClassifier(lacpUnselected,p,(void *)&nullBuf);
  rc = dot3adLacpClassifier(lacpUnselected,p,(void *)&nullBuf);

  p->actorOperPortKey = intIfNum;

  rc = aggPortResetValues(p);
  /*remove from waiting to be selected list*/
  rc = dot3adAggWaitSelectedDelete(p->actorPortWaitSelectedAggId,p->actorPortNum);
  p->actorPortWaitSelectedAggId =0;

  if (agg->currNumWaitSelectedMembers == 0)
  {
    bzero((char *)agg->partnerSys.addr,L7_MAC_ADDR_LEN);
    agg->partnerSysPri = 0;
    agg->partnerOperAggKey = 0;
    if (cnfgrIsFeaturePresent(L7_DOT3AD_COMPONENT_ID, 
                              L7_DOT3AD_LAG_PRECREATE_FEATURE_ID))
    {
      if (agg->isStatic == L7_FALSE)
      {
        agg->isStatic = L7_TRUE;
        dot3adLagCnt.DynamicLagCnt--;
        dot3adLagCnt.StaticLagCnt++;
      }
    }
  }

  /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/
  return L7_SUCCESS;
}
/*********************************************************************
* @purpose  Deletes configured LAGs
*
* @param    none            
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE      
*
* @notes    
*           
*       
* @end
*********************************************************************/
L7_RC_t aggConfiguredLagsRemove()
{
  L7_uint32 i;
  L7_RC_t rc;

  for (i=0;i<L7_MAX_NUM_LAG_INTF;i++)
  {
    if (dot3adAgg[i].inuse == L7_TRUE)
    {
	  rc = dot3adConfiguredLagRemove(dot3adAgg[i].aggId);
    }
  }
  return L7_SUCCESS;
}
/*********************************************************************
* @purpose  Records the current system time as the dot3adTablesLastChanged time
*
* @param    none            
*
* @returns  void
*
* @notes    
*           
*       
* @end
*********************************************************************/
void dot3adTablesLastChangedRecord(void)
{
  osapiUpTime(&dot3adSystem.timeOfLastTableChange);
  return;
}

/**************************************************************************
*
* @purpose    Actions to be performed when the current while timer expires
*
* @param      portNum      internal interface number of the port        
*
* @returns    L7_SUCCESS or L7_FAILURE
*
* @notes   	Put this timer expiry message on a timer queue, thus returning
*           immediately to the timer task that called this routine. This will 
*           avoid any processing on the timer thread.
*
* @end
*
*************************************************************************/ 
void dot3adCurrentWhileTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
{
  dot3adTimerMsg_t Message;
  L7_RC_t rc;

  Message.msgId = CURRENT_EXPIRED;
  Message.parm1 = portNum;
  Message.parm2 = nullParm;

  rc = osapiMessageSend(dot3ad_timer_queue,&Message, (L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);

  if (rc == L7_ERROR)
  {
    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
            "dot3adTimerTask: Failed to put msg in timer queue....\n");
  }

  return;
}
/**************************************************************************
*
* @purpose    Actions to be performed when the periodic timer expires
*
* @param      portNum      internal interface number of the port        
*
* @returns    L7_SUCCESS or L7_FAILURE
*
* @notes   	Put this timer expiry message on a timer queue, thus returning
*           immediately to the timer task that called this routine. This will 
*           avoid any processing on the timer thread.
*
* @end
*
*************************************************************************/
void dot3adPeriodicTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
{
  dot3adTimerMsg_t Message;
  L7_RC_t rc;

  Message.msgId = PERIODIC_EXPIRED;
  Message.parm1 = portNum;
  Message.parm2 = nullParm;

  rc = osapiMessageSend(dot3ad_timer_queue,&Message,(L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);

  if (rc == L7_ERROR)
  {
    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
            "dot3adTimerTask: Failed to put msg in timer queue....\n");
  }

  return;
}
/**************************************************************************
*
* @purpose    Actions to be performed when the Wait While timer expires
*
* @param      portNum      internal interface number of the port        
*
* @returns    L7_SUCCESS or L7_FAILURE
*
* @notes   	Put this timer expiry message on a timer queue, thus returning
*           immediately to the timer task that called this routine. This will 
*           avoid any processing on the timer thread.
* @end
*
*************************************************************************/
void dot3adWaitWhileTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
{
  dot3adTimerMsg_t Message;
  L7_RC_t rc;

  Message.msgId = WAIT_EXPIRED;
  Message.parm1 = portNum;
  Message.parm2 = nullParm;

  rc = osapiMessageSend(dot3ad_timer_queue,&Message, (L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);

  if (rc == L7_ERROR)
  {
    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
            "dot3adTimerTask: Failed to put msg in timer queue....\n");
  }

  return;
}
/**************************************************************************
*
* @purpose    Sets the txCount to zero 
*
* @param      portNum      internal interface number of the port        
*
* @returns    L7_SUCCESS or L7_FAILURE
*
* @notes   	Put this timer expiry message on a timer queue, thus returning
*           immediately to the timer task that called this routine. This will 
*           avoid any processing on the timer thread.
*
* @end
*
*************************************************************************/
void dot3adNttTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
{
  dot3adTimerMsg_t Message;
  L7_RC_t rc;

  Message.msgId = NTT_EXPIRED;
  Message.parm1 = portNum;
  Message.parm2 = nullParm;

  rc = osapiMessageSend(dot3ad_timer_queue,&Message, (L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);

  if (rc == L7_ERROR)
  {
    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
            "dot3adTimerTask: Failed to put msg in timer queue....\n");
  }

  return;
}

/**************************************************************************
*
* @purpose  Resets default values of admin in the operational values
*
* @param   *p   pointer to the agg. port structure
*
* @returns  L7_SUCCESS -always as this function copies default information
*
* @notes    only the partner values are defaulted
*
* @end
*
*************************************************************************/
L7_RC_t dot3adActivePortResetDefault(dot3ad_port_t *p)
{
  p->partnerOperPortNumber = p->partnerAdminPortNumber;
  p->partnerOperPortPri = p->partnerAdminPortPri;
  memcpy(p->partnerOperSys.addr,p->partnerAdminSys.addr,L7_MAC_ADDR_LEN);
  p->partnerOperSysPri = p->partnerAdminSysPri;
  p->partnerOperKey = p->partnerAdminKey;
  p->partnerOperPortState = p->partnerAdminPortState;

  dot3adTablesLastChangedRecord();

  return L7_SUCCESS;
}


/*********************************************************************
* @purpose  Set the Static or Dynamic mode for the LAG/aggregator.
*            
* @param    agg_intf    Internal aggregator interface
*           mode        Static or non-Static/Dynamic mode for the LAG
*                      
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* @returns  L7_TABLE_IS_FULL if user is attempting to change a static lag
*                            to dynamic and Maximum number of dynamic lags 
*                            already exist       
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t aggStaticModeSet(L7_uint32 agg_intf, L7_uint32 mode)
{
  dot3ad_agg_t *a;
  dot3ad_port_t *p;
  L7_uint32 currmode,i,j;
  L7_RC_t rc1,rc2;
  L7_BOOL bportActive;
  L7_uint32 linkState;


  /* Get the aggrgator */
  a = dot3adAggIntfFind(agg_intf);
  if (a == L7_NULLPTR)
  {
   (void)osapiSemaGive(dot3adQueueSyncSema);
   return L7_FAILURE;
  }

  if ((mode != L7_TRUE) && ( mode != L7_FALSE))
  {
    L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
    nimGetIntfName(agg_intf, L7_SYSNAME, ifName);

    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
            "Invalid mode for static lags %s: %u!\n", ifName, mode);
    (void)osapiSemaGive(dot3adQueueSyncSema);
    return L7_FAILURE;
  
  }
  currmode = a->isStatic;

  if (currmode == mode)
  {
    (void)osapiSemaGive(dot3adQueueSyncSema);
    return L7_SUCCESS;
  }

  /* if static lag is changed to dynamic */
  if((currmode==L7_TRUE) && (mode==L7_FALSE))
  {
     /*check that max number of dynamic lags do not already exist */
    if (dot3adLagCnt.DynamicLagCnt >= platIntfDynamicLagIntfMaxCountGet())
    {
      (void)osapiSemaGive(dot3adQueueSyncSema);
      return L7_TABLE_IS_FULL;
    }
    
  }
  a->isStatic = (L7_BOOL)mode;
  /*dot3adCfg.hdr.dataChanged = L7_TRUE;*/

  /* converting dynamic lag to static */
  if ((currmode == L7_FALSE) && (mode == L7_TRUE))
  {
    /* adjust lag counters*/
    dot3adLagCnt.DynamicLagCnt--;
    dot3adLagCnt.StaticLagCnt++;

    /* First process currently active ports */
    /*Currently active ports should remain in active state */
    for (i = 0; i< a->activeNumMembers; i++)
    {
      p = dot3adPortIntfFind(a->aggActivePortList[i]);
      if (p != L7_NULLPTR)
      {
        /* Reset the Partner operation information */
        dot3adActivePortResetDefault(p);

        if (dot3adSwitchoverInProgress == L7_TRUE)
        {
          continue;
        }
        /* Reset Periodic Machine . Send lacpDisablePerMachine*/
        rc1 = LACIssueCmd(lacpDisablePerMachine,p->actorPortNum, L7_NULL);
        if (rc1 != L7_SUCCESS)
        {
          L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                  "\n aggStaticModeSet: Dynamic to Static: Failure sending lacpDisablePerMachine for active port : %d",a->aggActivePortList[i]);
        }

        /* Reset the statistics counter */
        dot3ad_stats[a->aggActivePortList[i]].RxLACPDUsDropped=0;
      }/* p! = L7_NULLPTR*/
    }/* for each active port */

    /* Now process configured ports */
    /* Currently configured ports should be activated */
    for (i = 0; i< a->currNumWaitSelectedMembers; i++)
    {
       /* Initialize*/
       bportActive=L7_FALSE;
       
       /* Check if port is active  */

       for(j=0;j< a->activeNumMembers;j++)
       {
         if (a->aggActivePortList[j] == a->aggWaitSelectedPortList[i] )
         {
           bportActive = L7_TRUE;
           break;
         }
       }

       if(bportActive == L7_FALSE)
       {
          /* port is not active */
         /* Reset state machines, send lacpBegin*/
         if (dot3adSwitchoverInProgress == L7_TRUE)
         {
           continue;
         }
         rc1 = LACIssueCmd(lacpBegin, a->aggWaitSelectedPortList[i], L7_NULL);
         if (rc1 == L7_FAILURE)
           L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                   "\n aggStaticModeSet: Dynamic to Static:Failure to Send lacpBegin for configured port : %d\n",a->aggWaitSelectedPortList[i]);
         rc2 = nimGetIntfLinkState(a->aggWaitSelectedPortList[i],&linkState);
         if (rc2 != L7_SUCCESS)
           L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                   "\n aggStaticModeSet: Dynamic to Static: Failure to get linkstate for port %d",a->aggWaitSelectedPortList[i]);
         p = dot3adPortIntfFind(a->aggWaitSelectedPortList[i]);
         if (p != L7_NULLPTR)
         {
           /* port configured and linked up send lacpPortEnabledStaticLag event*/
           if (linkState == L7_UP)
             p->portEnabled = L7_TRUE;
           else
             p->portEnabled = L7_FALSE;
           if (linkState == L7_UP)
           {
             rc2= LACIssueCmd(lacpPortEnabledStaticLag,p->actorPortNum,L7_NULL);
             if (rc2 != L7_SUCCESS)
               L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                       "\n aggStaticModeSet: Dynamic to Static:Failure to Send lacpPortEnabledStaticLag for configured port : %d\n",a->aggWaitSelectedPortList[i]);
             
           }
         }

        /* Reset the statistics counter */
        dot3ad_stats[a->aggWaitSelectedPortList[i]].RxLACPDUsDropped=0;

       }/* port not active */
         

    }/* for each configured port */

   }
  else if ((currmode == L7_TRUE)&&(mode == L7_FALSE))
  {
    /* adjust lag counters*/
    dot3adLagCnt.StaticLagCnt--;
    dot3adLagCnt.DynamicLagCnt++;

    if (dot3adSwitchoverInProgress == L7_TRUE)
    {
      (void)osapiSemaGive(dot3adQueueSyncSema);
      return L7_SUCCESS;
    }
    /* LAG mode moving from static to dynamic */
    /* For all active members reset the state machines */
    for(i=0;i< a->currNumWaitSelectedMembers; i++)
    {
      /* for each configured port*/
      /* Reset state machines, send lacpBegin*/
      rc1 = LACIssueCmd(lacpBegin, a->aggWaitSelectedPortList[i], L7_NULL);
      if (rc1 == L7_FAILURE)
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                "\n aggStaticModeSet: Static to Dynamic:Failure to Send lacpBegin for configured port : %d\n",a->aggWaitSelectedPortList[i]);
      rc2 = nimGetIntfLinkState(a->aggWaitSelectedPortList[i],&linkState);
      if (rc2 != L7_SUCCESS)
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                "\n aggStaticModeSet: Static to Dynamic: Failure to get linkstate for port %d",a->aggWaitSelectedPortList[i]);
      p = dot3adPortIntfFind(a->aggWaitSelectedPortList[i]);
      if (p != L7_NULLPTR)
      {
        /* port configured and linked up */
        /* Since aggregator is dynamic check lacp mode and send approriate event */
        if (linkState == L7_UP)
          p->portEnabled = L7_TRUE;
        else
          p->portEnabled = L7_FALSE;
        if (linkState == L7_UP)
        {
          if (p->lacpEnabled == L7_TRUE)
            rc2=LACIssueCmd(lacpPortEnabledLacpEnabled,p->actorPortNum,L7_NULL);
             if (rc2 != L7_SUCCESS)
               L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                       "\n aggStaticModeSet: Static to Dynamic:Failure to Send lacpPortEnabledLacpEnabled for configured port : %d\n",a->aggWaitSelectedPortList[i]);
          else
            rc2=LACIssueCmd(lacpPortEnabledLacpDisabled,p->actorPortNum,L7_NULL);
            if (rc2 != L7_SUCCESS)
               L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                       "\n aggStaticModeSet: Static to Dynamic:Failure to Send lacpPortEnabledLacpDisabled for configured port : %d\n",a->aggWaitSelectedPortList[i]);
        }/* link up*/

      }/* p!=NULLPTR*/
    }/* for each configured port*/
  
  }/* static to dynamic*/

 /* Static lag mode change processing finished 
    return the semaphore 
 */
 (void)osapiSemaGive(dot3adQueueSyncSema);

 return L7_SUCCESS;
  
}


/*********************************************************************
* @purpose  Removes an existing LAG from dot3adRestore.
*
* @param    intIfNum    internal interface number of the LAG being removed
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    none 
*
* @end
*********************************************************************/
L7_RC_t dot3adConfiguredLagRemove(L7_uint32 intIfNum)
{
  L7_RC_t rc;
  dot3ad_agg_t *a;
  L7_uint32 numMembers=0;
  L7_uint32 memberList[L7_MAX_MEMBERS_PER_LAG];

  a = dot3adAggIntfFind(intIfNum);
  if (a == L7_NULLPTR || a->adminMode == L7_DISABLE)
  {
    return L7_FAILURE;
  }

  bzero((char *)memberList,sizeof(L7_uint32)* L7_MAX_MEMBERS_PER_LAG);

  rc = dot3adMemberListGet(intIfNum, &numMembers, memberList);
    
  if (rc == L7_SUCCESS && numMembers > 0)
	rc = dot3adConfiguredLagMemberDelete(intIfNum, numMembers, memberList);
  
  if (rc == L7_SUCCESS)
	/*rc = dot3adAggInuseSet(intIfNum, L7_FALSE);*/
	/* Call the aggInuseSet directly as this is called only from 
	 * the dot3adRestore which is protected with the dot3adTaskSyncSema
	 * semaphore
	 */
	aggInuseSet(intIfNum, L7_FALSE);
  
  return rc;
}
/*********************************************************************
* @purpose  Delete one or more member interfaces from a LAG port from dot3adRestore.
*            
* @param    intIfNum    internal interface number of the target LAG
* @param    count       number of members being deleted from the LAG 
* @param    pMemIntf    pointer to list of LAG member intfs to delete 
*                         (@b{Input:} densely-packed array of internal intfs) 
*                      
* @returns  L7_SUCCESS
* @returns  L7_ERROR    if parameter checking fails 
* @returns  L7_FAILURE
*
* @notes    This API command can only be used to update an existing LAG.
*
* @notes    @i{pMemIntf} points to a @b{densely-packed} array of internal
*           interface numbers.
*
* @end
*********************************************************************/
L7_RC_t dot3adConfiguredLagMemberDelete(L7_uint32 intIfNum, 
										L7_uint32 count,
                                        L7_uint32 *pMemIntf)
{
  L7_RC_t rc, rc_exist;
  L7_uint32 i, j;
  dot3ad_port_t *p;
  dot3ad_agg_t *a;
  rc = L7_SUCCESS;
  for (i=0;i<count;i++)
  {

    /* remove only exisiting physical interfaces */
    if (dot3adLihIsIntfTypePhy(pMemIntf[i]) == L7_FALSE)
    {
      return L7_FAILURE;
    }

    /* save port pointer for later */
    p = dot3adPortIntfFind(pMemIntf[i]);
    if (p == L7_NULLPTR)
    {
      return L7_FAILURE;
    }

    /* find the ith member to be deleted in a list */
    rc_exist = L7_FAILURE;
    a = dot3adAggIntfFind(intIfNum);
    if (a == L7_NULLPTR || a->inuse == L7_FALSE || a->adminMode == L7_DISABLE)
    {
      return L7_FAILURE;
    }

    for (j=0;j<L7_MAX_MEMBERS_PER_LAG;j++)
    {
      if (a->aggPortList[j] == pMemIntf[i])
      {
        rc_exist = L7_SUCCESS;
      }
      if (a->aggSelectedPortList[j] == pMemIntf[i])
      {
        rc_exist = L7_SUCCESS;
      }
      if (a->aggWaitSelectedPortList[j] == pMemIntf[i])
      {
        rc_exist = L7_SUCCESS;
      }
    }

    if (rc_exist == L7_SUCCESS)
    {
	  /*rc = LACIssueCmd(lacDeletePort, pMemIntf[i], L7_NULL);*/
	  /* Instead of putting this message in the dot3ad queue 
	   * directly call the aggPortDelete with this member interface
	   * data is protected as this routine is called only from the dot3adRestore
	   * and that rotuine has semaphore protection.
	   */
	  (void)aggPortDelete(pMemIntf[i]);
    }
    else
    {
      /* currently, if one delete fails, all others after it
         in pMemIntf fail */
      return L7_FAILURE;
    }

  }

  return rc;   

}

/*********************************************************************
* @purpose  Create a lag for the specific LAG_ID
*            
* @param    lagID         the lag ID internal to LAG
* @param    name          the name assigned to the LAG
* @param    members       the member list
* @param    adminMode     the admin state of the interface
* @param    linkTrapMode  the link trap state of the interface
* @param    hashMode      the Hash Mode value, enumerated by L7_DOT3AD_HASH_MODE_t
* @param    pIntfIfNum    the returned intIfNum of the interface
*                      
* @returns  L7_SUCCESS
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t dot3adPrivateLagCreate(L7_uint32 lagId, L7_char8 *name, L7_uint32 members[],
                               L7_uint32 adminMode, L7_uint32 linkTrapMode,
                               L7_BOOL cfgCreated, L7_uint32 hashMode,
                               L7_uint32 *pIntIfNum)
{

  L7_uint32               j;
  L7_uint32               aggIndex; /* the lagId is one based and index is 0 based */
  L7_RC_t                 rc ;
  DTL_USP_t               lagUsp = { 0};
  nimIntfCreateRequest_t  nimRequest;
  nimConfigID_t           intfIdInfo;  
  nimIntfDescr_t          intfDescr;   
  nimIntfConfig_t         defaultCfg;  
  NIM_INTF_CREATE_INFO_t  createInfo;
  NIM_EVENT_NOTIFY_INFO_t  notifyEventInfo;
  L7_uint32 i, aggIntIfNum;

  nimIntfCreateOutput_t   nimOutput;
  NIM_HANDLE_t            handle;

  do
  {
    aggIndex = lagId - 1;
    /* 
     * Need to perform a LAG create for DTL 
     * the LAG U and S need to be determined via CMGR
     */
    lagUsp.unit = L7_LOGICAL_UNIT;
    lagUsp.slot = platSlotLagSlotNumGet ();
    lagUsp.port = lagId;

    /* Now that we have a valid USP, let DTL know about the interface */
    /* OK to make this dtl call without the interface being ATTACHED */
    if ((rc = dtlDot3adCreate(&lagUsp)) != L7_SUCCESS)
      break; /* goto while (0) */

    /* Let the system know of the interface by creating it with NIM */
    /* setup the config ID */
    memset((void *)&defaultCfg,0,sizeof(nimIntfConfig_t));
    memset((void *)&intfDescr,0,sizeof(nimIntfDescr_t));
    memset((void *)&createInfo,0,sizeof(NIM_INTF_CREATE_INFO_t));
    memset((void *)&intfIdInfo,0,sizeof(nimConfigID_t));
    memset((void *)&nimRequest,0,sizeof(nimIntfCreateRequest_t));

    intfIdInfo.configSpecifier.dot3adIntf = lagId;
    intfIdInfo.type = L7_LAG_INTF;

    nimOutput.handle      = &handle;
    nimOutput.intIfNum    = pIntIfNum;

    /* no callback function for now */
    createInfo.component  = L7_DOT3AD_COMPONENT_ID;

    /* need cb func so we can do the attach when the create is complete */
    createInfo.pCbFunc    = dot3adNimEventCompletionCallback; 

    /* setup the default config for the LAG */
    memset(defaultCfg.LAAMacAddr.addr, 0, 6); 
    defaultCfg.addrType   = L7_SYSMAC_BIA;
    memset(defaultCfg.ifAlias, 0, sizeof(defaultCfg.ifAlias)); 
    defaultCfg.nameType   = L7_SYSNAME;
    defaultCfg.ifSpeed    = L7_PORTCTRL_PORTSPEED_LAG;
    defaultCfg.negoCapabilities = 0; /* Autonegotiation disabled */
    defaultCfg.adminState = FD_DOT3AD_ADMIN_MODE;
    defaultCfg.trapState  = L7_DISABLE;
    defaultCfg.ipMtu        = L7_PORT_ENET_ENCAP_MAX_MTU;
    defaultCfg.encapsType = L7_ENCAP_ETHERNET;         
    defaultCfg.cfgMaxFrameSize = dot3adSidMaxFrameSizeGet();

    /* setup the intf characteristics for this interface */
    intfDescr.configurable   = L7_TRUE;
    intfDescr.internal       = L7_FALSE;
    intfDescr.settableParms  = L7_INTF_PARM_ADMINSTATE | L7_INTF_PARM_MTU |
                               L7_INTF_PARM_FRAMESIZE | L7_INTF_PARM_MACADDR |
                               L7_INTF_PARM_LINKTRAP | 
                               L7_INTF_PARM_LOOPBACKMODE |
                               L7_INTF_PARM_MACROPORT | L7_INTF_PARM_ENCAPTYPE;
    memcpy (&intfDescr.bcastMacAddr,  &L7_ENET_BCAST_MAC_ADDR, 6);
    intfDescr.frameSize.largestFrameSize = 1522;
    intfDescr.ianaType       = L7_IANA_LAG_DESC;
    intfDescr.defaultSpeed   =  0;
    intfDescr.phyCapability  =  0;
    intfDescr.connectorType  =  0;
    osapiSnprintf((L7_char8 *)&(intfDescr.ifDescr), L7_NIM_INTF_DESCR_SIZE, 
                  "%s %s %d", (L7_char8 *)&(intfDescr.ifDescr),
                  IANA_LAG_DESC, lagId);
    if (cnfgrIsFeaturePresent(L7_FLEX_STACKING_COMPONENT_ID,
                            L7_STACKING_FEATURE_SUPPORTED) == L7_TRUE)
    {

      osapiSnprintf ((L7_char8 *)&(intfDescr.ifName), L7_NIM_INTF_DESCR_SIZE,
                     "%d/%d/%d", (L7_uchar8)L7_LOGICAL_UNIT, 
               (L7_uchar8)platSlotLagSlotNumGet(), lagId);
    }
    else
    {
      osapiSnprintf ((L7_char8 *)&(intfDescr.ifName), L7_NIM_INTF_DESCR_SIZE,
                     "%d/%d", (L7_uchar8)platSlotLagSlotNumGet(), lagId);
    }

    memset((void*)&intfDescr.macroPort,0,sizeof(nimMacroPort_t));

    if ((rc = cmgrIfaceMacGet(intfIdInfo.type, lagUsp.unit,lagUsp.slot,lagId,intfDescr.macAddr.addr, intfDescr.l3MacAddr.addr)) != L7_SUCCESS)
    {
      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
              "DOT3AD: failed to get the MAC address of LagID(%d)\n",lagId);
      break; /* goto while (0) */
    }

    /* setup the request block pointers */
    nimRequest.pDefaultCfg  = &defaultCfg;
    nimRequest.pIntfDescr   = &intfDescr;
    nimRequest.pIntfIdInfo  = &intfIdInfo;
    nimRequest.pCreateInfo  = &createInfo;

    /* syncronize the agg creation between the caller and the event handler */
    osapiSemaTake(dot3adAggIntfCreateSema,L7_WAIT_FOREVER);

    /* Tell the system about the interface */
    if ((rc = nimIntfCreate(&nimRequest,&nimOutput)) != L7_SUCCESS)
    {
      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
              "DOT3ad: failed to create the interface\n");
      break; /* goto while (0) */
    }

    /* create the mutant counters for LAG */
    if ((rc = dot3adCounterCreate(*pIntIfNum)) != L7_SUCCESS)
      break; /* goto while (0) */

    /* get config for the LAG */
    if (cfgCreated)
    {
      memcpy(&dot3adAgg[aggIndex], &dot3adCfg.cfg.dot3adAgg[aggIndex], sizeof(dot3ad_agg_t));

      dot3adAgg[aggIndex].partnerSysPri = 0;
      dot3adAgg[aggIndex].partnerOperAggKey = 0;
      dot3adAgg[aggIndex].rxState = 0;
      dot3adAgg[aggIndex].txState = 0;

      dot3adAgg[aggIndex].currNumMembers = 0;
      dot3adAgg[aggIndex].currNumSelectedMembers = 0;
      dot3adAgg[aggIndex].activeNumMembers = 0;

      memset((void*)&dot3adAgg[aggIndex].aggPortList, 0, sizeof(L7_uint32) * L7_MAX_MEMBERS_PER_LAG);
      memset((void*)&dot3adAgg[aggIndex].aggSelectedPortList, 0, sizeof(L7_uint32) * L7_MAX_MEMBERS_PER_LAG);
      memset((void*)&dot3adAgg[aggIndex].aggActivePortList, 0, sizeof(L7_uint32) * L7_MAX_MEMBERS_PER_LAG);

      /* clear list and count */
      memset((void *)&dot3adAgg[aggIndex].aggWaitSelectedPortList[0],0,
             sizeof(L7_uint32) * L7_MAX_MEMBERS_PER_LAG);
      memset((void *)&dot3adAgg[aggIndex].aggPortListUsp[0],0,
             sizeof(dot3ad_usp_t) * L7_MAX_MEMBERS_PER_LAG);

      dot3adAgg[aggIndex].currNumWaitSelectedMembers = 0;

      dot3adAggIdx[*pIntIfNum]=aggIndex;

      if (cnfgrIsFeaturePresent(L7_DOT3AD_COMPONENT_ID, L7_DOT3AD_LAG_PRECREATE_FEATURE_ID) )
      {
        /* Assign the internal interface number to the aggId as the aggId was
       assigned the same value as lagId while defaults were built. This is
       not necessary when the config already has the correct aggId after the
       last config save but we still do it regardless as it does not harm. */
        nimFirstValidIntfNumberByType(L7_LAG_INTF, &aggIntIfNum);
        for (i = 1; i < lagId; i++)
        {
          nimNextValidIntfNumberByType(L7_LAG_INTF, aggIntIfNum, &aggIntIfNum);
        }
        dot3adAgg[aggIndex].aggId = aggIntIfNum;
        dot3adAgg[aggIndex].actorAdminAggKey = aggIntIfNum;
        dot3adAgg[aggIndex].actorOperAggKey = aggIntIfNum;
      }
    }
    else
    {
      dot3adLagIntfDefaultBuild(*pIntIfNum, aggIndex, DOT3AD_CFG_VER_CURRENT,
                                &dot3adAgg[aggIndex],&dot3adAggIdx[*pIntIfNum]);
    }

    /* Populate the operational structure with the int no returned by NIM*/
    dot3adAgg[aggIndex].aggId = *pIntIfNum;

    /* these can be done on the create since they don't actually touch HW */
    if ((rc = aggInuseSet(*pIntIfNum,L7_TRUE)) != L7_SUCCESS)
      break; /* goto while (0) */

	if (cfgCreated == L7_FALSE)
      if ((rc = dot3adLinkTrapModeSet(*pIntIfNum, linkTrapMode)) != L7_SUCCESS)
        break; /* goto while (0) */

    if ((rc = aggPortNameSet(*pIntIfNum, (L7_uchar8 *)name)) != L7_SUCCESS)
      break; /* goto while (0) */

    if ((rc = aggPortHashModeSet (*pIntIfNum, hashMode)) != L7_SUCCESS)
      break; /* goto while (0) */

    /* check if lag is static or dynamic and increment counters*/
    if (dot3adAgg[aggIndex].isStatic == L7_TRUE)
      dot3adLagCnt.StaticLagCnt++;
    else
      dot3adLagCnt.DynamicLagCnt++;

    /* check if hashMode is supported only system-wide. And copy the system wide value
       to the newly created lag */
    if (cnfgrIsFeaturePresent(L7_DOT3AD_COMPONENT_ID,
                              L7_DOT3AD_HASHMODE_GLOBAL_FEATURE_ID) == L7_TRUE)
    {
      dot3adAgg[aggIndex].hashMode = dot3adCfg.cfg.dot3adSystem.hashMode;
    }
   

    /* add check to see that number of dynamic lags created has not reached max limit*/
    if(dot3adLagCnt.DynamicLagCnt > platIntfDynamicLagIntfMaxCountGet())
    {
      /* Max number of dynamic lags configured */
      /* check if this a result of previous configuration .If yes, log error */
      /* Do not log an error if lag pre create feature is on as we are trying to create static 
         and dynamic lags at init */
      if ((cnfgrIsFeaturePresent(L7_DOT3AD_COMPONENT_ID, L7_DOT3AD_LAG_PRECREATE_FEATURE_ID)  == L7_FALSE)
         && (cfgCreated == L7_TRUE))
      {
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                "\n DOT3ad: Error in previous configuration stored.");
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                "\n DOT3ad: Number of dynamic lags: %d exceeds maximum limit %d.",dot3adLagCnt.DynamicLagCnt,platIntfDynamicLagIntfMaxCountGet());
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                "\n DOT3ad: Forcing Lag %d to be static.\n",lagId);
      }
      /* force lag to be static*/
      dot3adAgg[aggIndex].isStatic = L7_TRUE;
      /* adjust lag counters*/
      dot3adLagCnt.DynamicLagCnt--;
      dot3adLagCnt.StaticLagCnt++;
    }
    /* If config created, then we must wait til the interfaces exist */
    if (cfgCreated == L7_FALSE)
    {
      for (j=0;j<L7_MAX_MEMBERS_PER_LAG;j++)
      {
        if (members[j] != 0)
        {
          (void)dot3adLagMemeberAdd(*pIntIfNum, 1, &members[j]);
        }
      }
    }

    /*
     * set the right admin mode
     * The adminModeSet will be issued on the attach since it sends other
     * events to NIM.
     */
    dot3adAgg[aggIndex].adminMode = adminMode;

    /* Tell everybody that interface is created.
    */
    notifyEventInfo.component  = L7_DOT3AD_COMPONENT_ID;
	if (cfgCreated == L7_TRUE)
	{
    notifyEventInfo.pCbFunc    = dot3adNimEventCompletionCallback; 
	}
	else
	{
		/* If this is not through config register a different function
		   as that would need to give the sem */
		notifyEventInfo.pCbFunc    = dot3adNimEventCreateCompletionCallback;
	}
    notifyEventInfo.event      = L7_CREATE;
    notifyEventInfo.intIfNum   = *pIntIfNum;

    rc = nimEventIntfNotify(notifyEventInfo,&handle);
    if (rc != L7_SUCCESS)
    {
      LOG_ERROR (rc);
    }
	else if (cfgCreated == L7_FALSE)
	{
	  /* To prevent a deadlock between the emWeb Task, nim processing an attach event
	   * and dot3ad processing the same attach,(in dot3ad attach for a lag interface 
	   * the semaphore dot3adAggIntfCreateSema is taken)
	   * If we do not return it here there is a timing window where we get to this point 
	   * and block on the dot3adCreateSyncSema, waiting for NIM to send us a completion 
	   * notificatiom for the create, while NIM has just sent an ATTACH for a previous lag, This ATTACH 
	   * requires the dot3adAggIntfCreateSema, hence the deadlock
	   */
	  osapiSemaGive(dot3adAggIntfCreateSema);
	  /* Block until everybody knows about the create
	   * However we cannot (and do not want to) block when 
	   * cfgCreated is true as that will cause a deadlock */
		osapiSemaTake(dot3adCreateSyncSema,L7_WAIT_FOREVER);
	  return rc;
	}


    /* syncronize the agg creation between the caller and the event handler */
    /*osapiSemaGive(dot3adAggIntfCreateSema); */

  } while ( 0 );

  /* give semaphore even on error */
  osapiSemaGive(dot3adAggIntfCreateSema);

  return rc;
}
