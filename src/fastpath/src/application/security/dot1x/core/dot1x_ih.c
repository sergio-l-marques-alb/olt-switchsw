/*********************************************************************
*
* (C) Copyright Broadcom Corporation 2003-2007
*
**********************************************************************
* @filename  dot1x_ih.c
*
* @purpose   dot1x Interface Handler
*
* @component dot1x
*
* @comments  none
*
* @create    04/08/2003
*
* @author    mfiorito
*
* @end
*
**********************************************************************/

#include "dot1x_include.h"
#include "dot1q_api.h"
#include "fdb_api.h"
#include "tlv_api.h"
#include "l7_diffserv_api.h"
#include "dtlapi.h"
#include "dot1ad_l2tp_api.h"
#include "trapapi.h"
#include "dot1x_nsf.h"

extern dot1xCnfgrState_t dot1xCnfgrState;
extern L7_tlvHandle_t    dot1xTlvHandle;
extern L7_RC_t dtlLedBlinkSet(L7_BOOL enable);
extern void fdbDelete(char *mac, L7_uint32 vlanId);
extern void fdbInsert(char *mac, L7_uint32 intIfNum, L7_uint32 virtual_port, L7_uint32 vlanId, L7_ushort16 entryType);  /* PTin modified: virtual ports */
extern L7_RC_t dot1xMacBasedVlanParticipationSet(L7_uint32 lIntIfNum, L7_uint32 vlanId);
extern void  dot1xCnfgrWarmRestartTypeSet(L7_BOOL L7_FALSE);

extern L7_BOOL dot1xSwitchoverInProgress;

/*********************************************************************
* @purpose  Handles events generated by NIM
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    intfEvent  @b{(input)) interface event
* @param    correlator @b{(input)) Correlator for the event
*
* @returns  L7_SUCCESS  on a successful operation
* @returns  L7_FAILURE  for any error
*
* @comments
*
* @end
*********************************************************************/
L7_RC_t dot1xIntfChangeCallback(L7_uint32 intIfNum, L7_uint32 intfEvent, NIM_CORRELATOR_t correlator)
{
  dot1xIntfChangeParms_t parms;
  NIM_EVENT_COMPLETE_INFO_t status;

  if (intfEvent != L7_UP &&
      intfEvent != L7_PORT_ENABLE &&
      intfEvent != L7_LAG_RELEASE &&
      intfEvent != L7_PROBE_TEARDOWN &&
      intfEvent != L7_DOWN &&
      intfEvent != L7_PORT_DISABLE &&
      intfEvent != L7_LAG_ACQUIRE &&
      intfEvent != L7_PROBE_SETUP &&
      intfEvent != L7_CREATE &&
      intfEvent != L7_ATTACH &&
      intfEvent != L7_DETACH &&
      intfEvent != L7_DELETE &&
      intfEvent != L7_DOT1X_ACQUIRE)
  {
    status.intIfNum     = intIfNum;
    status.component    = L7_DOT1X_COMPONENT_ID;
    status.event        = intfEvent;
    status.correlator   = correlator;
    status.response.rc = L7_SUCCESS;
    nimEventStatusCallback(status);
    return L7_SUCCESS;
  }
  parms.intfEvent = intfEvent;
  parms.nimCorrelator = correlator;

  return dot1xIssueCmd(dot1xIntfChange, intIfNum, &parms);
}

/*********************************************************************
* @purpose  Handles startup notification from NIM
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    intfEvent  @b{(input)) interface event
* @param    correlator @b{(input)) Correlator for the event
*
* @returns  L7_SUCCESS  on a successful operation
* @returns  L7_FAILURE  for any error
*
* @comments
*
* @end
*********************************************************************/
void dot1xIntfStartupCallback(NIM_STARTUP_PHASE_t startupPhase)
{

  if (!(DOT1X_IS_READY))
  {
    nimStartupEventDone(L7_DOT1X_COMPONENT_ID);
    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1X_COMPONENT_ID,
            "Received an interface change callback while not ready to receive it. (startupPhase=%d",
            startupPhase);
    return;
  }
  dot1xIssueCmd(dot1xIntfStartup, L7_NULL, &startupPhase);
  return;
}

/*********************************************************************
* @purpose  Process NIM startup callback
*
* @param    startupPhase @b{(input)) CREATE or ACTIVATE
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhProcessIntfStartup(NIM_STARTUP_PHASE_t startup_phase)
{
  L7_RC_t rc;
  L7_uint32 intIfNum;
  PORTEVENT_MASK_t nimEventMask;
  L7_uint64 startTime, endTime;

#ifdef L7_NSF_PACKAGE
  L7_BOOL warmRestart;
#endif
  /*DOT1S_DEBUG_NSF(DOT1S_DEBUG_NSF_NIM,"Startup callback phase %s\n",
                  (startup_phase == NIM_INTERFACE_CREATE_STARTUP) ?
                  "CREATE" : "ACTIVATE");*/

  startTime = osapiTimeMillisecondsGet64();
  switch (startup_phase)
  {
  case NIM_INTERFACE_CREATE_STARTUP:
    rc = nimFirstValidIntfNumber(&intIfNum);

    while (rc == L7_SUCCESS)
    {
      if (dot1xIsValidIntf(intIfNum) == L7_TRUE)
      {
        if (dot1xIntfCreate(intIfNum) != L7_SUCCESS)
        {
          L7_LOGF(L7_LOG_SEVERITY_ERROR,L7_DOT1X_COMPONENT_ID,
                  "Error in creating Intf %d ", intIfNum);
        }
      }
      rc = nimNextValidIntfNumber(intIfNum, &intIfNum);
    }

    /* Now ask NIM to send any future changes for these event types */
    memset(&nimEventMask, 0, sizeof(PORTEVENT_MASK_t));
    PORTEVENT_SETMASKBIT(nimEventMask, L7_CREATE);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_DELETE);
    nimRegisterIntfEvents(L7_DOT1X_COMPONENT_ID, nimEventMask);
    break;

  case NIM_INTERFACE_ACTIVATE_STARTUP:

#ifdef L7_NSF_PACKAGE
    warmRestart = dot1xCnfgrIsRestartTypeWarm();   
    if (warmRestart == L7_TRUE) 
    {

       L7_uint32                   lIntIfNum = 0;
       dot1xLPortCheckPointData_t  pDot1xCkptNode;
       L7_uint32 dynamicVlanMode; 

       memset(&pDot1xCkptNode, 0, sizeof(dot1xLPortCheckPointData_t));
       while (dot1xCkptLogicalPortNextGet(lIntIfNum, &pDot1xCkptNode) == L7_SUCCESS)
       {
         if(pDot1xCkptNode.vlanAssigned != 0) 
         {
            dot1xDynamicVlanCreationModeGet(&dynamicVlanMode);
            if(dynamicVlanMode != L7_DISABLE)
            {
              if(dot1qVlanCheckValid(pDot1xCkptNode.vlanAssigned) != L7_SUCCESS) 
              {
                if(dot1qVlanCreate(pDot1xCkptNode.vlanAssigned, DOT1Q_DOT1X) != L7_SUCCESS)
                {
        		L7_LOGF(L7_LOG_SEVERITY_ERROR,L7_DOT1X_COMPONENT_ID, 
                  	"Error in creating dynamic vlan %d ", pDot1xCkptNode.vlanAssigned);
                }   
              } 
            }   
         }

         /* update logical port for the next pass */
         lIntIfNum = pDot1xCkptNode.logicalPortNumber;
         memset(&pDot1xCkptNode, 0, sizeof(dot1xLPortCheckPointData_t));
       } 

    }
#endif 

    rc = dot1xIntfActivateStartup();

#ifdef L7_NSF_PACKAGE
    warmRestart = dot1xCnfgrIsRestartTypeWarm();   

    if (warmRestart == L7_TRUE) 
    {
       L7_uint32                   lIntIfNum = 0;
       dot1xLPortCheckPointData_t  pDot1xCkptNode;
       dot1xLogicalPortInfo_t *logicalPortInfo;

       memset(&pDot1xCkptNode, 0, sizeof(dot1xLPortCheckPointData_t));

       while (dot1xCkptLogicalPortNextGet(lIntIfNum, &pDot1xCkptNode) == L7_SUCCESS)
       {

	 logicalPortInfo = dot1xLogicalPortInfoGet(pDot1xCkptNode.logicalPortNumber);

  	 if (logicalPortInfo != L7_NULLPTR)
         {   
           if((pDot1xCkptNode.vlanAssigned != 0) && 
             (dot1xPortInfo[logicalPortInfo->physPort].portControlMode == L7_DOT1X_PORT_AUTO)) 
           {
              dot1xVlanAssignmentEnable(logicalPortInfo, logicalPortInfo->vlanAssigned);
           }
           else if( (pDot1xCkptNode.guestVlanId != 0) &&
                   (dot1xPortInfo[logicalPortInfo->physPort].portControlMode == L7_DOT1X_PORT_AUTO))
           {
              dot1xCtlPortDot1xAcquire(logicalPortInfo->physPort, logicalPortInfo->guestVlanId);    
           }  
           else if( (pDot1xCkptNode.unauthVlan != 0) &&
                   (dot1xPortInfo[logicalPortInfo->physPort].portControlMode == L7_DOT1X_PORT_AUTO))
           {
              dot1xCtlPortDot1xAcquire(logicalPortInfo->physPort, logicalPortInfo->unauthVlan);    
           }
         }  
         /* update logical port for the next pass */
         lIntIfNum = pDot1xCkptNode.logicalPortNumber;
         memset(&pDot1xCkptNode, 0, sizeof(dot1xLPortCheckPointData_t));
       }
     }  
#endif

    /* Now ask NIM to send any future changes for these event types */
    memset(&nimEventMask, 0, sizeof(PORTEVENT_MASK_t));
    PORTEVENT_SETMASKBIT(nimEventMask, L7_CREATE);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_DELETE);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_ATTACH);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_DETACH);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_PORT_ENABLE);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_PORT_DISABLE);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_UP);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_DOWN);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_LAG_ACQUIRE);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_LAG_RELEASE);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_PROBE_SETUP);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_PROBE_TEARDOWN);
    PORTEVENT_SETMASKBIT(nimEventMask, L7_DOT1X_ACQUIRE);
    nimRegisterIntfEvents(L7_DOT1X_COMPONENT_ID, nimEventMask);
    break;

  default:
    break;
  }

  endTime = osapiTimeMillisecondsGet64();
  /*DOT1S_DEBUG_NSF(DOT1S_DEBUG_NSF_NIM,"startup callback done in %d msecs \n",
                  (endTime - startTime));*/
  nimStartupEventDone(L7_DOT1X_COMPONENT_ID);

  return L7_SUCCESS;
}
/*********************************************************************
* @purpose  Process Link state changes
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    intIfEvent @b{(input)) interface event
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhProcessIntfChange(L7_uint32 intIfNum, L7_uint32 intfEvent, NIM_CORRELATOR_t correlator)
{
  L7_uint32 linkState, adminState;
  L7_RC_t rc = L7_SUCCESS;
  L7_uint32 currAcquired, prevAcquired,lagAcquired;
  NIM_EVENT_COMPLETE_INFO_t status;
  NIM_INTF_MASK_t intfMask;
  dot1xPortCfg_t *pCfg;
  L7_uint32       lIntIfNum;
#if defined L7_DOT1AD_PACKAGE
  L7_uint32       nniIntf;
  L7_uchar8            suppStatus=0x00;
#endif
  dot1xLogicalPortInfo_t *logicalPortInfo;
  L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);

  status.intIfNum     = intIfNum;
  status.component    = L7_DOT1X_COMPONENT_ID;
  status.event        = intfEvent;
  status.correlator   = correlator;

  if (!(DOT1X_IS_READY))
  {
    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
            "dot1xIntfChangeCallback: Received an interface change callback while not ready to receive it");
    rc = L7_FAILURE;
    status.response.rc = rc;
    nimEventStatusCallback(status);
    return rc;
  }

  if ((intfEvent != L7_CREATE) && (intfEvent != L7_DELETE) && (intfEvent != L7_ATTACH))
  {
    /* Ensure dot1x is globally enabled */
    if (dot1xCfg->dot1xAdminMode != L7_ENABLE)
    {
      rc = L7_SUCCESS;
      status.response.rc = rc;
      nimEventStatusCallback(status);
      return rc;
    }
  }

  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
  {
    rc = L7_SUCCESS;
    status.response.rc = rc;
    nimEventStatusCallback(status);
    return rc;
  }

  DOT1X_EVENT_TRACE(DOT1X_TRACE_EVENTS,intIfNum,"%s:%d Nim Event %d received for %d \n",
                    __FUNCTION__,__LINE__,intfEvent,intIfNum);

  switch (intfEvent)
  {
  case L7_UP:
  case L7_PORT_ENABLE:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {
      if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
      {
#if defined L7_DOT1AD_PACKAGE
        if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                                  L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
        {
          if (dot1adNniInterfaceGet (&nniIntf)!= L7_SUCCESS)
          {
            break;
          }
          if (dot1xSupplicantPortSpmStatusGet (nniIntf,&suppStatus) == L7_SUCCESS)
          {
            if (suppStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
            {
              if (intIfNum != nniIntf)
                break;
            }
          }
        }
#endif

        if (dot1xPortInfo[intIfNum].portEnabled == L7_FALSE)
        {
          if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
               (adminState == L7_ENABLE) )
          {
            dot1xPortInfo[intIfNum].portEnabled = L7_TRUE;
            (void) dot1xPortReset(intIfNum);
            (void) dot1xCtlApplyPortConfigData(intIfNum);
          }
        }
      }
      else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
      {
        /* reApply Supplicant configurations */
        if (dot1xSupplicantPortInfo[intIfNum].portEnabled == L7_FALSE)
        {
          if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
               (adminState == L7_ENABLE) )
          {
            dot1xSupplicantPortInfo[intIfNum].portEnabled = L7_TRUE;
            (void) dot1xSupplicantPortReset(intIfNum);
            (void) dot1xCtlApplySupplicantPortConfigData(intIfNum);
          }
        }
      }
    }
    break;

  case L7_LAG_RELEASE:
  case L7_PROBE_TEARDOWN:

    /* Lag component sends a L7_LAG_RELEASE event before a L7_LAG_ACQUIRE as part of the port accquisition process
       It also sends a L7_LAG_RELEASE event when a port is released from a lag. Check that the port has been acctually accquired
       by the Lag before processing the L7_LAG_RELEASE event*/
    lagAcquired=L7_FALSE;
    if (intfEvent == L7_LAG_RELEASE)
    {
      if (COMPONENT_ACQ_ISMASKBITSET(dot1xPortInfo[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID)!=0)
      {
        lagAcquired = L7_TRUE;
      }
    }
    /* update aquired list */
    if ((intfEvent == L7_LAG_RELEASE) && (lagAcquired ==L7_TRUE))
      COMPONENT_ACQ_CLRMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID);
    else if (intfEvent == L7_PROBE_TEARDOWN)
      COMPONENT_ACQ_CLRMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_PORT_MIRROR_COMPONENT_ID);


    /* check if currently acquired */
    COMPONENT_ACQ_NONZEROMASK(dot1xPortInfo[intIfNum].acquiredList, currAcquired);

    /* If the interface is not currently acquired by some component, cause
     * the acquisition to be reflected in the state of the spanning tree
     */

    if (((intfEvent == L7_LAG_RELEASE)&&(lagAcquired == L7_TRUE)&&(currAcquired == L7_FALSE))||
        ((intfEvent == L7_PROBE_TEARDOWN)&&(currAcquired == L7_FALSE)))
    {
      if (nimGetIntfLinkState(intIfNum, &linkState) == L7_SUCCESS)
      {
        if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
             (adminState == L7_ENABLE) &&
             (nimGetIntfLinkState(intIfNum, &linkState) == L7_SUCCESS) &&
             (linkState == L7_UP) )
        {
          dot1xPortInfo[intIfNum].portEnabled = L7_TRUE;
          (void) dot1xPortReset(intIfNum);
          (void) dot1xCtlApplyPortConfigData(intIfNum);
        }
      }
    }
    break;

  case L7_DOWN:
  case L7_PORT_DISABLE:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {

      if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
      {
        dot1xPortInfo[intIfNum].portEnabled = L7_FALSE;
        lIntIfNum = DOT1X_LOGICAL_PORT_ITERATE;
        while ((logicalPortInfo=dot1xLogicalPortInfoGetNextNode(intIfNum,&lIntIfNum))!= L7_NULLPTR)
        {
          if (logicalPortInfo->inUse != L7_TRUE)
            continue;

          (void) dot1xStateMachineClassifier(apmNotPortEnabled, lIntIfNum, L7_NULL, L7_NULLPTR);
          (void) dot1xStateMachineClassifier(krxNotPortEnabled, lIntIfNum, L7_NULL, L7_NULLPTR);

          if (intfEvent == L7_DOWN)
          {
            if (dot1xRadiusAccountingStop(lIntIfNum, RADIUS_ACCT_TERM_CAUSE_LOST_CARRIER) != L7_SUCCESS)
              L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
                      "dot1xIhProcessIntfChange L7_DOWN: failed sending terminate cause, intf %s\n", ifName);

          }
          else
          {
            if (intfEvent == L7_PORT_DISABLE)
            {
              if (dot1xRadiusAccountingStop(lIntIfNum, RADIUS_ACCT_TERM_CAUSE_PORT_ADMINISTRATIVELY_DISABLED) != L7_SUCCESS)
                L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
                        "dot1xIhProcessIntfChange L7_DISABLE: failed sending terminate cause, intf %s\n", ifName);

            }
          }
        }

        /* check if the port is vlan assigned */
        dot1xPortVlanAssignmentDisable(intIfNum);

        /* reset operational info on the port*/
        (void)dot1xPortInfoInitialize(intIfNum,L7_TRUE);
        (void)dot1xCtlApplyPortConfigData(intIfNum);
      }
      else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
      {
        dot1xSupplicantPortInfo[intIfNum].portEnabled = L7_FALSE;
        (void)dot1xCtlApplySupplicantPortConfigData(intIfNum);
      }
    }
    break;

  case L7_LAG_ACQUIRE:
  case L7_PROBE_SETUP:
    /* check if previously acquired */
    COMPONENT_ACQ_NONZEROMASK(dot1xPortInfo[intIfNum].acquiredList, prevAcquired);

    /* update aquired list */
    if (intfEvent == L7_LAG_ACQUIRE)
      COMPONENT_ACQ_SETMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID);
    else
      COMPONENT_ACQ_SETMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_PORT_MIRROR_COMPONENT_ID);

    /* If the interface was not previously acquired by some component, cause
     * the acquisition to be reflected in the state of the spanning tree
     */
    if (prevAcquired == L7_FALSE)
    {
      if (dot1xPortInfo[intIfNum].portControlMode != L7_DOT1X_PORT_FORCE_AUTHORIZED)
      {
        /* reset all the clients associated with the port if port control mode is Macbased */
        if (dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
        {
          /* remove clients from any associated vlans*/
          dot1xPortVlanAssignmentDisable(intIfNum);
          /* reset all the clients associated with the port */
          (void) dot1xPortReset(intIfNum);
          (void) dot1xCtlApplyPortConfigData(intIfNum);
        }
        else
        {
          dot1xPortVlanAssignmentDisable(intIfNum);
          lIntIfNum = DOT1X_LOGICAL_PORT_ITERATE;
          while ((logicalPortInfo=dot1xLogicalPortInfoGetNextNode(intIfNum,&lIntIfNum))!= L7_NULLPTR)
          {
            if (logicalPortInfo->inUse == L7_TRUE)
              (void)dot1xStateMachineClassifier(apmPortControlEqualForceAuthorized, lIntIfNum,
                                                L7_NULL, L7_NULLPTR);
          }
          /*dot1xPortVlanAssignmentDisable(intIfNum);*/
        }

      }

      /*dot1xPortVlanAssignmentDisable(intIfNum);*/
      /* if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
       {
         if(pCfg->guestVlanId !=0)
         {
           dot1xCtlPortGuestVlanRemove(intIfNum,pCfg->guestVlanId);
         }
       }*/

    }
    break;

  case L7_CREATE:
    rc = dot1xIntfCreate(intIfNum);
    break;

  case L7_ATTACH:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {
      if (pCfg->paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
      {
        (void) dot1xPortReset(intIfNum);
        rc = dot1xCtlApplyPortConfigData(intIfNum);
      }
      else if (pCfg->paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
      {
        dot1xPortInfo[intIfNum].paeCapabilities = L7_DOT1X_PAE_PORT_SUPP_CAPABLE;
        if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
        {
          dot1xSupplicantPortInfoInitialize(intIfNum, L7_TRUE);
          dot1xCtlApplySupplicantPortConfigData(intIfNum);
        }
        else
        {
          /* If dot1x admin mode is disabled, set port to authorized */
          rc = dot1xIhPhyPortStatusSet (intIfNum, L7_DOT1X_PORT_STATUS_AUTHORIZED,L7_TRUE);
        }
      }
    }
    else
    {
      rc = L7_FAILURE;
    }
    break;

  case L7_DETACH:
    rc = dot1xIntfDetach(intIfNum);
    break;

  case L7_DELETE:
    rc = dot1xIntfDelete(intIfNum);
    break;

  case L7_DOT1X_ACQUIRE:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {
      if (dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO)
      {
        L7_uint32 vlanId=0;
        logicalPortInfo = dot1xPhysicalPortInfoNodeGet(intIfNum);

        if(logicalPortInfo->guestVlanId != 0)
        {
          vlanId = logicalPortInfo->guestVlanId;
        }
        else if(logicalPortInfo->vlanAssigned != 0)
        {
          vlanId = logicalPortInfo->vlanAssigned;
        }
        else if (logicalPortInfo->unauthVlan!=0)
        {
          vlanId = logicalPortInfo->unauthVlan;
        }
        else if(logicalPortInfo->defaultVlanId != 0 && logicalPortInfo->isMonitorModeClient == L7_TRUE)
        {
          vlanId = logicalPortInfo->defaultVlanId;
        }
    
        if(vlanId != 0)
        { 
          memset(&intfMask, 0, sizeof(intfMask));
          L7_INTF_SETMASKBIT(intfMask,intIfNum);
          dot1qSwitchPortModeSet(&intfMask, DOT1Q_SWPORT_MODE_GENERAL,
                                 DOT1Q_DOT1X);
          dot1xPortVlanMembershipSet(intIfNum, vlanId, L7_TRUE);
        }
      }
    }
    break;
  default:
    break;
  }

  status.response.rc = rc;
  nimEventStatusCallback(status);

  return rc;
}

/*********************************************************************
* @purpose  bring up the individual interface
*
* @param    warmRestart L7_BOOL true if restart type is warm
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments Handle the events ATTACH, UP, Acquire etc
*
* @end
*********************************************************************/
L7_RC_t dot1xIntfStart(L7_uint32 intIfNum, L7_BOOL warmRestart)
{
  dot1xPortCfg_t *pCfg;
#if defined L7_DOT1AD_PACKAGE
  L7_uint32       nniIntf;
  L7_uchar8            suppStatus=0x00;
#endif
  L7_RC_t rc = L7_FAILURE;
  L7_uint32 portLinkState;
  L7_COMPONENT_IDS_t acqCompId = L7_FIRST_COMPONENT_ID;
  L7_uint32 adminState;
  L7_BOOL probePort, lagEnabled;
  /* ATTACH */


  do
  {
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) != L7_TRUE)
      break;

    if (pCfg->paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
    {
      (void) dot1xPortReset(intIfNum);
      rc = dot1xCtlApplyPortConfigData(intIfNum);
    }
    else if (pCfg->paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
    {
      dot1xPortInfo[intIfNum].paeCapabilities = L7_DOT1X_PAE_PORT_SUPP_CAPABLE;
      if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
      {
        dot1xSupplicantPortInfoInitialize(intIfNum, L7_TRUE);
        dot1xCtlApplySupplicantPortConfigData(intIfNum);
      }
      else
      {
        /* If dot1x admin mode is disabled, set port to authorized */
        rc = dot1xIhPhyPortStatusSet (intIfNum, L7_DOT1X_PORT_STATUS_AUTHORIZED,L7_TRUE);
      }
    }

    /* Link state */
    rc = nimGetIntfLinkState(intIfNum, &portLinkState);
    if (rc != L7_SUCCESS)
    {
      break;
    }
    rc = nimGetIntfAdminState(intIfNum, &adminState);
    if (rc != L7_SUCCESS)
    {
      break;
    }

    probePort = mirrorIsActiveProbePort(intIfNum);
    if (probePort)
    {
      acqCompId = L7_PORT_MIRROR_COMPONENT_ID;
    }
    else
    {
      lagEnabled = dot3adIsLagActiveMember(intIfNum);
      if (lagEnabled)
      {
        acqCompId = L7_DOT3AD_COMPONENT_ID;
      }
    }

    if (acqCompId != L7_FIRST_COMPONENT_ID)
    {
      COMPONENT_ACQ_SETMASKBIT(dot1xPortInfo[intIfNum].acquiredList, acqCompId);
    }
    else
    {
      if (portLinkState == L7_UP)
      {

        if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
        {
#if defined L7_DOT1AD_PACKAGE
          if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                                    L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
          {
            if (dot1adNniInterfaceGet (&nniIntf)!= L7_SUCCESS)
            {
              break;
            }
            if (dot1xSupplicantPortSpmStatusGet (nniIntf,&suppStatus) == L7_SUCCESS)
            {
              if (suppStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
              {
                if (intIfNum != nniIntf)
                  break;
              }
            }
          }
#endif

#ifdef L7_NSF_PACKAGE
          if ((warmRestart == L7_TRUE) &&
              ((dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
              || (dot1xPortInfo[intIfNum].portControlMode ==  L7_DOT1X_PORT_AUTO)))
          {
            L7_uint32                   lIntIfNum = 0;
            dot1xLPortCheckPointData_t  *pDot1xCkptNode = L7_NULLPTR;
            dot1xLogicalPortInfo_t     *logicalPortInfo = L7_NULLPTR;

            if(dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO)
            {
              logicalPortInfo = dot1xPhysicalPortInfoNodeGet(intIfNum);

              if(((pDot1xCkptNode =  dot1xCkptLogicalPortInfoGet(logicalPortInfo->logicalPortNumber)) != L7_NULLPTR) &&
                 (pDot1xCkptNode->logicalPortNumber == logicalPortInfo->logicalPortNumber))
              {

                logicalPortInfo->inUse = L7_TRUE;

                memcpy(logicalPortInfo->suppMacAddr.addr, pDot1xCkptNode->suppMacAddr.addr, L7_MAC_ADDR_LEN);
                memcpy(logicalPortInfo->dot1xUserName, pDot1xCkptNode->dot1xUserName, DOT1X_USER_NAME_LEN);
                logicalPortInfo->dot1xUserNameLength = pDot1xCkptNode->dot1xUserNameLength;

                logicalPortInfo->currentIdL = pDot1xCkptNode->currentIdL;

                logicalPortInfo->vlanAssigned = pDot1xCkptNode->vlanAssigned;
                logicalPortInfo->vlanId  = pDot1xCkptNode->vlanId;
                logicalPortInfo->unauthVlan = pDot1xCkptNode->unauthVlan;
                logicalPortInfo->guestVlanId = pDot1xCkptNode->guestVlanId;
                logicalPortInfo->voiceVlanId = pDot1xCkptNode->voiceVlanId;
                logicalPortInfo->isMABClient = pDot1xCkptNode->isMABClient;
                logicalPortInfo->blockVlanId = pDot1xCkptNode->blockVlanId;
                logicalPortInfo->defaultVlanId = pDot1xCkptNode->defaultVlanId;
                logicalPortInfo->isMonitorModeClient = pDot1xCkptNode->isMonitorModeClient;
 
                logicalPortInfo->sessionTimeout = pDot1xCkptNode->sessionTimeout;
                logicalPortInfo->terminationAction = pDot1xCkptNode->terminationAction;
                logicalPortInfo->dot1xChallengelen = pDot1xCkptNode->dot1xChallengelen;
                logicalPortInfo->serverClassLen = pDot1xCkptNode->serverClassLen;
                logicalPortInfo->serverStateLen = pDot1xCkptNode->serverStateLen;

                logicalPortInfo->logicalPortStatus = pDot1xCkptNode->logicalPortStatus;

                memcpy(logicalPortInfo->serverState, pDot1xCkptNode->serverState,DOT1X_SERVER_STATE_LEN);
                memcpy(logicalPortInfo->serverClass, pDot1xCkptNode->serverClass,DOT1X_SERVER_CLASS_LEN);
                memcpy(logicalPortInfo->dot1xChallenge, pDot1xCkptNode->dot1xChallenge,DOT1X_CHALLENGE_LEN);
                memcpy(logicalPortInfo->filterName, pDot1xCkptNode->filterName,DOT1X_FILTER_NAME_LEN);

                dot1xPortInfo[intIfNum].numUsers++;
                dot1xCtlApplyLogicalPortConfigData(logicalPortInfo->logicalPortNumber);
                dot1xPortInfo[intIfNum].incCurrentId = L7_TRUE;

                dot1xMacAddrInfoAdd(&(logicalPortInfo->suppMacAddr), logicalPortInfo->logicalPortNumber);

                if(pDot1xCkptNode->vlanAssigned != 0)
                {
                  dot1xVlanAssignmentEnable(logicalPortInfo, logicalPortInfo->vlanAssigned);
                }
                else if(pDot1xCkptNode->guestVlanId != 0)
                {
                  dot1xCtlPortDot1xAcquire(logicalPortInfo->physPort, logicalPortInfo->guestVlanId);
                }
                else if(pDot1xCkptNode->unauthVlan != 0)
                {
                  dot1xCtlPortDot1xAcquire(logicalPortInfo->physPort, logicalPortInfo->unauthVlan);
                }
                else if(pDot1xCkptNode->defaultVlanId != 0 && pDot1xCkptNode->isMonitorModeClient == L7_TRUE)
                {
                  dot1xCtlPortDot1xAcquire(logicalPortInfo->physPort, logicalPortInfo->defaultVlanId);
                }
              }
            }
            else
            {

              for(lIntIfNum = DOT1X_LOGICAL_PORT_START(intIfNum); lIntIfNum < DOT1X_LOGICAL_PORT_END(intIfNum); lIntIfNum++)
              {

                if( (pDot1xCkptNode =  dot1xCkptLogicalPortInfoGet(lIntIfNum)) != L7_NULLPTR)
                {
                  logicalPortInfo = dot1xLogicalPortInfoAlloc(intIfNum);
                  if(logicalPortInfo == L7_NULLPTR)
                  {
                    L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
                    nimGetIntfName(intIfNum, L7_SYSNAME, ifName);

                    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
                          "Failed to create logical interfaces for intf %s ", ifName);
                  }
                  else if( logicalPortInfo->logicalPortNumber == lIntIfNum)
                  {
                    dot1xLogicalPortInfoSetPortInfo(logicalPortInfo);

                    logicalPortInfo->inUse = L7_TRUE;
                    memcpy(logicalPortInfo->suppMacAddr.addr, &pDot1xCkptNode->suppMacAddr, L7_MAC_ADDR_LEN);
                    logicalPortInfo->currentIdL = pDot1xCkptNode->currentIdL;
                    memcpy(logicalPortInfo->dot1xUserName, &pDot1xCkptNode->dot1xUserName, DOT1X_USER_NAME_LEN);
                    logicalPortInfo->dot1xUserNameLength = pDot1xCkptNode->dot1xUserNameLength;

                    logicalPortInfo->currentIdL = pDot1xCkptNode->currentIdL;

                    logicalPortInfo->vlanAssigned = pDot1xCkptNode->vlanAssigned;

                    logicalPortInfo->vlanId  = pDot1xCkptNode->vlanId;
                    logicalPortInfo->unauthVlan = pDot1xCkptNode->unauthVlan;
                    logicalPortInfo->guestVlanId = pDot1xCkptNode->guestVlanId;
                    logicalPortInfo->voiceVlanId = pDot1xCkptNode->voiceVlanId;
                    logicalPortInfo->isMABClient = pDot1xCkptNode->isMABClient;
                    logicalPortInfo->blockVlanId = pDot1xCkptNode->blockVlanId;
                    logicalPortInfo->defaultVlanId = pDot1xCkptNode->defaultVlanId;
                    logicalPortInfo->isMonitorModeClient = pDot1xCkptNode->isMonitorModeClient;

                    logicalPortInfo->sessionTimeout = pDot1xCkptNode->sessionTimeout;
                    logicalPortInfo->terminationAction = pDot1xCkptNode->terminationAction;
                    memcpy(logicalPortInfo->filterName, &pDot1xCkptNode->filterName,DOT1X_FILTER_NAME_LEN);


                    dot1xPortInfo[intIfNum].numUsers++;
                    dot1xCtlApplyLogicalPortConfigData(logicalPortInfo->logicalPortNumber);

                    if(logicalPortInfo->vlanAssigned != 0)
                    {
                      dot1xVlanAssignmentEnable(logicalPortInfo, logicalPortInfo->vlanAssigned);
                    }
                    else if(pDot1xCkptNode->guestVlanId != 0)
                    {
                      dot1xMacBasedVlanParticipationSet(logicalPortInfo->logicalPortNumber,logicalPortInfo->guestVlanId);
                    }
                    else if(pDot1xCkptNode->unauthVlan != 0)
                    {
                      dot1xMacBasedVlanParticipationSet(logicalPortInfo->logicalPortNumber,logicalPortInfo->unauthVlan);
                    }
                    else if(pDot1xCkptNode->voiceVlanId!= 0)
                    {
                      dot1xMacBasedVlanParticipationSet(logicalPortInfo->logicalPortNumber,logicalPortInfo->voiceVlanId);
                    }
                    else if(pDot1xCkptNode->defaultVlanId != 0 && pDot1xCkptNode->isMonitorModeClient == L7_TRUE)
                    {
                      dot1xMacBasedVlanParticipationSet(logicalPortInfo->logicalPortNumber,logicalPortInfo->defaultVlanId);
                    }

                    dot1xPortInfo[intIfNum].incCurrentId = L7_TRUE;

                    dot1xMacAddrInfoAdd(&(logicalPortInfo->suppMacAddr), logicalPortInfo->logicalPortNumber);
                  }
                }
              }
            }
          }
#endif
        }
        else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
        {
          /* reApply Supplicant configurations */
          if (adminState == L7_ENABLE)
          {
            dot1xSupplicantPortInfo[intIfNum].portEnabled = L7_TRUE;
            (void) dot1xSupplicantPortReset(intIfNum);
            (void) dot1xCtlApplySupplicantPortConfigData(intIfNum);
          }
        }
      } /* end if link state is up*/
    }/* end intf not acquired*/
  }
  while (L7_FALSE);
  /* Acquire /Release*/

  return rc;
}

/*********************************************************************
* @purpose  Process the activate startup callback from NIM
*
* @param
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIntfActivateStartup()
{
  L7_RC_t rc;
  L7_uint32 intIfNum = 0;

  /*startTime = osapiTimeMillisecondsGet();         */

  if (dot1xCnfgrIsRestartTypeWarm() == L7_TRUE)
  {

  }

  /* coldStartTime[0] = osapiUpTimeMillisecondsGet();*/

  rc = nimFirstValidIntfNumber(&intIfNum);

  while (rc == L7_SUCCESS)
  {

    /*coldStartTime[intIfNum] = osapiUpTimeMillisecondsGet();*/
    if (dot1xIsValidIntf(intIfNum) == L7_TRUE)
    {
      dot1xIntfStart(intIfNum, dot1xCnfgrIsRestartTypeWarm());
    }

    rc = nimNextValidIntfNumber(intIfNum, &intIfNum);
    /*coldEndTime[intIfNum] = osapiUpTimeMillisecondsGet();*/
  }

/*  coldEndTime[0] = osapiTimeMillisecondsGet();*/

  /* If the NSF table is populated attempt to reconcile the data*/

  if ((dot1xSwitchoverInProgress == L7_TRUE) &&
      (DOT1X_IS_READY && dot1xCfg->dot1xAdminMode == L7_ENABLE))
  {
    #ifdef L7_NSF_PACKAGE
    if (((rc=dot1xNsfTimersRestart()) != L7_SUCCESS) &&
        (rc != L7_NOT_SUPPORTED))
    {
      L7_LOGF(L7_LOG_SEVERITY_DEBUG, L7_DOT1X_COMPONENT_ID,
              "Failed to restart DOT1X timers on a warm restart.");
    }
    #endif
  }

  dot1xSwitchoverInProgress = L7_FALSE;
  cnfgrApiComponentHwUpdateDone(L7_DOT1X_COMPONENT_ID, L7_CNFGR_HW_APPLY_CONFIG);
  dot1xCnfgrWarmRestartTypeSet(L7_FALSE);

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Make sure this is a valid interface for dot1x
*
* @param    intIfNum   @b{(input)) internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhIntfValidate(L7_uint32 intIfNum)
{
  /* Check for valid interface number */
  if (nimCheckIfNumber(intIfNum) != L7_SUCCESS)
    return L7_FAILURE;

  /* Check for physical interface interface */
  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
    return L7_FAILURE;

  return L7_SUCCESS;
}
#if 0
/*********************************************************************
*
* @purpose  Adds a dynamically locked entry to an interface.
*
* @param    lIntIfNum  @b((input)) Logical interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
static
L7_RC_t dot1xFdbDynamicEntryAdd(L7_uint32 lIntIfNum)
{
  L7_uint32          physPort;
  L7_uchar8          key[L7_FDB_KEY_SIZE];
  dot1dTpFdbData_t   fdbEntry;
  L7_RC_t            rc;
  L7_ushort16        vlanId;
  fdbMeberInfo_t     fdbMember;

  if (dot1xLogicalPortInfo[lIntIfNum].inUse != L7_TRUE)
  {
    DOT1X_ERROR_SEVERE("Failed dot1xFdbDynamicEntryAdd on logical port %d",
                       lIntIfNum);
    return L7_FAILURE;
  }

  physPort = dot1xPhysPortGet(lIntIfNum);

  /* search the FDB to determine if this MAC already exists.
     If it exists as a static entry, return failure. If it
     exists as a dynamic entry, convert it to static */
  vlanId = (L7_ushort16)dot1xLogicalPortInfo[lIntIfNum].vlanId;
  memcpy(&key[0], &vlanId, sizeof(L7_ushort16));
  memcpy(&key[2], &dot1xLogicalPortInfo[lIntIfNum].suppMacAddr.addr, L7_ENET_MAC_ADDR_LEN);

  rc = fdbFind(key, L7_MATCH_EXACT, &fdbEntry);

  if (rc == L7_SUCCESS)
  {
    if (fdbEntry.dot1dTpFdbEntryType != L7_FDB_ADDR_FLAG_LEARNED ||
        fdbEntry.dot1dTpFdbPort != physPort)
      return L7_FAILURE;
    else
      return L7_SUCCESS;
  }

  /* tell FDB component about this address */
  memset(&fdbMember,0,sizeof(fdbMeberInfo_t));
  memcpy(fdbMember.macAddr,dot1xLogicalPortInfo[lIntIfNum].suppMacAddr.addr,L7_MAC_ADDR_LEN);
  fdbMember.vlanId = vlanId;
  fdbMember.intIfNum = physPort;
  fdbMember.entryType =  L7_FDB_ADDR_FLAG_LEARNED;

  fdbAddEntry(&fdbMember);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Removes a dynamically locked entry to an interface.
*
* @param    lIntIfNum  @b((input)) Logical interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
static
L7_RC_t dot1xFdbDynamicEntryDelete(L7_uint32 lIntIfNum)
{
  fdbMeberInfo_t     fdbMember;

  memset(&fdbMember,0,sizeof(fdbMeberInfo_t));
  memcpy(fdbMember.macAddr,dot1xLogicalPortInfo[lIntIfNum].suppMacAddr.addr,L7_MAC_ADDR_LEN);
  fdbMember.vlanId = dot1xLogicalPortInfo[lIntIfNum].vlanId;
  fdbMember.intIfNum = dot1xPhysPortGet(lIntIfNum);
  fdbMember.entryType =  L7_FDB_ADDR_FLAG_LEARNED;

  fdbDelEntry(&fdbMember);
  return L7_SUCCESS;;
}
#endif

/*********************************************************************
* @purpose  Set the dot1x port authorization status
*
* @param    lIntIfNum   @b{(input)) internal interface number
* @param    portStatus @b{(input)) port authorization status setting
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* @returns  L7_ERROR
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhPortStatusSet(L7_uint32 lIntIfNum, L7_DOT1X_PORT_STATUS_t portStatus)
{
  L7_uint32 physPort;
  dot1xLogicalPortInfo_t *logicalPortInfo;
  L7_BOOL client_oper = L7_FALSE;
  L7_ushort16   vlanId;
  L7_uint32 pvid;

  logicalPortInfo = dot1xLogicalPortInfoGet(lIntIfNum);
  if (logicalPortInfo == L7_NULLPTR)
  {
    return L7_FAILURE;
  }
  physPort = logicalPortInfo->physPort;

  DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:Setting the Logical port-%d to %s\n",
                    __FUNCTION__,lIntIfNum,
                    (portStatus==L7_DOT1X_PORT_STATUS_AUTHORIZED)?"Authorize":"Unauthorize");

  /* Verify port status parm value */
  if (portStatus != L7_DOT1X_PORT_STATUS_AUTHORIZED && portStatus != L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
    return L7_FAILURE;

  if (dot1xPortInfo[physPort].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
  {
    /*If setting to the same value, just return success */
    if (portStatus == logicalPortInfo->logicalPortStatus)
    {
      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d Status already set \n",__FUNCTION__,__LINE__);
      /* if ((portStatus != L7_DOT1X_PORT_STATUS_AUTHORIZED) ||
       ((logicalPortInfo->reAuthenticating != L7_TRUE) && (logicalPortInfo->reauth_auth_apply != L7_TRUE)) ||
        (logicalPortInfo->suppRestarting != L7_TRUE))
     {*/
      return L7_SUCCESS;
      /* } */

    }

    if (dot1xPortInfo[physPort].portControlMode != L7_DOT1X_PORT_AUTO_MAC_BASED)
    {
      if (logicalPortInfo->inUse == L7_TRUE)
      {
        logicalPortInfo->logicalPortStatus = portStatus;
#ifdef L7_NSF_PACKAGE
        if (cnfgrIsFeaturePresent(L7_FLEX_STACKING_COMPONENT_ID,
                                  L7_STACKING_NSF_FEATURE_ID) == L7_TRUE)
        {
          if (portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
          {
            if ((dot1xCfg->dot1xAdminMode == L7_ENABLE) &&
                (dot1xPortInfo[physPort].portControlMode != L7_DOT1X_PORT_FORCE_AUTHORIZED))
            { 
              dot1xCallCheckpointService(lIntIfNum, DOT1X_LOG_PORT_ADD_TLV);
              dot1xCallCheckpointService(lIntIfNum, DOT1X_PHY_PORT_TLV);
            }
          }
          else if ((portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED ) &&
                   (dot1xPortInfo[physPort].portControlMode != L7_DOT1X_PORT_FORCE_UNAUTHORIZED))
          {
            dot1xCallCheckpointService(lIntIfNum, DOT1X_LOG_PORT_DELETE_TLV);
            dot1xCallCheckpointService(lIntIfNum, DOT1X_PHY_PORT_TLV);
          }
        }
#endif
      }
      else
      {
        DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:FAILED to set . Port status is the same as before.\n",__FUNCTION__,__LINE__);
        return L7_SUCCESS;
      }

    }
    else
    {
      client_oper = L7_FALSE;
      if (logicalPortInfo->inUse == L7_TRUE)
      {
        if (portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
        {
#ifdef L7_QOS_FLEX_PACKAGE_DIFFSERV
          L7_uint32     tlvLen = 0;
          L7_uint32     policyIndex;
          L7_uchar8     tempName[DOT1X_FILTER_NAME_LEN];
#endif
          L7_tlv_t      *pTlv = L7_NULL;

          /* Add the entry in the driver */
          if (logicalPortInfo->vlanAssigned != 0)
          {
            vlanId = logicalPortInfo->vlanAssigned;
          }
          else if (logicalPortInfo->unauthVlan != 0)
          {
            vlanId = logicalPortInfo->unauthVlan;
          }
          else if (logicalPortInfo->guestVlanId != 0)
          {
            vlanId = logicalPortInfo->guestVlanId;
          }
          else if (logicalPortInfo->voiceVlanId != 0)
          {
            vlanId = logicalPortInfo->voiceVlanId;
          }
          else if ((logicalPortInfo->defaultVlanId != 0) && (logicalPortInfo->isMonitorModeClient == L7_TRUE))
          {
            vlanId = logicalPortInfo->defaultVlanId;
          }
          else
          {
            /* Check if the dot1q pvid is same as one this client has */
            if (dot1qQportsVIDGet(physPort, L7_DOT1Q_DEFAULT_VID_INDEX, &pvid) == L7_SUCCESS)
            {
              vlanId = pvid;
              logicalPortInfo->vlanId = pvid;
            }
            else
            {
              vlanId = logicalPortInfo->vlanId;
            }
          }

          /* Check for QoS package presence*/
#ifdef L7_QOS_FLEX_PACKAGE_DIFFSERV
          if (cnfgrIsFeaturePresent(L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,L7_DIFFSERV_FEATURE_SUPPORTED)==L7_TRUE)
          {
            pTlv = L7_NULL;
            memset(tempName,0,DOT1X_FILTER_NAME_LEN);
            if (memcmp(logicalPortInfo->filterName,tempName,sizeof(tempName))!=0)
            {
              if (diffServPolicyNameToIndex(logicalPortInfo->filterName,
                                            &policyIndex) == L7_SUCCESS)
              {
                if (diffServPolicyTlvGet(policyIndex,physPort,
                                         L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN,
                                         dot1xTlvHandle) == L7_SUCCESS)
                {
                  tlvQuery(dot1xTlvHandle,&pTlv,&tlvLen);
                }
              }
            }
          }
#else
          pTlv=L7_NULL;
#endif
          if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
          {
            DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:adding the client %02x:%02x:%02x:%02x:%02x:%02x, vlan= %d to port %d \n",
                              __FUNCTION__,__LINE__,
                              logicalPortInfo->suppMacAddr.addr[0],
                              logicalPortInfo->suppMacAddr.addr[1],
                              logicalPortInfo->suppMacAddr.addr[2],
                              logicalPortInfo->suppMacAddr.addr[3],
                              logicalPortInfo->suppMacAddr.addr[4],
                              logicalPortInfo->suppMacAddr.addr[5],
                              vlanId,
                              physPort);
            if (dtlDot1xIntfClientAdd(physPort,
                                      logicalPortInfo->suppMacAddr,
                                      vlanId,pTlv) != L7_SUCCESS)
            {
              L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
                      "%s: Error in adding the client details to the driver."
                      " Could not add client (logical port) details to the hardware."
                      ,__FUNCTION__);
              DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"\n%s:%d Error in adding the client details to the driver \n",__FUNCTION__,__LINE__);
              client_oper = L7_FALSE;
              /* remove the previously blocked entry if the vlan id does not match*/
              if (logicalPortInfo->blockVlanId != 0 && logicalPortInfo->blockVlanId != vlanId)
              {
                DOT1X_EVENT_TRACE(DOT1X_TRACE_EXTERNAL,physPort,
                                  "%s:%d Unblocking the Client %02x:%02x:%02x:%02x:%02x:%02x with vlan id- %d \n",
                                  __FUNCTION__,__LINE__,
                                  logicalPortInfo->suppMacAddr.addr[0],
                                  logicalPortInfo->suppMacAddr.addr[1],
                                  logicalPortInfo->suppMacAddr.addr[2],
                                  logicalPortInfo->suppMacAddr.addr[3],
                                  logicalPortInfo->suppMacAddr.addr[4],
                                  logicalPortInfo->suppMacAddr.addr[5],
                                  logicalPortInfo->blockVlanId);
                dtlDot1xIntfClientUnblock(physPort,logicalPortInfo->suppMacAddr,logicalPortInfo->blockVlanId);
                logicalPortInfo->blockVlanId = 0;
              }
            }
            else
            {
              /* Add entry into FDB so user can see it since this will be (quasi)static and SDK won't update FDB */
              fdbInsert(&logicalPortInfo->suppMacAddr.addr[0], physPort, 0 /* Not used */, vlanId, L7_FDB_ADDR_FLAG_DOT1X_STATIC);

              /* remove the previously blocked entry if the vlan id does not match*/
              if (logicalPortInfo->blockVlanId != 0 && logicalPortInfo->blockVlanId != vlanId)
              {
                DOT1X_EVENT_TRACE(DOT1X_TRACE_EXTERNAL,physPort,
                                  "%s:%d Unblocking the Client %02x:%02x:%02x:%02x:%02x:%02x with vlan id- %d \n",
                                  __FUNCTION__,__LINE__,
                                  logicalPortInfo->suppMacAddr.addr[0],
                                  logicalPortInfo->suppMacAddr.addr[1],
                                  logicalPortInfo->suppMacAddr.addr[2],
                                  logicalPortInfo->suppMacAddr.addr[3],
                                  logicalPortInfo->suppMacAddr.addr[4],
                                  logicalPortInfo->suppMacAddr.addr[5],
                                  logicalPortInfo->blockVlanId);
                dtlDot1xIntfClientUnblock(physPort,logicalPortInfo->suppMacAddr,logicalPortInfo->blockVlanId);
                logicalPortInfo->blockVlanId = 0;
              }

#ifdef L7_NSF_PACKAGE
              logicalPortInfo->logicalPortStatus = portStatus;

              if (cnfgrIsFeaturePresent(L7_FLEX_STACKING_COMPONENT_ID,
                                      L7_STACKING_NSF_FEATURE_ID) == L7_TRUE)
              {
                dot1xCallCheckpointService(lIntIfNum, DOT1X_LOG_PORT_ADD_TLV);
                dot1xCallCheckpointService(lIntIfNum, DOT1X_PHY_PORT_TLV);
              }
#endif
              client_oper = L7_TRUE;
            }
          }
          else
          {
            client_oper = L7_TRUE;
          }
          /* free the tlv handle */
          if (pTlv != L7_NULL)
          {
            tlvDelete(dot1xTlvHandle);
          }
        } /* end if(portStatus == Authorize) */
        else if (portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED &&
                 logicalPortInfo->logicalPortStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
        {
          dot1xPortCfg_t  *pCfg;

          if (dot1xIntfIsConfigurable(physPort, &pCfg) == L7_TRUE)
          {
            if (dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
            {
              if (logicalPortInfo->vlanAssigned != 0)
              {
                vlanId = logicalPortInfo->vlanAssigned;
              }
              else if (logicalPortInfo->unauthVlan != 0)
              {
                vlanId = logicalPortInfo->unauthVlan;
              }
              else if (logicalPortInfo->guestVlanId != 0)
              {
                vlanId = logicalPortInfo->guestVlanId;
              }
              else if (logicalPortInfo->voiceVlanId != 0)
              {
                vlanId = logicalPortInfo->voiceVlanId;
              }
              else if ((logicalPortInfo->defaultVlanId != 0) && (logicalPortInfo->isMonitorModeClient == L7_TRUE))
              {
                vlanId = logicalPortInfo->defaultVlanId;
              }
              else
              {
                /* Check if the dot1q pvid is same as one this client has */
                if (dot1qQportsVIDGet(physPort, L7_DOT1Q_DEFAULT_VID_INDEX, &pvid) == L7_SUCCESS)
                {
                  vlanId = pvid;
                  logicalPortInfo->vlanId = pvid;
                }
                else
                {
                  vlanId = logicalPortInfo->vlanId;
                }
              }

              if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
              {
                DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:removing the client %d, Mac Addr:%02x:%02x:%02x:%02x:%02x:%02x from port %d \n",
                                __FUNCTION__,__LINE__,
                                logicalPortInfo->logicalPortNumber ,
                                logicalPortInfo->suppMacAddr.addr[0],
                                logicalPortInfo->suppMacAddr.addr[1],
                                logicalPortInfo->suppMacAddr.addr[2],
                                logicalPortInfo->suppMacAddr.addr[3],
                                logicalPortInfo->suppMacAddr.addr[4],
                                logicalPortInfo->suppMacAddr.addr[5],
                                physPort);
                if (dtlDot1xIntfClientRemove(physPort,logicalPortInfo->suppMacAddr) != L7_SUCCESS)
                {
                  L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
                        "%s: Error in removing the client details from the driver."
                        " Could not remove client details from the driver",__FUNCTION__);
                  DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,
                        "\n%s:%d Error in removing the client details from the driver\n",__FUNCTION__,__LINE__);
                  client_oper = L7_FALSE;
                }
                else
                {
#ifdef L7_NSF_PACKAGE
                  if (cnfgrIsFeaturePresent(L7_FLEX_STACKING_COMPONENT_ID,
                                            L7_STACKING_NSF_FEATURE_ID) == L7_TRUE)
                  {
                    dot1xCallCheckpointService(lIntIfNum, DOT1X_LOG_PORT_DELETE_TLV);
                  }
#endif
                  client_oper = L7_TRUE;
                  fdbDelete(&logicalPortInfo->suppMacAddr.addr[0], vlanId);
                }
              }
            }/*mac based*/
          }
        }

        /* Save new state */
        logicalPortInfo->logicalPortStatus = portStatus;

      } /* end if (logicalPort == in Use) */
      else
      {
        DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:FAILED to set \n",__FUNCTION__,__LINE__);
        return L7_SUCCESS;
      }
    }

    if (portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
    {
      if (dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
      {
        if (client_oper == L7_TRUE)
        {
          if (dot1xPortInfo[physPort].authCount!=0)
          {
            dot1xPortInfo[physPort].authCount--;
            DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS, physPort,
                            "%s:%d:Decreased authcount (%d) for physical port:%d because of removal of client:%d  \n",
                            __FUNCTION__, __LINE__, dot1xPortInfo[physPort].authCount,physPort, lIntIfNum);
          }
        }
      }
      else
      {
        if (dot1xPortInfo[physPort].authCount!=0)
        { 
          dot1xPortInfo[physPort].authCount--;
        }
      }
    }
    else
    {
      if (dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
      {
        if (client_oper == L7_TRUE)
        {
          if (dot1xPortInfo[physPort].authCount!=DOT1X_MAX_USERS_PER_PORT)
          {  
            dot1xPortInfo[physPort].authCount++;
          }
          DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:Increased authcount (%d) for physical port:%d because of adding of client:%d  \n",
                          __FUNCTION__,__LINE__,dot1xPortInfo[physPort].authCount,physPort,lIntIfNum);
        }
      }
      else
      {
        if (dot1xPortInfo[physPort].authCount!=DOT1X_MAX_USERS_PER_PORT)
        {
          dot1xPortInfo[physPort].authCount++;
        }
        DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:Increased authcount (%d) for physical port:%d  \n",
                        __FUNCTION__,__LINE__,dot1xPortInfo[physPort].authCount,physPort);
      }
    }

    /* Generate NIM event and set the driver state */
    if (dot1xPortInfo[physPort].authCount == 1
        && portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
    {
      if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
      {
        trapMgrDot1xPortStatusAuthorizedLogTrap(physPort);
      }
      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS, physPort,
                      "%s:%d:Setting physical port:%d to Authorized as authcount = %d \n",
                      __FUNCTION__, __LINE__, physPort, dot1xPortInfo[physPort].authCount);
      dot1xPortInfo[physPort].portStatus =  L7_DOT1X_PORT_STATUS_AUTHORIZED;

      /* During a reauthentication or supplicant restarting, a port remains in
      authorized state. If the reauthentication is successful, but some of the
      client associated parameters viz vlan assigned of filter Id assigned
      have changed, then this change needs to be propgated to the hardware.
      In order to do this, this function is called to set the port to
      unauthorized and then back to authorized. In the process the old
      information for the client is removed and the new one is added.Since
      ultimately the port remains authorized, we want to avoid the costly
      operation of NIM notify for the port. Hence in case of reauthentication
      or supplicant restart with changed parameters for the client we avoid
      NIM Notify. */
      if ((dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED) &&
          ((logicalPortInfo->reAuthenticating == L7_TRUE) || (logicalPortInfo->suppRestarting == L7_TRUE)) &&
          (logicalPortInfo->reauth_auth_apply == L7_TRUE))
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_FALSE);
      }
      else
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_TRUE);
      }
    }
    else if (dot1xPortInfo[physPort].authCount == 0 &&
             portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
    {
      if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
      {
        trapMgrDot1xPortStatusUnauthorizedLogTrap(physPort);
      }

      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS, physPort,
                      "%s:%d:Setting physical port:%d to Unauthorized as authcount = %d \n",
                      __FUNCTION__, __LINE__, physPort, dot1xPortInfo[physPort].authCount);
      dot1xPortInfo[physPort].portStatus = L7_DOT1X_PORT_STATUS_UNAUTHORIZED;
      if ((dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED) &&
          ((logicalPortInfo->reAuthenticating == L7_TRUE) || (logicalPortInfo->suppRestarting == L7_TRUE)) &&
          (logicalPortInfo->reauth_auth_apply == L7_TRUE))
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_FALSE);
      }
      else
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_TRUE);
      }
    }

#ifdef L7_NSF_PACKAGE
    if (cnfgrIsFeaturePresent(L7_FLEX_STACKING_COMPONENT_ID,
                            L7_STACKING_NSF_FEATURE_ID) == L7_TRUE)
    {
      dot1xCallCheckpointService(lIntIfNum, DOT1X_PHY_PORT_TLV);
    }
#endif

  }


  return L7_SUCCESS;
}


/*********************************************************************
* @purpose  Set the dot1x port authorization status
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    portStatus @b{(input)) port authorization status setting
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* @returns  L7_ERROR
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhPhyPortStatusSet(L7_uint32 intIfNum, L7_DOT1X_PORT_STATUS_t portStatus,L7_BOOL bNotifyNim)
{
  NIM_HANDLE_t           handle;
  NIM_EVENT_NOTIFY_INFO_t eventInfo;
  dot1xPortCfg_t          *pCfg;
  L7_BOOL                 flag=L7_FALSE;

  /* Set the port status in the driver */
  if (dot1xIntfIsConfigurable(intIfNum, &pCfg)== L7_FALSE)
    return L7_FAILURE;

  if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
  {

    if (dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
    {
      /* Need to get the violation packets to CPU in mac-based mode */
      flag = L7_TRUE;
    }

    if (!(dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED &&
          dot1xCfg->dot1xAdminMode == L7_ENABLE && pCfg->portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED))
    {
      if (dtlDot1xIntfStatusSet(intIfNum, portStatus, flag) != L7_SUCCESS)
      {
        return L7_FAILURE;
      }
      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,intIfNum,"%s:Setting the port-%d and flag-%d to %s\n",
                        __FUNCTION__,intIfNum,flag,
                        (portStatus==L7_DOT1X_PORT_STATUS_AUTHORIZED)?"Authorize":"Unauthorize");
    }
  }
  else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
  {

    {
      if (dtlDot1xIntfStatusSet(intIfNum, portStatus, flag) != L7_SUCCESS)
      {
        return L7_FAILURE;
      }
      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,intIfNum,"%s:Setting the port-%d to %s\n",
                        __FUNCTION__,intIfNum,
                        (portStatus==L7_DOT1X_PORT_STATUS_AUTHORIZED)?"Authorize":"Unauhtorize");
#if defined L7_DOT1AD_PACKAGE
      if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                                L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
      {
        {
          DOT1AD_INTFERFACE_TYPE_t  intfType;
          dot1adInterfaceTypeGet(intIfNum, &intfType);
          if (intfType == DOT1AD_INTFERFACE_TYPE_NNI)
          {
            if (portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
            {
              dtlLedBlinkSet(L7_FALSE);
            }
            else
            {
              dtlLedBlinkSet(L7_TRUE);
            }
          }
        }
      }
#endif
    }
  }

  if (bNotifyNim == L7_TRUE)
  {
    /* Notify NIM of the port status as NIM is port specific */
    if (portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
    {
      eventInfo.event = L7_DOT1X_PORT_UNAUTHORIZED;
    }
    else if (portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
    {
      eventInfo.event = L7_DOT1X_PORT_AUTHORIZED;
    }
    else
    {
      return L7_FAILURE;
    }
    eventInfo.component     = L7_DOT1X_COMPONENT_ID;
    eventInfo.pCbFunc       = L7_NULLPTR;
    eventInfo.intIfNum      = intIfNum;

    if (nimEventIntfNotify(eventInfo,&handle) != L7_SUCCESS)
    {
      return L7_FAILURE;
    }
  }




  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Obtain a pointer to the specified interface configuration data
*           for this interface
*
* @param    intIfNum @b{(input)} Internal Interface Number
* @param    **pCfg   @b{(output)}  Ptr  to dot1x port config structure
*                           or L7_NULL if not needed
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
*
* @comments Facilitates pre-configuration, as it checks if the NIM
*           interface exists and whether the component is in a state to
*           be configured (regardless of whether the component is enabled
*           or not).
*
* @comments The caller can set the pCfg parm to L7_NULL if it does not
*           want the value output from this function.
*
* @end
*********************************************************************/
L7_BOOL dot1xIntfIsConfigurable(L7_uint32 intIfNum, dot1xPortCfg_t **pCfg)
{
  nimConfigID_t configId;
  L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);

  if (!(DOT1X_IS_READY))
    return L7_FALSE;

  /* Check boundary conditions */
  if (intIfNum <= 0 || intIfNum >= L7_DOT1X_INTF_MAX_COUNT)
    return L7_FALSE;


  /* verify that the configId in the config data table entry matches the configId that NIM maps to
   ** the intIfNum we are considering
   */
  if (nimConfigIdGet(intIfNum, &configId) == L7_SUCCESS)
  {
    if (NIM_CONFIG_ID_IS_EQUAL(&configId, &(dot1xCfg->dot1xPortCfg[intIfNum].configId)) == L7_TRUE)
    {
      *pCfg = &dot1xCfg->dot1xPortCfg[intIfNum];
      return L7_TRUE;
    }
  }

  /* if we get here, either we have a table management error between dot1xCfg and dot1xMapTbl or
  ** there is synchronization issue between NIM and components w.r.t. interface creation/deletion
  */
  L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
          "Error accessing dot1x config data for interface %s in dot1xIntfIsConfigurable.\n", ifName);
  return L7_FALSE;
}

/*********************************************************************
* @purpose  Obtain a pointer to the first free interface config struct
*
* @param    intIfNum @b{(input)} Internal Interface Number
* @param    **pCfg   @b{(output)}  Ptr  to dot1x port config structure
*                           or L7_NULL if not needed
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
*
* @comments Facilitates pre-configuration, as it checks if the NIM
*           interface exists and whether the component is in a state to
*           be configured (regardless of whether the component is enabled
*           or not).
*
* @end
*********************************************************************/
L7_BOOL dot1xIntfConfigEntryGet(L7_uint32 intIfNum, dot1xPortCfg_t **pCfg)
{
  L7_uint32 i;
  nimConfigID_t configId;
  nimConfigID_t configIdNull;
  L7_RC_t rc;

  memset(&configIdNull, 0, sizeof(nimConfigID_t));

  if (!(DOT1X_IS_READY))
    return L7_FALSE;

  if ((rc = nimConfigIdGet(intIfNum, &configId)) == L7_SUCCESS)
  {
    for (i = 1; i < L7_DOT1X_INTF_MAX_COUNT; i++)
    {
      if (NIM_CONFIG_ID_IS_EQUAL(&dot1xCfg->dot1xPortCfg[i].configId, &configIdNull))
      {
        dot1xMapTbl[intIfNum] = i;
        *pCfg = &dot1xCfg->dot1xPortCfg[i];
        return L7_TRUE;
      }
    }
  }

  return L7_FALSE;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_CREATE
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1xIntfCreate(L7_uint32 intIfNum)
{
  nimConfigID_t configId;
  dot1xPortCfg_t *pCfg;

  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
    return L7_FAILURE;

  if (nimConfigIdGet(intIfNum, &configId) != L7_SUCCESS)
    return L7_FAILURE;

  pCfg = &dot1xCfg->dot1xPortCfg[intIfNum];
  NIM_CONFIG_ID_COPY(&pCfg->configId, &configId);


  /* If an interface configuration entry is not already assigned to the interface, assign one */

  /* Update the configuration structure with the config id */
  dot1xBuildDefaultIntfConfigData(&configId, pCfg);
#if defined L7_DOT1AD_PACKAGE
  if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                            L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
  {
    if (intIfNum == FD_DOT1X_WAN_PORT)
    {
      pCfg->paeCapabilities = L7_DOT1X_PAE_PORT_SUPP_CAPABLE;
    }
  }
#endif
  dot1xBuildDefaultSupplicantIntfConfigData(&configId, pCfg);


  /* Allocate the Memory for the operational strcuture */
  if (dot1xPhysicalPortInfoNodeGet(intIfNum)==L7_NULLPTR)
  {
    dot1xLogicalPortInfoAlloc(intIfNum);
  }
  /* Initialize the port info and clear the stats for this interface */
  (void)dot1xPortInfoInitialize(intIfNum,L7_TRUE);
#if defined L7_DOT1AD_PACKAGE
  if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                            L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
  {
    if (intIfNum == FD_DOT1X_WAN_PORT)
    {
      pCfg->paeCapabilities = L7_DOT1X_PAE_PORT_SUPP_CAPABLE;
    }
  }
#endif
  (void)dot1xCtlPortStatsClear(intIfNum);

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_DETACH
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1xIntfDetach(L7_uint32 intIfNum)
{
  dot1xPortCfg_t *pCfg;

  if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
  {
    if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
    {
      /*dot1xBuildDefaultIntfConfigData(&pCfg->configId, pCfg);*/
      dot1xPortVlanAssignmentDisable(intIfNum);
      dot1xPortInfoInitialize(intIfNum,L7_TRUE);
      (void)dot1xCtlApplyPortConfigData(intIfNum);
    }
    else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
    {
      /* Disable previous Supplicant functionality */
      (void) dot1xStateMachineClassifier(sbmSuppAbort, intIfNum, L7_NULL, L7_NULLPTR);
      (void) dot1xSupplicantPortInfoInitialize(intIfNum,L7_TRUE);
      dot1xIhPhyPortStatusSet(intIfNum,L7_DOT1X_PORT_STATUS_AUTHORIZED,
                              L7_TRUE);
    }
  }

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_DELETE
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1xIntfDelete(L7_uint32 intIfNum)
{
  dot1xPortCfg_t *pCfg;
  L7_uint32      lIndex = 0;
  dot1xLogicalPortInfo_t *logicalPortInfo;

  if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
  {
    dot1xPortVlanAssignmentDisable(intIfNum);

    memset((void *)&pCfg->configId, 0, sizeof(nimConfigID_t));
    memset((void *)&dot1xMapTbl[intIfNum], 0, sizeof(L7_uint32));
    memset((void *)&dot1xPortInfo[intIfNum], 0, sizeof(dot1xPortInfo_t));
    memset((void *)&dot1xPortStats[intIfNum], 0, sizeof(dot1xPortStats_t));

    lIndex = DOT1X_LOGICAL_PORT_ITERATE;
    while ((logicalPortInfo=dot1xLogicalPortInfoGetNextNode(intIfNum,&lIndex))!= L7_NULLPTR)
    {
      /*remove supplicant mac address from Mac address Database*/
      dot1xMacAddrInfoRemove(&(logicalPortInfo->suppMacAddr));
      dot1xLogicalPortInfoDeAlloc(logicalPortInfo);
    }
  }

  return L7_SUCCESS;
}


/*********************************************************************
* @purpose  Set the Violation Callback in the driver
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    flag       @b{(input)) True to set the value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* @returns  L7_ERROR
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhPhyPortViolationCallbackSet(L7_uint32 intIfNum, L7_BOOL flag)
{
  DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,intIfNum,"%s:Setting the %d for violation callback \n",
                    __FUNCTION__,intIfNum);
  return dtlDot1xIntfStatusSet(intIfNum,L7_DOT1X_PORT_STATUS_UNAUTHORIZED ,flag);
}
