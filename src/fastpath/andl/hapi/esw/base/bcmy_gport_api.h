/*
 * $Id: $
 * 
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __PTIN_GPORT_API_H__
#define __PTIN_GPORT_API_H__

#include <bcm/types.h>
#include <bcm/error.h>

#include <stdint.h>
#include "dapi.h"
#include "globaldefs.h"

#define BCMY_INVALID_VAL    BCM_GPORT_INVALID

typedef enum bcmy_error_e {
    BCMY_E_NONE      = BCM_E_NONE,      /* Success */
    BCMY_E_PARAM     = BCM_E_PARAM,     /* Invalid inputs */
    BCMY_E_NOT_FOUND = BCM_E_NOT_FOUND, /* Entry not found */
    BCMY_E_EXISTS    = BCM_E_EXISTS,    /* Entry already exists */
    BCMY_E_CONFIG    = BCM_E_CONFIG,    /* Configuration error */
    BCMY_E_FAIL      = BCM_E_FAIL,      /* Operation failed */
    BCMY_E_INIT      = BCM_E_INIT,      /* Missing intialization */
    BCMY_E_INTERNAL  = BCM_E_INTERNAL,  /* Internal error */
    BCMY_E_MEMORY    = BCM_E_MEMORY,    /* Memory allocation error */
} bcmy_error_t;

/********************************************************************
 * GPORT MANIPULATION FUNCTIONS                                     *
 ********************************************************************/

#define BCMY_GPORT_VALID(gport) bcmy_gport_is_valid(gport)

#define BCMY_GPORT_BCM_UNIT(gport)    bcmy_gport_bcm_unit_get(gport)
#define BCMY_GPORT_BCM_PORT(gport)    bcmy_gport_bcm_port_get(gport)
#define BCMY_GPORT_MODID(gport)       bcmy_gport_modid_get(gport)
#define BCMY_GPORT_MODPORT(gport)     bcmy_gport_modport_get(gport)
#define BCMY_GPORT_LOCAL_PORT(gport)  bcmy_gport_localport_get(gport)

/** Iterate over all configured gports in lookup tables */
#define BCMY_GPORT_ITER(idx, gport)  \
    for (idx=0; \
         (gport=bcmy_gport_list_get(idx)) != BCM_GPORT_INVALID; \
         idx++)

/** Iterate over all configured local gports in lookup tables */
#define BCMY_GPORT_LOCAL_ITER(idx, gport)  \
    for (idx=0; \
         (gport=bcmy_gport_list_get(idx)) != BCM_GPORT_INVALID; \
         idx++) \
        if (bcmy_gport_is_local(gport))

/**
 * Check if gport is a valid value
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return BOOL : TRUE / FALSE
 */
BOOL bcmy_gport_is_valid(bcm_gport_t gport);

/**
 * Check if GPORT is hw mapped
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return BOOL : TRUE / FALSE
 */
extern BOOL bcmy_gport_is_hwmapped(bcm_gport_t gport);

/**
 * Check if BCM unit/port is hw mapped
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in) BCM unit
 * @param port (in) BCM port
 * 
 * @return BOOL : TRUE / FALSE
 */
extern BOOL bcmy_unit_port_is_hwmapped(int unit, int port);

/**
 * Check if GPORT is local to this board
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return BOOL : TRUE / FALSE
 */
extern BOOL bcmy_gport_is_local(bcm_gport_t gport);

/**
 * Return first CPU interface for this unit
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * 
 * @return bcm_gport_t : first CPU interface 
 */
extern bcm_gport_t bcmy_gport_local_cpu_get_first(int unit);

/**
 * Get next CPU interface for this unit
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * @param gport (in): CPU interface
 * 
 * @return bcm_gport_t : next CPU interface
 */
extern bcm_gport_t bcmy_gport_local_cpu_get_next(int unit, bcm_gport_t gport);

#if 0 /* XGS not supported */
/**
 * Return first OLP interface for this unit
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * 
 * @return bcm_gport_t : first OLP interface
 */
extern bcm_gport_t bcmy_gport_local_olp_get_first(int unit);

/**
 * Return next OLP interface for this unit
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * @param gport (in): OLP interface
 * 
 * @return bcm_gport_t : next OLP interface
 */
extern bcm_gport_t bcmy_gport_local_olp_get_next(int unit, bcm_gport_t gport);
#endif

/**
 * Return local/mod port associated to this gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return int : local port
 */
extern int bcmy_gport_bcm_port_get(bcm_gport_t gport);

/**
 * Return local port associated to this gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return int : local port
 */
extern int bcmy_gport_localport_get(bcm_gport_t gport);

/**
 * Return bcm_unit associated to this gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return int : bcm_unit
 */
extern int bcmy_gport_bcm_unit_get(bcm_gport_t gport);

/**
 * Return modid associated to this gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return int : modid
 */
extern int bcmy_gport_modid_get(bcm_gport_t gport);

/**
 * Return modport associated to this gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * 
 * @return int : modport
 */
extern int bcmy_gport_modport_get(bcm_gport_t gport);

/**
 * Convert bcm_unit to modid
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * @param modid_base (out)
 * @param modid_number (out)
 * 
 * @return bcmy_error_t : 
 *       BCMY_E_NONE (success)
 *       BCMY_E_PARAM (invalid inputs)
 *       BCMY_E_FAIL (operation failed)
 */
extern bcmy_error_t bcmy_unit_to_modid(int unit, int *modid_base, int *modid_number);

/**
 * Convert modid to unit
 * 
 * @author mruas (04/08/20)
 * 
 * @param modid (in)
 * @param bcm_unit (out)
 * 
 * @return bcmy_error_t : 
 *       BCMY_E_NONE (success)
 *       BCMY_E_PARAM (invalid inputs)
 */
extern bcmy_error_t bcmy_modid_to_unit(int modid, int *bcm_unit);

/**
 * Return modid and modport associated to this gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * @param modid (out)
 * @param modport (out)
 * 
 * @return bcmy_error_t : 
 *       BCMY_E_NONE (success)
 *       BCMY_E_PARAM (invalid inputs)
 */
extern bcmy_error_t bcmy_gport_to_modid_port(bcm_gport_t gport, int *modid, bcm_port_t *modport);

/**
 * Return gport asscociated to a modid+modport
 * 
 * @author mruas (04/08/20)
 * 
 * @param modid (in)
 * @param port (in)
 * @param gport (out)
 * 
 * @return bcmy_error_t : 
 *       BCMY_E_NONE (success)
 *       BCMY_E_PARAM (invalid inputs)
 */
extern bcmy_error_t bcmy_modid_port_to_gport(int modid, bcm_port_t port, bcm_gport_t *gport);

/**
 * Return bcm_unit/port associated to a gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * @param unit (out)
 * @param port (out)
 * 
 * @return bcmy_error_t : 
 *       BCMY_E_NONE (success)
 *       BCMY_E_PARAM (invalid inputs)
 */
extern bcmy_error_t bcmy_gport_to_unit_port(bcm_gport_t gport, int *unit, bcm_port_t *port);

/**
 * Return gport associated to a bcm_unit/port
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * @param port (in)
 * @param gport (out)
 * 
 * @return bcmy_error_t : 
 *       BCMY_E_NONE (success)
 *       BCMY_E_PARAM (invalid inputs)
 */
extern bcmy_error_t bcmy_unit_port_to_gport(int unit, bcm_port_t port, bcm_gport_t *gport);


/********************************************************************
 * GPORT LOOKUP TABLE TO ACESS USP AND BCM_UNIT/PORT INFORMATION    *
 ********************************************************************/

/**
 * Initialize internal structures.
 * 
 * @author mruas (04/08/20) 
 *  
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (Invalid inputs)
 *      BCMY_E_MEMORY (Memory allocation error)
 */
extern bcmy_error_t bcmy_lut_gport_init(void);

/**
 * Obtain USP from bcm_unit/port inputs
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * @param port (in)
 * @param usp (out)
 * 
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (Invalid inputs)
 *      BCMY_E_INIT (Missing initialization)
 *      BCMY_E_CONFIG (Entry not configured)
 */
extern bcmy_error_t bcmy_lut_unit_port_to_usp_get(int unit, int port, DAPI_USP_t *usp);

/**
 * Obtain gport from USP input
 * 
 * @author mruas (04/08/20)
 * 
 * @param usp (in)
 * @param gport (out)
 * 
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (Invalid inputs)
 *      BCMY_E_INIT (Missing initialization)
 *      BCMY_E_CONFIG (Entry not configured)
 */
extern bcmy_error_t bcmy_lut_usp_to_gport_get(DAPI_USP_t usp, bcm_gport_t *gport);

/**
 * Obtain gport from bcm_unit/port inputs
 * 
 * @author mruas (04/08/20)
 * 
 * @param unit (in)
 * @param port (in)
 * @param gport (out)
 * 
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (Invalid inputs)
 *      BCMY_E_INIT (Missing initialization)
 *      BCMY_E_CONFIG (Entry not configured)
 */
extern bcmy_error_t bcmy_lut_unit_port_to_gport_get(int unit, int port, bcm_gport_t *gport);

/**
 * Obtain usp from gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * @param usp (out)
 * 
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (Invalid inputs)
 *      BCMY_E_NOT_FOUND (Entry not found)
 */
extern bcmy_error_t bcmy_lut_gport_to_usp_get(bcm_gport_t gport, DAPI_USP_t *usp);

/**
 * Obtain bcm_unit/port from gport
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in)
 * @param unit (out)
 * @param port (out)
 * 
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (Invalid inputs)
 *      BCMY_E_NOT_FOUND (Entry not found)
 */
extern bcmy_error_t bcmy_lut_gport_to_unit_port_get(bcm_gport_t gport, int *unit, int *port);

/**
 * Associate a gport to a bcm_unit/port and USP interfaces
 * 
 * @author mruas (04/08/20)
 * 
 * @param gport (in) 
 * @param unit (in) 
 * @param port (in) 
 * @param usp (in)
 *  
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (invalid inputs)
 *      BCMY_E_INIT (missing initialization)
 *      BCMY_E_CONFIG (entry already configured)
 *      BCMY_E_EXISTS (gport already exists in table)
 */
extern bcmy_error_t bcmy_lut_gport_set(bcm_gport_t gport, int unit, int port, DAPI_USP_t *usp);

/**
 * Reset gport entry at LUT tables
 * 
 * @author mruas (04/08/20)
 *  
 * @param unit (in) 
 * @param port (in) 
 * @param usp (in)
 *  
 * @return bcmy_error_t : 
 *      BCMY_E_NONE (Success)
 *      BCMY_E_PARAM (invalid inputs)
 *      BCMY_E_CONFIG (inconsistent configurations)
 */
extern bcmy_error_t bcmy_lut_gport_reset(int unit, int port, DAPI_USP_t *usp);

/**
 * Return configured gport in lookup tables
 * 
 * @author mruas (06/08/20)
 * 
 * @param index : use index to iterate over all gports
 * 
 * @return bcm_gport_t 
 */
extern bcm_gport_t bcmy_gport_list_get(int index);

/********************************************************************
 * GPLIST MANIPULATION FUNCTIONS                                    *
 ********************************************************************/

/* 
 * Deprecated flags to indicate groups of ports.
 * 
 * Use BCMX_PORT_LP_* instead.
 */
#define BCMY_GP_ALL             (1 << 0)   /* 0x00000001 */
#define BCMY_GP_FE              (1 << 1)   /* 0x00000002 */
#define BCMY_GP_GE              (1 << 2)   /* 0x00000004 */
#define BCMY_GP_XE              (1 << 3)   /* 0x00000008 */
#define BCMY_GP_HG              (1 << 4)   /* 0x00000010 */

/* 
 * Deprecated flags.
 * 
 * BCMY_GP_UNIQ:  Elements appear on the list at most once.
 * BCMY_GP_SORT:  Keep the list sorted by bcm_gport value
 * BCMY_GP_USER is a flag that can be used at the application level
 */
#define BCMY_GP_UNIQ            (1 << 5)   /* 0x00000020 */
#define BCMY_GP_SORT            (1 << 6)   /* 0x00000040 */
#define BCMY_GP_USER            (1 << 8)   /* 0x00000100 */

/* BCMX Logical Port List */
typedef struct bcmy_gplist_s {
    int gp_last;            /* Index of last elt on list. -1 --> empty (only
                               significant if list is not null). */
    int gp_alloc;           /* How many spaces currently allocated. */
    bcm_gport_t *gp_ports; /* Pointer to the ports. */
} bcmy_gplist_t;

/* 
 * Logical Port List macros.
 * 
 *      BCMY_GPLIST_ADD(list, gport)
 *           Add an element to the end of the list; doesn't check
 *           for sorted or uniquness.
 *           Alias for function w/ same (lower case) name
 *      BCM_GPLIST_REMOVE(list, gport)
 *           Search for the first occurrance of gport on the list
 *           and remove it if found.
 *      BCM_GPLIST_IDX_REMOVE(list, idx)
 *           Remove the gport at idx
 *      BCMY_GPLIST_ITER(list, gport, count)
 *           Iterate through the list (passed by value)
 *           in order of the array
 *      BCMY_GPLIST_IDX_ITER(list, gport, count)
 *           Iterate through the list (passed by reference)
 *           in order of the array
 *      BCM_GPLIST_IS_NULL
 *           Boolean: Is list invalid?
 *      BCM_GPLIST_IS_EMPTY
 *           Boolean:  Is list invalid or has no elements?
 *      BCM_GPLIST_COUNT
 *           Returns the number of elements on the list
 */
#define BCMY_GPLIST_IS_NULL(list)  \
    (((void *)(list) == NULL) || ((list)->gp_ports == NULL)) 
#define BCMY_GPLIST_IS_EMPTY(list)  \
    (BCMY_GPLIST_IS_NULL(list) || ((list)->gp_last < 0)) 
#define BCMY_GPLIST_COUNT(list)  \
    (BCMY_GPLIST_IS_EMPTY(list) ? 0 : ((list)->gp_last + 1)) 
#define BCMY_GPLIST_IDX_REMOVE(list, idx)  do {                 \
    int _i;                                                     \
                                                                \
    if (((idx) >= 0) && ((idx) <= (list)->gp_last)) {           \
        for (_i = (idx); _i < (list)->gp_last; _i++) {          \
            (list)->gp_ports[_i] = (list)->gp_ports[_i + 1];    \
        }                                                       \
        ((list)->gp_last)--;                                    \
    }                                                           \
} while (0) 
#define BCMY_GPLIST_REMOVE(list, gport)  do {                   \
    int _idx;                                                   \
                                                                \
    _idx = bcmy_gplist_index_get(list, gport);                  \
    if (_idx >= 0) {                                            \
        BCMY_GPLIST_IDX_REMOVE(list, _idx);                     \
    }                                                           \
} while (0) 
#define BCMY_GPLIST_ADD(list, gport)  \
    bcmy_gplist_add(list, gport) /* Alias bcmy_gplist_add as a macro. */
#define BCMY_GPLIST_IDX_ITER(list_p, gport, count)               \
    for ((gport) = (list_p)->gp_ports[0], (count) = 0;           \
         (count) <= (list_p)->gp_last;                           \
         (gport) = (list_p)->gp_ports[++(count)]) /* NOTE:  List is a pointer here; not
                                              a pointer below.  Ick. */

/* 
 * Iterate across a port list.
 *    Notes:  If a port is on the list twice, it will
 *    occur twice in the loop.
 *    Does not support flags in the port list (ALL, FE, GE....)
 * NOTE:  List is NOT a pointer here; it is a pointer above.  Ick.
 */
#define BCMY_GPLIST_ITER(list, gport, count)  \
    BCMY_GPLIST_IDX_ITER(&(list), gport, count) 

/* 
 * Logical Port List functions.
 * 
 *   int  bcmy_gplist_init(list, init_count, flags)
 *   void bcmy_gplist_t_init(list)
 *      Initialize the lplist.
 *   int  bcmy_gplist_free(list)
 *   void bcmy_gplist_t_free(list)
 *      Free an initialized lplist.
 *   int bcmy_gplist_clear(list)
 *      Clear an lplist.
 *   int bcmy_gplist_index_get(list, gport)
 *      Return the index of gport
 *   int bcmy_gplist_index_get_from(list, position, port)
 *      Return the index of gport starting at position
 *   bcm_gport_t bcmy_gplist_index(list, position)
 *      Return the gport at position
 *   int bcmy_gplist_add(list, gport)
 *      Add gport to the end of list
 *   int bcmy_gplist_port_remove(list, gport, all)
 *      Remove first or all gport from list
 *   int bcmy_gplist_eq(list1, list2)
 *      Return 1 if lists have the same members (O(N^2))
 *   int bcmy_gplist_append(list1, list2)
 *      Append list2 to list2
 *   int bcmy_gplist_copy(dest, src)
 *      Copy src to dest
 *   int bcmy_gplist_check(list)
 *      Check list consistency
 *   int bcmy_gplist_range(list, start, end)
 *      Add range of gports to list
 * 
 * Compatibility
 * 
 *   bcmy_gplist_first(list)
 *      Return first gport in list
 *   bcmy_gplist_last_insert(list, port)
 *      Same as bcmy_gplist_add()
 * 
 * Removed for SDK 5.3.0
 * 
 *   BCMY_GP_ALL
 *   BCMY_GP_FE
 *   BCMY_GP_GE
 *   BCMY_GP_XE
 *   BCMY_GP_HG
 * 
 *     BCMX_PORT_LP_* and bcmx_port_lplist_populate provide equivalent
 *     functionality.
 * 
 * 
 *   BCMY_GP_SORT
 *   BCMY_GP_UNIQ
 * 
 *     Use bcmy_gplist_sort() and bcmy_gplist_uniq() to sort and
 *     make lists contail unique members.
 * 
 * 
 *   BCMY_GP_USER
 * 
 *     No equivalent functionality provided.
 * 
 *   bcmy_gplist_current_insert()
 *   bcmy_gplist_current_delete()
 *   bcmy_gplist_last_insert()
 *   bcmy_gplist_insert()
 *   bcmy_gplist_next()
 *   bcmy_gplist_current()
 *   bcmy_gplist_merge()
 *   BCM_GPL_DEF_LEN
 * 
 *   No equivalent functionality provided.
 */

extern int bcmy_gplist_init(
    bcmy_gplist_t *list, 
    int init_count, 
    uint32 flags);

extern int bcmy_gplist_free(
    bcmy_gplist_t *list);

extern int bcmy_gplist_clear(
    bcmy_gplist_t *list);

extern void bcmy_gplist_t_init(
    bcmy_gplist_t *list);

extern void bcmy_gplist_t_free(
    bcmy_gplist_t *list);

extern int bcmy_gplist_index_get(
    bcmy_gplist_t *list, 
    bcm_gport_t port);

extern int bcmy_gplist_index_get_from(
    bcmy_gplist_t *list, 
    int position, 
    bcm_gport_t port);

extern bcm_gport_t bcmy_gplist_index(
    bcmy_gplist_t *list, 
    int position);

/* Compatibility. */
#define bcmy_gplist_first(list)  bcmy_gplist_index((list), 0) 
#define bcmy_gplist_last_insert(list, port)  bcmy_gplist_add((list), (port)) 

extern int bcmy_gplist_add(
    bcmy_gplist_t *list, 
    bcm_gport_t gport);

extern int bcmy_gplist_port_remove(
    bcmy_gplist_t *list, 
    bcm_gport_t gport, 
    int all);

extern int bcmy_gplist_eq(
    bcmy_gplist_t *list1, 
    bcmy_gplist_t *list2);

extern int bcmy_gplist_append(
    bcmy_gplist_t *list1, 
    bcmy_gplist_t *list2);

extern int bcmy_gplist_copy(
    bcmy_gplist_t *dest, 
    bcmy_gplist_t *src);

extern int bcmy_gplist_check(
    bcmy_gplist_t *list);

extern int bcmy_gplist_range(
    bcmy_gplist_t *list, 
    bcm_gport_t start, 
    bcm_gport_t end);

extern int bcmy_gplist_is_null(
    bcmy_gplist_t *list);

extern int bcmy_gplist_is_empty(
    bcmy_gplist_t *list);

extern int bcmy_gplist_count(
    bcmy_gplist_t *list);

extern void bcmy_gplist_remove(
    bcmy_gplist_t *list, 
    int gport);

extern void bcmy_gplist_idx_remove(
    bcmy_gplist_t *list, 
    int idx);

extern int bcmy_gplist_pbmp_add(
    bcmy_gplist_t *list, 
    int unit, 
    bcm_pbmp_t *pbm);

extern void bcmy_gplist_to_pbmp(
    bcmy_gplist_t *list, 
    int unit, 
    bcm_pbmp_t *pbm);

extern int bcmy_gplist_sort(
    bcmy_gplist_t *list);

extern int bcmy_gplist_uniq(
    bcmy_gplist_t *list);

extern int _bcmy_gplist_pbmp_add(
    bcmy_gplist_t *list, 
    int unit, 
    bcm_pbmp_t pbm);


/* 
 * LP List to port bitmap function/macros.
 * 
 *     BCM_GPLIST_TO_PBMP   -- Extract ports from an lplist to a bitmap
 *                              Procedural (no return value)
 *     BCM_GPLIST_PBMP_ADD  -- Add ports from a bitmap to an lplist
 *                              Returns BCM_E_XXX.
 * 
 * Note:  These macros are inefficient and may be replaced with a
 * better implementation (with lplist changes) in the future.
 */
#define BCM_GPLISTPTR_TO_PBMP(_gplist, _unit, _pbm)  do {                \
    bcm_gport_t _gport;                                                  \
    int _count;                                                          \
    int _bcm_unit;                                                       \
    bcm_port_t _bcm_port;                                                \
    BCM_PBMP_CLEAR(_pbm);                                                \
    BCMY_GPLIST_IDX_ITER(((_gplist)), _gport, _count)  {                  \
        if (BCM_GPORT_IS_SET(_gport)) {                                  \
            if (bcmy_gport_to_unit_port(_gport, &_bcm_unit, &_bcm_port) == BCM_E_NONE) \
            {                                                            \
                if (_bcm_unit == _unit) {                                \
                    BCM_PBMP_PORT_ADD(_pbm, _bcm_port);                  \
                }                                                        \
            }                                                            \
        }                                                                \
    }                                                                    \
} while (0) 
#define BCM_GPLIST_TO_PBMP(_lplist, _unit, _pbm)  \
        BCM_GPLISTPTR_TO_PBMP(&_lplist, _unit, _pbm) 
#define BCM_GPLIST_PBMP_ADD(_lplist_p, _unit, _pbm)  \
        _bcmy_gplist_pbmp_add(_lplist_p, _unit, _pbm) 

#endif /* __PTIN_GPORT_API_H__ */
