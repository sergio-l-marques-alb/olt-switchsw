/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: traverse_client.c 1.12.2.3 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:	traverse_client.c
 * Purpose:	BCM API Traverse Server routines for remote units
 * Generator:	mkdispatch 1.41.2.3
 * Generated:	Sat May  5 12:19:17 2012
 */

#include <shared/alloc.h>
#include <bcm/types.h>
#include <bcm/ces.h>
#include <bcm/cosq.h>
#include <bcm/diffserv.h>
#include <bcm/field.h>
#include <bcm/ipfix.h>
#include <bcm/ipmc.h>
#include <bcm/l2.h>
#include <bcm/l3.h>
#include <bcm/mim.h>
#include <bcm/mirror.h>
#include <bcm/mpls.h>
#include <bcm/multicast.h>
#include <bcm/niv.h>
#include <bcm/oam.h>
#include <bcm/policer.h>
#include <bcm/subport.h>
#include <bcm/time.h>
#include <bcm/trill.h>
#include <bcm/trunk.h>
#include <bcm/vlan.h>
#include <bcm/wlan.h>

#include <bcm_int/rpc/pack.h>
#include "traverse.h"

#ifdef	BCM_RPC_SUPPORT


#ifdef	INCLUDE_CES

int
bcm_client_ces_services_traverse(
	int	unit,
	uint32	flags,
	bcm_ces_service_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x90e65d9e,0xcf643c0b,0x5ba55c9c,0x4bf8ba92,0xd6b819e9 };

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, flags);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */

			r_rv = cb(unit, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#endif	/* INCLUDE_CES */

int
bcm_client_cosq_gport_traverse(
	int	unit,
	bcm_cosq_gport_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xcdd16376,0x9b8ac79f,0xd0b2074a,0x456f0101,0xb667687c };
	bcm_gport_t	r_port;
	int	r_numq;
	uint32	r_flags;
	bcm_gport_t	r_gport;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U32(r_req.rx_ptr, r_numq);
			BCM_UNPACK_U32(r_req.rx_ptr, r_flags);
			BCM_UNPACK_U32(r_req.rx_ptr, r_gport);

			r_rv = cb(unit, r_port, r_numq, r_flags, r_gport, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_cosq_subscriber_traverse(
	int	unit,
	bcm_cosq_subscriber_map_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x7eaa044b,0x4739ff12,0x82703193,0x8bc6a763,0x26eb7aae };
	bcm_cosq_subscriber_map_t	r_map;
	bcm_cosq_subscriber_map_t *	r_p_map;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_map = NULL;
			} else {
				r_p_map = &r_map;
				r_req.rx_ptr = _bcm_unpack_cosq_subscriber_map(r_req.rx_ptr, r_p_map);
			}

			r_rv = cb(unit, r_p_map, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_ds_classifier_traverse(
	int	unit,
	int	dpid,
	bcm_ds_classifier_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x5b616166,0x0eaeca37,0x1bc508f3,0xb6b27745,0x432bfcdf };
	int	r_dpid;
	int	r_cfid;
	bcm_ds_clfr_t	r_clfr;
	bcm_ds_inprofile_actn_t	r_inp_actn;
	bcm_ds_outprofile_actn_t	r_outp_actn;
	bcm_ds_nomatch_actn_t	r_nm_actn;
	bcm_ds_clfr_t *	r_p_clfr;
	bcm_ds_inprofile_actn_t *	r_p_inp_actn;
	bcm_ds_outprofile_actn_t *	r_p_outp_actn;
	bcm_ds_nomatch_actn_t *	r_p_nm_actn;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, dpid);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_dpid);
			BCM_UNPACK_U32(r_req.rx_ptr, r_cfid);
			if (*r_req.rx_ptr++ == 1) {
				r_p_clfr = NULL;
			} else {
				r_p_clfr = &r_clfr;
				r_req.rx_ptr = _bcm_unpack_ds_clfr(r_req.rx_ptr, r_p_clfr);
			}
			if (*r_req.rx_ptr++ == 1) {
				r_p_inp_actn = NULL;
			} else {
				r_p_inp_actn = &r_inp_actn;
				r_req.rx_ptr = _bcm_unpack_ds_inprofile_actn(r_req.rx_ptr, r_p_inp_actn);
			}
			if (*r_req.rx_ptr++ == 1) {
				r_p_outp_actn = NULL;
			} else {
				r_p_outp_actn = &r_outp_actn;
				r_req.rx_ptr = _bcm_unpack_ds_outprofile_actn(r_req.rx_ptr, r_p_outp_actn);
			}
			if (*r_req.rx_ptr++ == 1) {
				r_p_nm_actn = NULL;
			} else {
				r_p_nm_actn = &r_nm_actn;
				r_req.rx_ptr = _bcm_unpack_ds_nomatch_actn(r_req.rx_ptr, r_p_nm_actn);
			}

			r_rv = cb(unit, r_dpid, r_cfid, r_p_clfr, r_p_inp_actn, r_p_outp_actn, r_p_nm_actn, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_field_group_traverse(
	int	unit,
	bcm_field_group_traverse_cb	callback,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xabd27cfb,0x948c6a65,0x086d4a58,0x4f1490e8,0x6e2aa45d };
	bcm_field_group_t	r_group;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_group);

			r_rv = callback(unit, r_group, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_ipfix_rate_traverse(
	int	unit,
	bcm_ipfix_rate_traverse_cb	cb,
	void *	userdata)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x46a4972e,0x92ec830b,0x9b8f6d89,0x04fc1820,0x272f503f };
	bcm_ipfix_rate_t	r_rate_info;
	bcm_ipfix_rate_t *	r_p_rate_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_rate_info = NULL;
			} else {
				r_p_rate_info = &r_rate_info;
				r_req.rx_ptr = _bcm_unpack_ipfix_rate(r_req.rx_ptr, r_p_rate_info);
			}

			r_rv = cb(unit, r_p_rate_info, userdata);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#ifdef	INCLUDE_L3

int
bcm_client_ipmc_traverse(
	int	unit,
	uint32	flags,
	bcm_ipmc_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xe6cd13ba,0x125638c6,0xbbe75b93,0x7e25925e,0x0d8b8c42 };
	bcm_ipmc_addr_t	r_info;
	bcm_ipmc_addr_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, flags);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_ipmc_addr(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#endif	/* INCLUDE_L3 */

int
bcm_client_l2_egress_traverse(
	int	unit,
	bcm_l2_egress_traverse_cb	trav_fn,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xb8c6c76d,0x66647c41,0xaaf33868,0x35da5d0a,0x53e675bb };
	bcm_l2_egress_t	r_egr;
	bcm_l2_egress_t *	r_p_egr;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_egr = NULL;
			} else {
				r_p_egr = &r_egr;
				r_req.rx_ptr = _bcm_unpack_l2_egress(r_req.rx_ptr, r_p_egr);
			}

			r_rv = trav_fn(unit, r_p_egr, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_l2_traverse(
	int	unit,
	bcm_l2_traverse_cb	trav_fn,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x60a22b31,0x6ec6ca4f,0xe1b0ce78,0xee3264b2,0x1e544bd4 };
	bcm_l2_addr_t	r_info;
	bcm_l2_addr_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_l2_addr(r_req.rx_ptr, r_p_info);
			}

			r_rv = trav_fn(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#ifdef	INCLUDE_L3

int
bcm_client_l3_egress_multipath_traverse(
	int	unit,
	bcm_l3_egress_multipath_traverse_cb	trav_fn,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	int	r_i;
	uint32	r_key[] = {
		0x22876dbb,0x559c93df,0x84dcc649,0x6d3fe0ae,0x14dbec70 };
	bcm_if_t	r_mpintf;
	int	r_intf_count;
	bcm_if_t *	r_p_intf_array;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			r_rv = BCM_E_NONE;
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_mpintf);
			BCM_UNPACK_U32(r_req.rx_ptr, r_intf_count);
			if (*r_req.rx_ptr++ == 1) {
				r_p_intf_array = NULL;
			} else {
				r_p_intf_array = sal_alloc(r_intf_count*sizeof(bcm_if_t), "traverse r_intf_array");
				if (r_p_intf_array == NULL) {
					r_rv = BCM_E_MEMORY;
				} else {
					for (r_i = 0; r_i < r_intf_count; r_i++) {
						BCM_UNPACK_U32(r_req.rx_ptr, *(r_p_intf_array+r_i));
					}
				}
			}

			if (BCM_SUCCESS(r_rv)) {
				r_rv = trav_fn(unit, r_mpintf, r_intf_count, r_p_intf_array, user_data);
			}

			if (r_p_intf_array != NULL) {
				sal_free(r_p_intf_array);
			}

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_l3_egress_traverse(
	int	unit,
	bcm_l3_egress_traverse_cb	trav_fn,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x5ab66d8d,0x122fdf0c,0x33bd285e,0x1f8c56ed,0x1ad886d3 };
	bcm_if_t	r_intf;
	bcm_l3_egress_t	r_info;
	bcm_l3_egress_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_intf);
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_l3_egress(r_req.rx_ptr, r_p_info);
			}

			r_rv = trav_fn(unit, r_intf, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_l3_host_traverse(
	int	unit,
	uint32	flags,
	uint32	start,
	uint32	end,
	bcm_l3_host_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x65fa4078,0x7c353975,0xc28647e2,0x1d35a278,0xcbaeef5d };
	int	r_index;
	bcm_l3_host_t	r_info;
	bcm_l3_host_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, flags);
		BCM_PACK_U32(r_req.tx_ptr, start);
		BCM_PACK_U32(r_req.tx_ptr, end);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_index);
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_l3_host(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_index, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_l3_ingress_traverse(
	int	unit,
	bcm_l3_ingress_traverse_cb	trav_fn,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x167de67a,0x4556a271,0xdc2c824a,0x9422f096,0x666e0a05 };
	bcm_if_t	r_intf_id;
	bcm_l3_ingress_t	r_ing_intf;
	bcm_l3_ingress_t *	r_p_ing_intf;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_intf_id);
			if (*r_req.rx_ptr++ == 1) {
				r_p_ing_intf = NULL;
			} else {
				r_p_ing_intf = &r_ing_intf;
				r_req.rx_ptr = _bcm_unpack_l3_ingress(r_req.rx_ptr, r_p_ing_intf);
			}

			r_rv = trav_fn(unit, r_intf_id, r_p_ing_intf, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_l3_route_traverse(
	int	unit,
	uint32	flags,
	uint32	start,
	uint32	end,
	bcm_l3_route_traverse_cb	trav_fn,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x3abb9ca2,0x9b9849d1,0x3fa6df34,0x889a975e,0xf18da8c9 };
	int	r_index;
	bcm_l3_route_t	r_info;
	bcm_l3_route_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, flags);
		BCM_PACK_U32(r_req.tx_ptr, start);
		BCM_PACK_U32(r_req.tx_ptr, end);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_index);
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_l3_route(r_req.rx_ptr, r_p_info);
			}

			r_rv = trav_fn(unit, r_index, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_l3_source_bind_traverse(
	int	unit,
	bcm_l3_source_bind_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xd2779d49,0xa91716ef,0xd4db8d97,0x5419c650,0xceaaa2c9 };
	bcm_l3_source_bind_t	r_info;
	bcm_l3_source_bind_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_l3_source_bind(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_mim_vpn_traverse(
	int	unit,
	bcm_mim_vpn_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x532bf474,0x5fc8a40c,0x05cfbef4,0x927b5787,0x09fc1173 };
	bcm_mim_vpn_config_t	r_info;
	bcm_mim_vpn_config_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_mim_vpn_config(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#endif	/* INCLUDE_L3 */

int
bcm_client_mirror_destination_traverse(
	int	unit,
	bcm_mirror_destination_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xdcd8d11e,0x2fee11c8,0xfdc6b378,0x9fefee8c,0x8980f333 };
	bcm_mirror_destination_t	r_mirror_dest;
	bcm_mirror_destination_t *	r_p_mirror_dest;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_mirror_dest = NULL;
			} else {
				r_p_mirror_dest = &r_mirror_dest;
				r_req.rx_ptr = _bcm_unpack_mirror_destination(r_req.rx_ptr, r_p_mirror_dest);
			}

			r_rv = cb(unit, r_p_mirror_dest, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#ifdef	INCLUDE_L3

int
bcm_client_mpls_switch_traverse(
	int	unit,
	uint32	flags,
	uint32	start,
	uint32	end,
	bcm_mpls_switch_traverse_cb	trav_fn,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xbb88839c,0x49966e8e,0xdfc60ec3,0xb5b9d1c7,0x44a0d8e9 };
	int	r_index;
	bcm_mpls_switch_t	r_info;
	bcm_mpls_switch_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, flags);
		BCM_PACK_U32(r_req.tx_ptr, start);
		BCM_PACK_U32(r_req.tx_ptr, end);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_index);
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_mpls_switch(r_req.rx_ptr, r_p_info);
			}

			r_rv = trav_fn(unit, r_index, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_mpls_tunnel_switch_traverse(
	int	unit,
	bcm_mpls_tunnel_switch_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xe78321d1,0x5f8959d3,0x6b5dc068,0x3bd16a35,0x8fa5673f };
	bcm_mpls_tunnel_switch_t	r_info;
	bcm_mpls_tunnel_switch_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_mpls_tunnel_switch(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_mpls_vpn_traverse(
	int	unit,
	bcm_mpls_vpn_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xa6b62e4d,0xf0357ad3,0x3eb5c1f8,0xc1112545,0xff607622 };
	bcm_mpls_vpn_config_t	r_info;
	bcm_mpls_vpn_config_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_mpls_vpn_config(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#endif	/* INCLUDE_L3 */

int
bcm_client_multicast_group_traverse(
	int	unit,
	bcm_multicast_group_traverse_cb_t	trav_fn,
	uint32	flags,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x609d585a,0x28d1d4b4,0x9dafcc73,0x0600d68f,0x56fdedd2 };
	bcm_multicast_t	r_group;
	uint32	r_flags;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, flags);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_group);
			BCM_UNPACK_U32(r_req.rx_ptr, r_flags);

			r_rv = trav_fn(unit, r_group, r_flags, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#ifdef	INCLUDE_L3

int
bcm_client_niv_forward_traverse(
	int	unit,
	bcm_niv_forward_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xdff5e37c,0x63f8f445,0x7eb5490d,0xae8f690c,0x87f6eec7 };
	bcm_niv_forward_t	r_iv_fwd_entry;
	bcm_niv_forward_t *	r_p_iv_fwd_entry;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_iv_fwd_entry = NULL;
			} else {
				r_p_iv_fwd_entry = &r_iv_fwd_entry;
				r_req.rx_ptr = _bcm_unpack_niv_forward(r_req.rx_ptr, r_p_iv_fwd_entry);
			}

			r_rv = cb(unit, r_p_iv_fwd_entry, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_niv_port_traverse(
	int	unit,
	bcm_niv_port_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xf576f989,0xe875babe,0xdc063963,0xedd55a31,0xd47ff86a };
	bcm_niv_port_t	r_niv_port;
	bcm_niv_port_t *	r_p_niv_port;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_niv_port = NULL;
			} else {
				r_p_niv_port = &r_niv_port;
				r_req.rx_ptr = _bcm_unpack_niv_port(r_req.rx_ptr, r_p_niv_port);
			}

			r_rv = cb(unit, r_p_niv_port, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#endif	/* INCLUDE_L3 */

int
bcm_client_oam_endpoint_traverse(
	int	unit,
	bcm_oam_group_t	group,
	bcm_oam_endpoint_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x84d3139b,0x63882899,0x779a64f2,0x780bebd5,0x7c6293da };
	bcm_oam_endpoint_info_t	r_endpoint_info;
	bcm_oam_endpoint_info_t *	r_p_endpoint_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, group);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_endpoint_info = NULL;
			} else {
				r_p_endpoint_info = &r_endpoint_info;
				r_req.rx_ptr = _bcm_unpack_oam_endpoint_info(r_req.rx_ptr, r_p_endpoint_info);
			}

			r_rv = cb(unit, r_p_endpoint_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_oam_group_traverse(
	int	unit,
	bcm_oam_group_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xc0d84a55,0xb28f41a5,0xa3f7be33,0x6c24dde9,0x98e0eccb };
	bcm_oam_group_info_t	r_group_info;
	bcm_oam_group_info_t *	r_p_group_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_group_info = NULL;
			} else {
				r_p_group_info = &r_group_info;
				r_req.rx_ptr = _bcm_unpack_oam_group_info(r_req.rx_ptr, r_p_group_info);
			}

			r_rv = cb(unit, r_p_group_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_policer_traverse(
	int	unit,
	bcm_policer_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xf1700d39,0x5240c888,0x4932cc67,0xdfa88306,0x7424edf3 };
	bcm_policer_t	r_policer_id;
	bcm_policer_config_t	r_info;
	bcm_policer_config_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_policer_id);
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_policer_config(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_policer_id, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_subport_port_traverse(
	int	unit,
	bcm_subport_port_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x36115c4e,0x15b39040,0xea52c661,0x326f8213,0x13b775b1 };
	bcm_gport_t	r_port;
	bcm_subport_config_t	r_config;
	bcm_subport_config_t *	r_p_config;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			if (*r_req.rx_ptr++ == 1) {
				r_p_config = NULL;
			} else {
				r_p_config = &r_config;
				r_req.rx_ptr = _bcm_unpack_subport_config(r_req.rx_ptr, r_p_config);
			}

			r_rv = cb(unit, r_port, r_p_config, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_time_interface_traverse(
	int	unit,
	bcm_time_interface_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xb7e7bce3,0xf36ec46a,0x4b1c9ac0,0x8c196613,0x6f327905 };
	bcm_time_interface_t	r_intf;
	bcm_time_interface_t *	r_p_intf;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_intf = NULL;
			} else {
				r_p_intf = &r_intf;
				r_req.rx_ptr = _bcm_unpack_time_interface(r_req.rx_ptr, r_p_intf);
			}

			r_rv = cb(unit, r_p_intf, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#ifdef	INCLUDE_L3

int
bcm_client_trill_multicast_source_traverse(
	int	unit,
	bcm_trill_multicast_source_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x08f576a7,0x7bddad71,0xdc08b493,0x2359ce15,0x9ba1b582 };
	bcm_trill_name_t	r_root_name;
	bcm_trill_name_t	r_source_rbridge_name;
	bcm_gport_t	r_port;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_root_name);
			BCM_UNPACK_U32(r_req.rx_ptr, r_source_rbridge_name);
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);

			r_rv = cb(unit, r_root_name, r_source_rbridge_name, r_port, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_trill_multicast_traverse(
	int	unit,
	bcm_trill_multicast_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xd132870c,0x2cb0ac3a,0xb0e3a10f,0x00a87405,0x0b496785 };
	bcm_trill_name_t	r_root_name;
	bcm_vlan_t	r_vlan;
	bcm_mac_t	r_c_dmac;
	bcm_multicast_t	r_group;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_root_name);
			BCM_UNPACK_U16(r_req.rx_ptr, r_vlan);
			r_req.rx_ptr = _bcm_unpack_mac(r_req.rx_ptr, r_c_dmac);
			BCM_UNPACK_U32(r_req.rx_ptr, r_group);

			r_rv = cb(unit, r_root_name, r_vlan, r_c_dmac, r_group, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#endif	/* INCLUDE_L3 */

int
bcm_client_trunk_member_traverse(
	int	unit,
	bcm_trunk_t	tid,
	bcm_trunk_member_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xb0bc0e72,0x9bb89000,0xf00cb06a,0x4b5a2499,0xbf3bc57b };
	bcm_trunk_member_t	r_member;
	bcm_trunk_member_t *	r_p_member;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */
		BCM_PACK_U32(r_req.tx_ptr, tid);

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_member = NULL;
			} else {
				r_p_member = &r_member;
				r_req.rx_ptr = _bcm_unpack_trunk_member(r_req.rx_ptr, r_p_member);
			}

			r_rv = cb(unit, r_p_member, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_cross_connect_traverse(
	int	unit,
	bcm_vlan_cross_connect_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x9b81a1e3,0x30e13ed8,0x2c88e0b6,0x806061d6,0x2d25b128 };
	bcm_vlan_t	r_outer_vlan;
	bcm_vlan_t	r_inner_vlan;
	bcm_gport_t	r_port_1;
	bcm_gport_t	r_port_2;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U16(r_req.rx_ptr, r_outer_vlan);
			BCM_UNPACK_U16(r_req.rx_ptr, r_inner_vlan);
			BCM_UNPACK_U32(r_req.rx_ptr, r_port_1);
			BCM_UNPACK_U32(r_req.rx_ptr, r_port_2);

			r_rv = cb(unit, r_outer_vlan, r_inner_vlan, r_port_1, r_port_2, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_dtag_range_traverse(
	int	unit,
	bcm_vlan_dtag_range_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xecace45d,0x604f598a,0x2bd096c2,0x08717feb,0x18c78766 };
	bcm_gport_t	r_port;
	bcm_vlan_t	r_old_vlan_low;
	bcm_vlan_t	r_old_vlan_high;
	bcm_vlan_t	r_new_vlan;
	int	r_prio;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U16(r_req.rx_ptr, r_old_vlan_low);
			BCM_UNPACK_U16(r_req.rx_ptr, r_old_vlan_high);
			BCM_UNPACK_U16(r_req.rx_ptr, r_new_vlan);
			BCM_UNPACK_U32(r_req.rx_ptr, r_prio);

			r_rv = cb(unit, r_port, r_old_vlan_low, r_old_vlan_high, r_new_vlan, r_prio, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_dtag_traverse(
	int	unit,
	bcm_vlan_dtag_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x9463324c,0x9c4abd42,0xd58d3258,0x97c563e2,0xb4754ba3 };
	bcm_gport_t	r_port;
	bcm_vlan_t	r_old_vlan;
	bcm_vlan_t	r_new_vlan;
	int	r_prio;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U16(r_req.rx_ptr, r_old_vlan);
			BCM_UNPACK_U16(r_req.rx_ptr, r_new_vlan);
			BCM_UNPACK_U32(r_req.rx_ptr, r_prio);

			r_rv = cb(unit, r_port, r_old_vlan, r_new_vlan, r_prio, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_ip_action_traverse(
	int	unit,
	bcm_vlan_ip_action_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xefbb89d5,0x4a559662,0xde80ed51,0x4c007b8f,0x0974bb66 };
	bcm_vlan_ip_t	r_vlan_ip;
	bcm_vlan_action_set_t	r_action;
	bcm_vlan_ip_t *	r_p_vlan_ip;
	bcm_vlan_action_set_t *	r_p_action;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_vlan_ip = NULL;
			} else {
				r_p_vlan_ip = &r_vlan_ip;
				r_req.rx_ptr = _bcm_unpack_vlan_ip(r_req.rx_ptr, r_p_vlan_ip);
			}
			if (*r_req.rx_ptr++ == 1) {
				r_p_action = NULL;
			} else {
				r_p_action = &r_action;
				r_req.rx_ptr = _bcm_unpack_vlan_action_set(r_req.rx_ptr, r_p_action);
			}

			r_rv = cb(unit, r_p_vlan_ip, r_p_action, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_mac_action_traverse(
	int	unit,
	bcm_vlan_mac_action_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xa3ed9bb5,0x865fc75a,0xa70b17e5,0x985c5995,0x70c760f8 };
	bcm_mac_t	r_mac;
	bcm_vlan_action_set_t	r_action;
	bcm_vlan_action_set_t *	r_p_action;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			r_req.rx_ptr = _bcm_unpack_mac(r_req.rx_ptr, r_mac);
			if (*r_req.rx_ptr++ == 1) {
				r_p_action = NULL;
			} else {
				r_p_action = &r_action;
				r_req.rx_ptr = _bcm_unpack_vlan_action_set(r_req.rx_ptr, r_p_action);
			}

			r_rv = cb(unit, r_mac, r_p_action, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_port_protocol_action_traverse(
	int	unit,
	bcm_vlan_port_protocol_action_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x05e54e9f,0xdb836cfa,0xe46d5689,0x89bcfb19,0xff0ee886 };
	bcm_port_t	r_port;
	bcm_port_frametype_t	r_frame;
	bcm_port_ethertype_t	r_ether;
	bcm_vlan_action_set_t	r_action;
	bcm_vlan_action_set_t *	r_p_action;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U32(r_req.rx_ptr, r_frame);
			BCM_UNPACK_U16(r_req.rx_ptr, r_ether);
			if (*r_req.rx_ptr++ == 1) {
				r_p_action = NULL;
			} else {
				r_p_action = &r_action;
				r_req.rx_ptr = _bcm_unpack_vlan_action_set(r_req.rx_ptr, r_p_action);
			}

			r_rv = cb(unit, r_port, r_frame, r_ether, r_p_action, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_translate_action_range_traverse(
	int	unit,
	bcm_vlan_translate_action_range_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x31fa6e34,0xacb376f6,0xc54b4087,0xf40b84c4,0x11d6c6d8 };
	bcm_gport_t	r_port;
	bcm_vlan_t	r_outer_vlan_low;
	bcm_vlan_t	r_outer_vlan_high;
	bcm_vlan_t	r_inner_vlan_low;
	bcm_vlan_t	r_inner_vlan_high;
	bcm_vlan_action_set_t	r_action;
	bcm_vlan_action_set_t *	r_p_action;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U16(r_req.rx_ptr, r_outer_vlan_low);
			BCM_UNPACK_U16(r_req.rx_ptr, r_outer_vlan_high);
			BCM_UNPACK_U16(r_req.rx_ptr, r_inner_vlan_low);
			BCM_UNPACK_U16(r_req.rx_ptr, r_inner_vlan_high);
			if (*r_req.rx_ptr++ == 1) {
				r_p_action = NULL;
			} else {
				r_p_action = &r_action;
				r_req.rx_ptr = _bcm_unpack_vlan_action_set(r_req.rx_ptr, r_p_action);
			}

			r_rv = cb(unit, r_port, r_outer_vlan_low, r_outer_vlan_high, r_inner_vlan_low, r_inner_vlan_high, r_p_action, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_translate_action_traverse(
	int	unit,
	bcm_vlan_translate_action_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x6994f48d,0x4364f04f,0x0c31cf30,0x5487894a,0xccc734a1 };
	bcm_gport_t	r_port;
	bcm_vlan_translate_key_t	r_key_type;
	bcm_vlan_t	r_outer_vlan;
	bcm_vlan_t	r_inner_vlan;
	bcm_vlan_action_set_t	r_action;
	bcm_vlan_action_set_t *	r_p_action;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U32(r_req.rx_ptr, r_key_type);
			BCM_UNPACK_U16(r_req.rx_ptr, r_outer_vlan);
			BCM_UNPACK_U16(r_req.rx_ptr, r_inner_vlan);
			if (*r_req.rx_ptr++ == 1) {
				r_p_action = NULL;
			} else {
				r_p_action = &r_action;
				r_req.rx_ptr = _bcm_unpack_vlan_action_set(r_req.rx_ptr, r_p_action);
			}

			r_rv = cb(unit, r_port, r_key_type, r_outer_vlan, r_inner_vlan, r_p_action, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_translate_egress_action_traverse(
	int	unit,
	bcm_vlan_translate_egress_action_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xc13ddf2f,0xfb47b82d,0x4cda9795,0xc016496d,0xd6ec48fd };
	int	r_port_class;
	bcm_vlan_t	r_outer_vlan;
	bcm_vlan_t	r_inner_vlan;
	bcm_vlan_action_set_t	r_action;
	bcm_vlan_action_set_t *	r_p_action;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port_class);
			BCM_UNPACK_U16(r_req.rx_ptr, r_outer_vlan);
			BCM_UNPACK_U16(r_req.rx_ptr, r_inner_vlan);
			if (*r_req.rx_ptr++ == 1) {
				r_p_action = NULL;
			} else {
				r_p_action = &r_action;
				r_req.rx_ptr = _bcm_unpack_vlan_action_set(r_req.rx_ptr, r_p_action);
			}

			r_rv = cb(unit, r_port_class, r_outer_vlan, r_inner_vlan, r_p_action, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_translate_egress_traverse(
	int	unit,
	bcm_vlan_translate_egress_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x2d222e96,0x2f3ca059,0x8b18e874,0xa3c14190,0xf4512a5b };
	bcm_gport_t	r_port;
	bcm_vlan_t	r_old_vlan;
	bcm_vlan_t	r_new_vlan;
	int	r_prio;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U16(r_req.rx_ptr, r_old_vlan);
			BCM_UNPACK_U16(r_req.rx_ptr, r_new_vlan);
			BCM_UNPACK_U32(r_req.rx_ptr, r_prio);

			r_rv = cb(unit, r_port, r_old_vlan, r_new_vlan, r_prio, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_translate_range_traverse(
	int	unit,
	bcm_vlan_translate_range_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x1fc89dd9,0xc16c9083,0x4aeb7b35,0x1b8d0c83,0x4f104003 };
	bcm_gport_t	r_port;
	bcm_vlan_t	r_old_vlan_low;
	bcm_vlan_t	r_old_vlan_high;
	bcm_vlan_t	r_new_vlan;
	int	r_prio;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U16(r_req.rx_ptr, r_old_vlan_low);
			BCM_UNPACK_U16(r_req.rx_ptr, r_old_vlan_high);
			BCM_UNPACK_U16(r_req.rx_ptr, r_new_vlan);
			BCM_UNPACK_U32(r_req.rx_ptr, r_prio);

			r_rv = cb(unit, r_port, r_old_vlan_low, r_old_vlan_high, r_new_vlan, r_prio, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_vlan_translate_traverse(
	int	unit,
	bcm_vlan_translate_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0x0640d32f,0x4f1e5c31,0xcdf1e172,0xae1e6445,0x9ce22c65 };
	bcm_gport_t	r_port;
	bcm_vlan_t	r_old_vlan;
	bcm_vlan_t	r_new_vlan;
	int	r_prio;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			BCM_UNPACK_U32(r_req.rx_ptr, r_port);
			BCM_UNPACK_U16(r_req.rx_ptr, r_old_vlan);
			BCM_UNPACK_U16(r_req.rx_ptr, r_new_vlan);
			BCM_UNPACK_U32(r_req.rx_ptr, r_prio);

			r_rv = cb(unit, r_port, r_old_vlan, r_new_vlan, r_prio, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#ifdef	INCLUDE_L3

int
bcm_client_wlan_client_traverse(
	int	unit,
	bcm_wlan_client_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xa128eb0b,0xefa0c614,0x0584f855,0xfe95099e,0x95ad77ea };
	bcm_wlan_client_t	r_info;
	bcm_wlan_client_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_wlan_client(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

int
bcm_client_wlan_port_traverse(
	int	unit,
	bcm_wlan_port_traverse_cb	cb,
	void *	user_data)
{
	bcm_rlink_traverse_data_t	r_req;
	int	r_rv;
	uint32	r_key[] = {
		0xc5c947cb,0xcb5fa2e9,0x62b91776,0x5327848f,0x5208fc54 };
	bcm_wlan_port_t	r_info;
	bcm_wlan_port_t *	r_p_info;

	sal_memset(&r_req, 0, sizeof(r_req));
	r_rv = bcm_rlink_traverse_request_start(unit, &r_req, r_key);
	if (BCM_SUCCESS(r_rv)) {
		/* Pack request */
		/* Skip unit */

		while (bcm_rlink_traverse_reply_get(unit, &r_req)) {
			/* Unpack reply */
			/* Skip unit */
			if (*r_req.rx_ptr++ == 1) {
				r_p_info = NULL;
			} else {
				r_p_info = &r_info;
				r_req.rx_ptr = _bcm_unpack_wlan_port(r_req.rx_ptr, r_p_info);
			}

			r_rv = cb(unit, r_p_info, user_data);

			if (BCM_FAILURE(r_rv)) {
				break;
			}
		}
		r_rv = bcm_rlink_traverse_request_done(unit, r_rv, &r_req);
	}

	return r_rv;
}

#endif	/* INCLUDE_L3 */

#endif	/* BCM_RPC_SUPPORT */
