/*
 * $Id: trident2.c,v 1.298 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:        trident2.c
 * Purpose:
 * Requires:
 */
#include <shared/bsl.h>
#include <sal/core/boot.h>
#include <soc/trident2.h>
#include <soc/bradley.h>
#include <soc/drv.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/mspi.h>
#include <soc/l2x.h>
#include <soc/soc_ser_log.h>
#include <soc/tdm/core/tdm_top.h>

#ifdef BCM_TRIDENT2_SUPPORT
#include <soc/td2_td2p.h>

#ifdef ALPM_ENABLE
#include <soc/lpm.h>
#include <soc/alpm.h>
#include <soc/esw/alpm_int.h>
#endif /* ALPM_ENABLE */

#include <soc/mmu_config.h>
#include <soc/trident2.h>
#include <soc/post.h>

#define TDM_CHIP_EXEC__IARB_TD2 11
#define TDM_CHIP_EXEC__IARB_TD2P 12
#include <soc/esw/portctrl.h>

#ifdef PORTMOD_SUPPORT
#include <soc/portmod/portmod.h>
#endif /* PORTMOD_SUPPORT */

#define _TD2_PORTS_PER_XLP         4
#define _TD2_XLPS_PER_PGW          4
#define _TD2_PGWS_PER_QUAD         2
#define _TD2_QUADS_PER_PIPE        2
#define _TD2_PIPES_PER_DEV         2

#define _TD2_QUADS_PER_DEV         (_TD2_QUADS_PER_PIPE * _TD2_PIPES_PER_DEV)

#define _TD2_PGWS_PER_PIPE         (_TD2_PGWS_PER_QUAD * _TD2_QUADS_PER_PIPE)
#define _TD2_PGWS_PER_DEV          (_TD2_PGWS_PER_PIPE * _TD2_PIPES_PER_DEV)

#define _TD2_PORTS_PER_PGW         (_TD2_PORTS_PER_XLP * _TD2_XLPS_PER_PGW)
#define _TD2_PORTS_PER_QUAD        (_TD2_PORTS_PER_PGW * _TD2_PGWS_PER_QUAD)
#define _TD2_PORTS_PER_PIPE        (_TD2_PORTS_PER_QUAD * _TD2_QUADS_PER_PIPE) 

#define _TD2_BYTES_PER_OBM_CELL    16

#define _TD2_LOG_PORTS_PER_PIPE    53
#define _TD2_MMU_PORTS_PER_PIPE    53
#define _SOC_TD2_MAX_PORT          (_TD2_LOG_PORTS_PER_PIPE * \
                                    _TD2_PIPES_PER_DEV)

#define _TD2_MMU_PACKET_HEADER_BYTES    64    /* bytes */
#define _TD2_MMU_JUMBO_FRAME_BYTES      9216  /* bytes */
#define _TD2_MMU_DEFAULT_MTU_BYTES      1536  /* bytes */

#define _TD2_MMU_BYTES_PER_CELL      208   /* bytes (1664 bits) */
#define _TD2_MMU_NUM_PG              8
#define _TD2_MMU_NUM_POOL            4

#define SOC_TD2_MMU_CFG_QGROUP_MAX   128

#define SOC_TD2_MMU_RQE_TOTAL_RSVD_ENTRY    88
#define SOC_TD2_MMU_MCQ_ENTRY        49152
#define SOC_TD2_MMU_RQE_ENTRY        4096

#define _TD2_MMU_TOTAL_MCQ_ENTRY(unit)  SOC_TD2_MMU_MCQ_ENTRY

#define _TD2_MMU_TOTAL_RQE_ENTRY(unit)  SOC_TD2_MMU_RQE_ENTRY

#define _TD2_MMU_PORT_CREDIT_100G (SOC_IS_TRIDENT2PLUS(unit) ? 96 : 144)
#define _TD2_MMU_PORT_CREDIT_40G  48
#define _TD2_MMU_PORT_CREDIT_20G  24
#define _TD2_MMU_PORT_CREDIT_10G  12

#define _TD2_MMU_PORT_CREDIT(speed) _TD2_MMU_PORT_CREDIT_##speed

#define _TD2_MMU_ASF_CREDIT_THRESH_LO_100G (SOC_IS_TRIDENT2PLUS(unit) ? 30 : 64)
#define _TD2_MMU_ASF_CREDIT_THRESH_HI_100G (SOC_IS_TRIDENT2PLUS(unit) ? 72 : 108)
#define _TD2_MMU_ASF_CREDIT_THRESH_LO_40G  18
#define _TD2_MMU_ASF_CREDIT_THRESH_HI_40G  36
#define _TD2_MMU_ASF_CREDIT_THRESH_LO_20G  8
#define _TD2_MMU_ASF_CREDIT_THRESH_HI_20G  18
#define _TD2_MMU_ASF_CREDIT_THRESH_LO_10G  4
#define _TD2_MMU_ASF_CREDIT_THRESH_HI_10G  9

#define _TD2_MMU_ASF_CREDIT_THRESH(param, speed) _TD2_MMU_ASF_CREDIT_THRESH_##param##_##speed

#define _TD2_MMU_ASF_FIFO_THRESHOLD 3
#define _TD2_MMU_ASF_HS_FIFO_THRESHOLD (SOC_IS_TRIDENT2PLUS(unit) ? 12 : 13)

#define _TD2_TD2_MMU_XMIT_START_CNT_OVERSUB (si->frequency >= 608 ? 9 :\
                                            (si->frequency >= 500 ? 11 : 12))

#define _TD2P_TD2_MMU_XMIT_START_CNT_OVERSUB ((si->frequency >= 760 ? 11 :\
                                             (si->frequency >= 608 ? 12 : \
                                             (si->frequency >= 500 ? 14 : 15))))

#define XMIT_START_CNT_OVERSUB(param)\
    ((SOC_IS_TRIDENT2PLUS(unit))? _TD2P##param : _TD2##param)

#define _TD2_MMU_XMIT_START_CNT_OVERSUB XMIT_START_CNT_OVERSUB(_TD2_MMU_XMIT_START_CNT_OVERSUB)


#define _TD2_TD2_MMU_XMIT_START_CNT_LINERATE(speed) \
        (speed > 42000 ? 3 : ((si->frequency <= 415) && (speed > 11000) ? 8 : 7))

#define _TD2P_TD2_MMU_XMIT_START_CNT_LINERATE(speed) \
        (speed > 42000 ? 10 : ((si->frequency <= 415) && (speed > 21000) ? 8 : 7))

#define XMIT_START_CNT_LINERATE(param,speed)\
    ((SOC_IS_TRIDENT2PLUS(unit))? _TD2P##param(speed) : _TD2##param(speed))

#define _TD2_MMU_XMIT_START_CNT_LINERATE(speed) XMIT_START_CNT_LINERATE(_TD2_MMU_XMIT_START_CNT_LINERATE, speed)

#define _SOC_TD2_DEFIP_MAX_TCAMS   8
#define _SOC_TD2_DEFIP_TCAM_DEPTH 1024

#define SOC_FIELD_RANGE_CHECK(val, min, max) \
    (((val) > (min)) && ((val) <= (max)))

#define _SOC_TD2_MAX_INTERNAL_PRIORITY 15
#define _SOC_TD2_MAX_PRIORITY           7

typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_GENERIC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_CPORT,
    _SOC_PARITY_TYPE_MMU_SER,
    _SOC_PARITY_TYPE_START_ERR,
    _SOC_PARITY_TYPE_SER,
    _SOC_PARITY_TYPE_BST
} _soc_td2_ser_info_type_t;

typedef struct _soc_td2_fifo_ser_info_s {
    soc_reg_t   enable_reg;
    soc_field_t enable_field;
    uint8       type; /* 0: mem, 1: reg, 2: bus */
    soc_mem_t   mem;
    soc_reg_t   reg;
    char        *name_str; /* Used when mem == INVALIDm or reg == INVALIDr or type == bus
                              (either not accessible or multiple) */
} _soc_td2_fifo_ser_info_t;

typedef struct _soc_td2_ser_block_info_s {
    soc_block_t              blocktype;
    soc_reg_t                fifo_reset_reg;
    _soc_td2_fifo_ser_info_t *info;
} _soc_td2_ser_block_info_t;

typedef struct _soc_td2_ser_reg_s {
    soc_reg_t reg;
    char      *mem_str;
} _soc_td2_ser_reg_t;

typedef struct _soc_td2_ser_info_s {
    _soc_td2_ser_info_type_t   type;
    struct _soc_td2_ser_info_s *info;
    int                        id;
    soc_field_t                group_reg_enable_field;
    soc_field_t                group_reg_status_field;
    soc_mem_t                  mem;
    char                       *mem_str;
    soc_reg_t                  enable_reg;
    soc_field_t                enable_field;
    soc_reg_t                  intr_status_reg;
    _soc_td2_ser_reg_t         *intr_status_reg_list;
} _soc_td2_ser_info_t;

typedef struct _soc_td2_ser_route_block_s {
    uint32              cmic_bit;
    soc_block_t         blocktype;
    int                 pipe;
    soc_reg_t           enable_reg;
    soc_reg_t           status_reg;
    soc_field_t         enable_field;
    _soc_td2_ser_info_t *info;
    uint8               id;
} _soc_td2_ser_route_block_t;

typedef struct _soc_td2_mmu_traffic_ctrl_s {
    uint8   thdo_drop_bmp[_SOC_TD2_MAX_PORT];
} _soc_td2_mmu_traffic_ctrl_t;


#define   MAC_ENABLE_SET_CTRL          (1 << 0)
#define   MMU_TRAFFIC_EN_CTRL          (1 << 1)
#define   COSQ_SCHED_SET_CTRL          (1 << 2) 
static    _soc_td2_mmu_traffic_ctrl_t
              *_soc_td2_mmu_traffic_ctrl[SOC_MAX_NUM_DEVICES];
static    sal_mutex_t _fwd_ctrl_lock[SOC_MAX_NUM_DEVICES];
#define   FWD_CTRL_LOCK(unit) \
          sal_mutex_take(_fwd_ctrl_lock[unit], sal_mutex_FOREVER)
#define   FWD_CTRL_UNLOCK(unit) \
          sal_mutex_give(_fwd_ctrl_lock[unit])

/* Forward declarations */
extern int
tdm_td2_set_iarb_tdm_table(int core_bw, int is_x_ovs, int is_y_ovs, int mgm4x1,
int mgm4x2p5, int mgm1x10, int *iarb_tdm_wrap_ptr_x, int *iarb_tdm_wrap_ptr_y,
int *iarb_tdm_tbl_x, int *iarb_tdm_tbl_y);

enum tdm_td2_port_speed {TDM_TD2_SPEED_0=0, TDM_TD2_SPEED_10M=10, TDM_TD2_SPEED_20M=20,
TDM_TD2_SPEED_25M=25, TDM_TD2_SPEED_33M=33, TDM_TD2_SPEED_40M=40, TDM_TD2_SPEED_50M=50,
TDM_TD2_SPEED_100M=100, TDM_TD2_SPEED_100M_FX=101, TDM_TD2_SPEED_120M=120,TDM_TD2_SPEED_400M=400,
TDM_TD2_SPEED_1G=1000, TDM_TD2_SPEED_1G_FX=1001, TDM_TD2_SPEED_1p2G=1200, TDM_TD2_SPEED_2G=2000,
TDM_TD2_SPEED_2p5G=2500, TDM_TD2_SPEED_4G=4000, TDM_TD2_SPEED_5G=5000, TDM_TD2_SPEED_7p5G=7500,
TDM_TD2_SPEED_10G=10000, TDM_TD2_SPEED_10G_DUAL=10001, TDM_TD2_SPEED_10G_XAUI=10002,
TDM_TD2_SPEED_12G=12000, TDM_TD2_SPEED_12p5G=12500, TDM_TD2_SPEED_13G=13000, TDM_TD2_SPEED_15G=15000,
TDM_TD2_SPEED_16G=16000, TDM_TD2_SPEED_20G=20000, TDM_TD2_SPEED_21G=21000, TDM_TD2_SPEED_21G_DUAL=21010,
TDM_TD2_SPEED_24G=24000, TDM_TD2_SPEED_25G=25000, TDM_TD2_SPEED_30G=30000, TDM_TD2_SPEED_40G=40000,
TDM_TD2_SPEED_42G=40005, TDM_TD2_SPEED_50G=50000,TDM_TD2_SPEED_75G=75000, TDM_TD2_SPEED_82G=82000,
TDM_TD2_SPEED_100G=100000, TDM_TD2_SPEED_120G=120000, TDM_TD2_SPEED_126G=126000};

#define TDM_TD2_NUM_EXT_PORTS 130

extern int
_soc_td2_set_tdm_tbl(enum tdm_td2_port_speed speed[TDM_TD2_NUM_EXT_PORTS],
int tdm_bw, int pgw_tdm_tbl_x0[32], int ovs_tdm_tbl_x0[32], int ovs_spacing_x0[32],
int pgw_tdm_tbl_x1[32], int ovs_tdm_tbl_x1[32], int ovs_spacing_x1[32],
int pgw_tdm_tbl_y0[32], int ovs_tdm_tbl_y0[32], int ovs_spacing_y0[32],
int pgw_tdm_tbl_y1[32], int ovs_tdm_tbl_y1[32], int ovs_spacing_y1[32],
int mmu_tdm_tbl_x[256], int mmu_tdm_ovs_x_1[16], int mmu_tdm_ovs_x_2[16],
int mmu_tdm_ovs_x_3[16], int mmu_tdm_ovs_x_4[16], int mmu_tdm_tbl_y[256],
int mmu_tdm_ovs_y_1[16], int mmu_tdm_ovs_y_2[16], int mmu_tdm_ovs_y_3[16],
int mmu_tdm_ovs_y_4[16], int port_state_map[128], int iarb_tdm_tbl_x[512],
int iarb_tdm_tbl_y[512]);

STATIC int
_soc_trident2_mdio_reg_read(int unit, uint32 phy_addr,
                            uint32 phy_reg, uint32 *phy_data);
STATIC int
_soc_trident2_mdio_reg_write(int unit, uint32 phy_addr,
                             uint32 phy_reg, uint32 phy_data);

STATIC void
_soc_trident2_ser_control_reg_get(CONST _soc_td2_fifo_ser_info_t *fifo_ser_list,
                                soc_mem_t   mem,
                                soc_reg_t   *ser_control_reg,
                                soc_field_t *ser_enable_field);
STATIC int
_soc_trident2_get_prio_map(int unit, int port, uint16 *pri_mask);


STATIC
_soc_td2_fifo_ser_info_t _soc_td2_ep_ser_info[] = {
    { EFP_PARITY_CONTROLr, EFP_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EFP BUS" },
    { EFP_PARITY_CONTROLr, PW_INIT_COUNTERS_PARITY_ENf, 0, EGR_PW_INIT_COUNTERSm, INVALIDr, "" },
    { EFP_PARITY_CONTROLr, METER_PARITY_ENf, 0, EFP_METER_TABLEm, INVALIDr, "" },
    { EFP_PARITY_CONTROLr, POLICY_PARITY_ENf, 0, EFP_POLICY_TABLEm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP15_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP15 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP14_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP14 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP13_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP13 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP12_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP12 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP11_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP11 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP10_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP10 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP9_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP9 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP8_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP8 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP7_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP7 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP6_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP6 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP5_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP5 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP4_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP4 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP3 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP2 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP1 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP0 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP3 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP2 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP1 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP0 CELL DATABUF" },
    /*{ EGR_EDATABUF_PARITY_CONTROLr, XLP_RESI_BUFFER_PAR_ENf, 0, INVALIDm, INVALIDr, "EP RESIDUE BUF" },*/
    { EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CM" },
    { EGR_EDATABUF_PARITY_CONTROLr, FCOE_DELIMITER_ERR_CNTR_PAR_ENf, 1, INVALIDm, EGR_FCOE_DELIMITER_ERROR_FRAMESr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, FCOE_INVALID_CNTR_PAR_ENf, 1, INVALIDm, EGR_FCOE_INVALID_CRC_FRAMESr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, PERQ_PAR_ENf, 0, EGR_PERQ_XMT_COUNTERSm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, EFPCTR_PAR_ENf, 0, EFP_COUNTER_TABLEm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, STATS_PAR_ENf, 0, INVALIDm, INVALIDr, "TX DEBUG COUNTER" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP15_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP15 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP14_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP14 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP13_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP13 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP12_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP12 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP11_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP11 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP10_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP10 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP9_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP9 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP8_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP8 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP7_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP7 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP6_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP6 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP5_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP5 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP4_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP4 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP3 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP2 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP1 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP0 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP3 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP2 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP1 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP0 DATABUF CONTROL INFO" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_0m, INVALIDr, "" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_1m, INVALIDr, "" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_2m, INVALIDr, "" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_3m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_0m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_1m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_2m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_3m, INVALIDr, "" },
    { EGR_EFPPARS_PARITY_CONTROLr, EGR_1588_LINK_DELAY_PARITY_ENf, 1, INVALIDm, EGR_1588_LINK_DELAY_64r, "" },
    { EGR_EFPPARS_PARITY_CONTROLr, EGR_1588_SA_PARITY_ENf, 0, EGR_1588_SAm, INVALIDr, "" },
    { EGR_EFPPARS_SER_CONTROLr, EFPPARS_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EFPPARS BUS" },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, SF_SRC_MODID_CHECK_PARITY_ENf, 1, INVALIDm, EGR_SF_SRC_MODID_CHECKr, "" },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, MOD_MAP_PARITY_ENf, 0, EGR_MOD_MAP_TABLEm, INVALIDr, "" },
    { EGR_EHCPM_SER_CONTROLr, EHCPM_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EHCPM BUS" },
    { EGR_EL3_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf, 0, INVALIDm, INVALIDr, "INIT BUFF" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_NAT_PACKET_EDIT_INFO_PARITY_ENf, 0, EGR_NAT_PACKET_EDIT_INFOm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAP_MH_PARITY_ENf, 0, EGR_MAP_MHm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPB_ECC_ENf, 0, INVALIDm, INVALIDr, "EGR MPB" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_PORT_PARITY_ENf, 0, EGR_PORTm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_IPMC_PARITY_ENf, 0, EGR_IPMCm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_VFI_PARITY_ENf, 0, EGR_VFIm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_DVP_ATTRIBUTE_PARITY_ENf, 0, EGR_DVP_ATTRIBUTEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAC_DA_PROFILE_PARITY_ENf, 0, EGR_MAC_DA_PROFILEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf, 0, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_INTF_PARITY_ENf, 0, EGR_L3_INTFm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_NEXT_HOP_PARITY_ENf, 0, EGR_L3_NEXT_HOPm, INVALIDr, "" },
    { EGR_EPMOD_SER_CONTROLr, EPMOD_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EPMOD BUS" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_XLATE_PARITY_EN_LPf, 0, EGR_VLAN_XLATE_LPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EVLAN_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EVLAN BUS" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_TAG_ACTION_PROFILE_PARITY_ENf, 0, EGR_VLAN_TAG_ACTION_PROFILEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_ETAG_PCP_MAPPING_PARITY_ENf, 0, EGR_ETAG_PCP_MAPPINGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_CONTROL_3_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_3r, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_CONTROL_2_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_2r, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_PVLAN_EPORT_CONTROL_PARITY_ENf, 1, INVALIDm, EGR_PVLAN_EPORT_CONTROLr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VP_VLAN_MEMBERSHIP_PARITY_ENf, 0, EGR_VP_VLAN_MEMBERSHIPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VPLAG_MEMBER_PARITY_ENf, 0, EGR_VPLAG_MEMBERm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VPLAG_GROUP_PARITY_ENf, 0, EGR_VPLAG_GROUPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_1_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_1m, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_PARITY_ENf, 0, EGR_GPP_ATTRIBUTESm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_MODBASE_PARITY_ENf, 0, EGR_GPP_ATTRIBUTES_MODBASEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_FRAGMENT_ID_TABLE_PARITY_ENf, 0, EGR_FRAGMENT_ID_TABLEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_DSCP_TABLE_PARITY_ENf, 0, EGR_DSCP_TABLEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_PRI_CNG_MAP_PARITY_ENf, 0, EGR_PRI_CNG_MAPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_PRI_MAPPING_PARITY_ENf, 0, EGR_MPLS_PRI_MAPPINGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_2_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_2m, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf, 0, EGR_IP_TUNNELm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_XLATE_PARITY_ENf, 0, EGR_VLAN_XLATEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_STG_PARITY_ENf, 0, EGR_VLAN_STGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_PARITY_ENf, 0, EGR_VLANm, INVALIDr, "" },
    { INVALIDr }
};

STATIC
_soc_td2_fifo_ser_info_t _soc_td2_ip_ser_info[] = {
    { CFG_SER_CONTROLr, PORT_TABLE_ECC_ENf, 0, PORT_TABm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SYSTEM_CONFIG_TABLE_PAR_ENf, 0, SYSTEM_CONFIG_TABLEm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SYSTEM_CONFIG_TABLE_MODBASE_PAR_ENf, 0, SYSTEM_CONFIG_TABLE_MODBASEm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SOURCE_TRUNK_MAP_MODBASE_PAR_ENf, 0, SOURCE_TRUNK_MAP_MODBASEm, INVALIDr, "" },
    /* NOTE: Read does not get the correct value for this reg */
    { DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf, 0, DLB_HGT_FLOWSET_TIMESTAMP_PAGEm, INVALIDr, "" }, 
    { DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_PARITY_ENf, 0, DLB_HGT_FLOWSETm, INVALIDr, "" },
    { IARB_SER_CONTROLr, LEARN_FIFO_ECC_ENf, 0, INVALIDm, INVALIDr, "IARB LEARN FIFO" },
    { IARB_SER_CONTROLr, CMIC_BUF_ECC_ENf, 0, INVALIDm, INVALIDr, "CMIC BUFFER" },
    { IFP_PARITY_CONTROLr, IFP_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IFP BUS" },
    /*{ IFP_PARITY_CONTROLr, COUNTER_MUX_DATA_STAGING_PARITY_ENf, 0, INVALIDm, INVALIDr, "COUNTER MUX DATA STAGING" }, HOW TO CLEAR */
    /*{ IFP_PARITY_CONTROLr, METER_MUX_DATA_STAGING_PARITY_ENf, 0, INVALIDm, INVALIDr, "METER MUX DATA STAGING" }, HOW TO CLEAR */
    { IFP_PARITY_CONTROLr, PORT_METER_MAP_PARITY_ENf, 0, FP_PORT_METER_MAPm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, ING_DVP_2_PARITY_ENf, 0, ING_DVP_2_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, STORM_PARITY_ENf, 0, FP_STORM_CONTROL_METERSm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, COUNTER_PARITY_ENf, 0, FP_COUNTER_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, METER_PARITY_ENf, 0, FP_METER_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, POLICY_PARITY_ENf, 0, FP_POLICY_TABLEm, INVALIDr, "" },
    { IL2L3_BUS_SER_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "IL2L3 BUS" },
    { ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, INVALIDm, INVALIDr, "L3 DEFIP ALPM IPV4/_1/IPV6_64/_64_1/_128" },
    { ILPM_SER_CONTROLr, L3_DEFIP_AUX_PARITY_ENf, 0, L3_DEFIP_AUX_TABLEm, INVALIDr, "" },
    { ILPM_SER_CONTROLr, L3_DEFIP_DATA_PARITY_ENf, 0, L3_DEFIP_DATA_ONLYm, INVALIDr, "" },
    { ILPM_SER_CONTROL_1r, RTAG7_PORT_BASED_HASH_PARITY_ENf, 0, RTAG7_PORT_BASED_HASHm, INVALIDr, "" },
    { ILPM_SER_CONTROL_1r, RTAG7_FLOW_BASED_HASH_PARITY_ENf, 0, RTAG7_FLOW_BASED_HASHm, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_0m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_1m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_2m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_3m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_4m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_5m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_6m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_7m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_0m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_1m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_2m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_3m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_4m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_5m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_6m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_7m, INVALIDr, "" },
    { IPARS_SER_CONTROLr, IPARS_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IARS BUS" },
    { IPARS_SER_CONTROLr, SRC_VP_2_PARITY_ENf, 0, SOURCE_VP_2m, INVALIDr, "" },
    { IPARS_SER_CONTROLr, SRC_TRUNK_ECC_ENf, 0, SOURCE_TRUNK_MAP_TABLEm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, L3_TUNNEL_PARITY_ENf, 0, L3_TUNNEL_DATA_ONLYm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, FP_UDF_PARITY_ENf, 0, FP_UDF_OFFSETm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, MOD_MAP_PARITY_ENf, 0, ING_MOD_MAP_TABLEm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, LPORT_TABLE_ECC_ENf, 0, LPORT_TABm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, CPU_TS_PARITY_ENf, 0, CPU_TS_MAPm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, VLAN_RANGE_PARITY_ENf, 0, ING_VLAN_RANGEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_ING_L3_NEXT_HOP_PARITY_ENf, 0, INITIAL_ING_L3_NEXT_HOPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_GROUP_PARITY_ENf, 0, INITIAL_L3_ECMP_GROUPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_PARITY_ENf, 0, INITIAL_L3_ECMPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, OAM_OPCODE_CONTROL_PROFILE_PARITY_ENf, 0, OAM_OPCODE_CONTROL_PROFILEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_PROT_NHI_TABLE_PARITY_ENf, 0, INITIAL_PROT_NHI_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_PARITY_ENf, 0, PORT_CBL_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, TRUNK_CBL_TABLE_PARITY_ENf, 0, TRUNK_CBL_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_MODBASE_PARITY_ENf, 0, PORT_CBL_TABLE_MODBASEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, L3_IPMC_1_PARITY_ENf, 0, L3_IPMC_1m, INVALIDr, "" },
/*    { IRSEL1_SER_CONTROLr, MAID_REDUCTION_PARITY_ENf, 0, MAID_REDUCTIONm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, MA_INDEX_PARITY_ENf, 0, MA_INDEXm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, MA_STATE_PARITY_ENf, 0, MA_STATEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, RMEP_PARITY_ENf, 0, RMEPm, INVALIDr, "" },*/
    { IRSEL1_SER_CONTROLr, ING_1588_INGRESS_CTRL_PARITY_ENf, 0, ING_1588_INGRESS_CTRLm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, IRSEL1_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IRSEL1 BUS" },
    { IRSEL2_SER_CONTROLr, ING_L3_NEXT_HOP_PARITY_ENf, 0, ING_L3_NEXT_HOPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L2MC_PARITY_ENf, 0, L2MCm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_IPMC_PARITY_ENf, 0, L3_IPMCm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_IPMC_REMAP_PARITY_ENf, 0, L3_IPMC_REMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_ECMP_GROUP_PARITY_ENf, 0, L3_ECMP_COUNTm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_ECMP_PARITY_ENf, 0, L3_ECMPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, IFP_REDIRECTION_PROFILE_PARITY_ENf, 0, IFP_REDIRECTION_PROFILEm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, ICONTROL_OPCODE_BITMAP_PARITY_ENf, 0, ICONTROL_OPCODE_BITMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, EGR_MASK_MODBASE_PARITY_ENf, 0, EGR_MASK_MODBASEm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, DEST_TRUNK_BITMAP_PARITY_ENf, 0, DEST_TRUNK_BITMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, TRUNK_GROUP_PARITY_ENf, 0, TRUNK_GROUPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, RH_ECMP_FLOWSET_PARITY_ENf, 0, RH_ECMP_FLOWSETm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, RH_LAG_FLOWSET_PARITY_ENf, 0, RH_LAG_FLOWSETm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, ING_SNAT_DATA_ONLY_PARITY_ENf, 0, ING_SNAT_DATA_ONLYm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, IRSEL2_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IRSEL2 BUS" },
    { ISW1_SER_CONTROLr, FP_PORT_FIELD_SEL_PARITY_ENf, 0, FP_PORT_FIELD_SELm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, TTL_FN_PARITY_ENf, 0, TTL_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, TOS_FN_PARITY_ENf, 0, TOS_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ING_PRI_CNG_MAP_PARITY_ENf, 0, ING_PRI_CNG_MAPm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ING_UNTAGGED_PHB_PARITY_ENf, 0, ING_UNTAGGED_PHBm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, DSCP_TABLE_PARITY_ENf, 0, DSCP_TABLEm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, STORM_CONTROL_METER_CONFIG_PARITY_ENf, 1, INVALIDm, STORM_CONTROL_METER_CONFIGr, "" },
    { ISW1_SER_CONTROLr, FCOE_HOP_COUNT_FN_PARITY_ENf, 0, FCOE_HOP_COUNT_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ISW1_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "ISW1 BUS" },
    { ISW2_SER_CONTROL_0r, VOQ_PORT_MAP_PARITY_ENf, 0, VOQ_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, VOQ_MOD_MAP_PARITY_ENf, 0, VOQ_MOD_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, TRUNK_MEMBER_PARITY_ENf, 0, TRUNK_MEMBERm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_0r, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf, 0, DLB_HGT_FLOWSET_TIMESTAMP_PAGEm, 
      INVALIDr, "" }, DUPLICATE */
    { ISW2_SER_CONTROL_0r, UNKNOWN_HGI_BITMAP_PARITY_ENf, 0, UNKNOWN_HGI_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, IMIRROR_BITMAP_PARITY_ENf, 0, IMIRROR_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, KNOWN_MCAST_BLOCK_MASK_PARITY_ENf, 0, KNOWN_MCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_EGRMSKBMAP_PARITY_ENf, 0, ING_EGRMSKBMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, BCAST_BLOCK_MASK_PARITY_ENf, 0, BCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, UNKNOWN_MCAST_BLOCK_MASK_PARITY_ENf, 0, UNKNOWN_MCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, UNKNOWN_UCAST_BLOCK_MASK_PARITY_ENf, 0, UNKNOWN_UCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRRm, 
      INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBMm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_0r, VOQ_COS_MAP_PARITY_ENf, 0, VOQ_COS_MAPm, INVALIDr, "" }, NA */
    { ISW2_SER_CONTROL_0r, NUM_QCN_CNM_RECEIVED_PARITY_ENf, 0, NUM_QCN_CNM_RECEIVEDm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, OAM_LM_COUNTERS_PARITY_ENf, 0, OAM_LM_COUNTERSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, SRC_MODID_EGRESS_PARITY_ENf, 0, SRC_MODID_EGRESSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, SRC_MODID_INGRESS_BLOCK_PARITY_ENf, 0, SRC_MODID_INGRESS_BLOCKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_1_PARITY_ENf, 0, E2E_HOL_STATUS_1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_PARITY_ENf, 0, E2E_HOL_STATUSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, VLAN_PROFILE_2_PARITY_ENf, 0, VLAN_PROFILE_2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MAC_BLOCK_TABLE_PARITY_ENf, 0, MAC_BLOCKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_PW_TERM_SEQ_NUM_PARITY_ENf, 0, ING_PW_TERM_SEQ_NUMm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ALTERNATE_EMIRROR_BITMAP_PARITY_ENf, 0, ALTERNATE_EMIRROR_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_MIRRORm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, PORT_LAG_FAILOVER_SET_PARITY_ENf, 0, PORT_LAG_FAILOVER_SETm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_HIGIG_TRUNK_OVERRIDE_PROFILE_PARITY_ENf, 0, ING_HIGIG_TRUNK_OVERRIDE_PROFILEm, 
      INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_SW_PARITY_ENf, 0, MODPORT_MAP_SWm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, NONUCAST_TRUNK_BLOCK_MASK_PARITY_ENf, 0, NONUCAST_TRUNK_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, TRUNK_BITMAP_TABLE_PARITY_ENf, 0, TRUNK_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, EGR_MASK_PARITY_ENf, 0, EGR_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_M3m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_M2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_M1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, SERVICE_PORT_MAP_PARITY_ENf, 0, SERVICE_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, SERVICE_QUEUE_MAP_PARITY_ENf, 0, SERVICE_QUEUE_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, ING_MISC_PORT_CONFIG_PARITY_ENf, 1, INVALIDm, ING_MISC_PORT_CONFIGr, "" },
    { ISW2_SER_CONTROL_1r, SFLOW_EGR_THRESHOLD_PARITY_ENf, 1, INVALIDm, SFLOW_EGR_THRESHOLDr, "" },
    { ISW2_SER_CONTROL_1r, SFLOW_ING_THRESHOLD_PARITY_ENf, 1, INVALIDm, SFLOW_ING_THRESHOLDr, "" },
    /*{ ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_VLAN_TAGGED_PARITY_ENf, 1, INVALIDm,
      ING_NIV_RX_FRAMES_VLAN_TAGGEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_FORWARDING_DROP_PARITY_ENf, 1, INVALIDm, 
      ING_NIV_RX_FRAMES_FORWARDING_DROPr, "" },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_ERROR_DROP_PARITY_ENf, 1, INVALIDm,
      ING_NIV_RX_FRAMES_ERROR_DROPr, "" },*/
    
    
    { ISW2_SER_CONTROL_1r, L3_MTU_VALUES_PARITY_ENf, 0, L3_MTU_VALUESm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_1r, ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_ENf, 1, INVALIDm, 
      ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_ENf, 1, INVALIDm, 
      ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_PKTS_PARITY_ENf, 1, INVALIDm, ING_TRILL_RX_PKTSr, "" },*/
    { ISW2_SER_CONTROL_1r, HG_COUNTERS_PARITY_ENf, 1, INVALIDm, INVALIDr, "HG STATS COUNTERS" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST2_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDBGC5/RDBGC6/RDBGC7/RDBGC8" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST1_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDBGC1/RDBGC2/RDBGC3/RDBGC4" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST0_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDISC/RUC/RPORTD/RDBGC0" },
    { ISW2_SER_CONTROL_1r, IP_COUNTERS_PARITY_ENf, 1, INVALIDm, INVALIDr, "IP STATS COUNTERS" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_C_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER C" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_B_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER B" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_A_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER A" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL3_PARITY_ENf, 0, EMIRROR_CONTROL3m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL2_PARITY_ENf, 0, EMIRROR_CONTROL2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL1_PARITY_ENf, 0, EMIRROR_CONTROL1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL_PARITY_ENf, 0, EMIRROR_CONTROLm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ENDPOINT_COS_MAP_PARITY_ENf, 0, ENDPOINT_COS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, PHB2_COS_MAP_PARITY_ENf, 0, PHB2_COS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ENDPOINT_QUEUE_MAP_PARITY_ENf, 0, ENDPOINT_QUEUE_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PKT_PRI_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PKT_PRI_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PRI_CNG_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PRI_CNG_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PORT_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_TOS_MAP_PARITY_ENf, 0, ING_FLEX_CTR_TOS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PKT_RES_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PKT_RES_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_SERVICE_PRI_MAP_PARITY_ENf, 0, ING_SERVICE_PRI_MAPm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_XLATE_PARITY_EN_LPf, 0, VLAN_XLATE_LPm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, ING_ETAG_PCP_MAPPING_PARITY_ENf, 0, ING_ETAG_PCP_MAPPINGm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_PROT_PARITY_ENf, 0, VLAN_PROTOCOL_DATAm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, ING_VLAN_TAG_ACTION_PROFILE_PARITY_ENf, 0, ING_VLAN_TAG_ACTION_PROFILEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, MPLS_ENTRY_PARITY_ENf, 0, MPLS_ENTRYm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_SUBNET_PARITY_ENf, 0, VLAN_SUBNET_DATA_ONLYm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_PROT_PARITY_ENf, 0, VLAN_PROTOCOLm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_XLATE_PARITY_ENf, 0, VLAN_XLATEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VFP_POLICY_PARITY_ENf, 0, VFP_POLICY_TABLEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, IVXLT_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IVXLT BUS" },
    { L2_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L2Xm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, ING_DVP_TABLE_PARITY_ENf, 0, ING_DVP_TABLEm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, L2_ENDPOINT_ID_PARITY_ENf, 0, L2_ENDPOINT_IDm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, PARITY_EN_LPf, 0, L2_ENTRY_LPm, INVALIDr, "" },
    { L2_MOD_FIFO_PARITY_CONTROLr, PARITY_ENf, 0, L2_MOD_FIFOm, INVALIDr, "" },
    { L2_USER_ENTRY_DATA_PARITY_CONTROLr, PARITY_ENf, 0, L2_USER_ENTRY_DATA_ONLYm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L3_ENTRY_ONLYm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, ING_ACTIVE_L3_IIF_PROFILE_PARITY_ENf, 0, ING_ACTIVE_L3_IIF_PROFILEm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_EN_LPf, 0, L3_ENTRY_LPm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_VP_VLAN_MEMBERSHIP_PAR_ENf, 0, ING_VP_VLAN_MEMBERSHIPm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, L3_IIF_PAR_ENf, 0, L3_IIFm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_MPLS_EXP_MAPPING_PAR_ENf, 0, ING_MPLS_EXP_MAPPINGm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VRF_PAR_ENf, 0, VRFm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_PAR_ENf, 0, VLAN_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_STG_PAR_ENf, 0, STG_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_PROFILE_PAR_ENf, 0, VLAN_PROFILE_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_OUTER_DOT1P_MAPPING_TABLE_PAR_ENf, 0, ING_OUTER_DOT1P_MAPPING_TABLEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, IP_OPTION_CONTROL_PROFILE_TABLE_PAR_ENf, 0, IP_OPTION_CONTROL_PROFILE_TABLEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, L3_IIF_PROFILE_PAR_ENf, 0, L3_IIF_PROFILEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_DNAT_ADDRESS_TYPE_PAR_ENf, 0, ING_DNAT_ADDRESS_TYPEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, MPLS_BUS_PAR_ENf, 2, INVALIDm, INVALIDr, "MPLS BUS" },
    { VP_SER_CONTROLr, VLAN_MPLS_PAR_ENf, 0, VLAN_MPLSm, INVALIDr, "" },
    { VP_SER_CONTROLr, MY_STATION_TCAM_DATA_ONLY_PAR_ENf, 0, MY_STATION_TCAM_DATA_ONLYm, INVALIDr, "" },
    { VP_SER_CONTROLr, SOURCE_VP_PAR_ENf, 0, SOURCE_VPm, INVALIDr, "" },
    { VP_SER_CONTROLr, VFI_PAR_ENf, 0, VFIm, INVALIDr, "" },
    { VP_SER_CONTROLr, VFI_1_PAR_ENf, 0, VFI_1m, INVALIDr, "" },
    { VP_SER_CONTROLr, ING_VSAN_PAR_ENf, 0, ING_VSANm, INVALIDr, "" },
    { VP_SER_CONTROLr, ING_TRILL_ADJACENCY_PAR_ENf, 1, INVALIDm, ING_TRILL_ADJACENCYr, "" },
    { VP_SER_CONTROLr, VP_BUS_PAR_ENf, 2, INVALIDm, INVALIDr, "VP BUS" },
    { INVALIDr }
};

STATIC const
_soc_td2_ser_block_info_t _soc_td2_ser_block_info[] = {
    { SOC_BLK_IPIPE, ING_SER_FIFO_CTRLr, _soc_td2_ip_ser_info },
    { SOC_BLK_EPIPE, EGR_SER_FIFO_CTRLr, _soc_td2_ep_ser_info },
    { 0 }
};

STATIC _soc_td2_ser_info_t _soc_td2_mmu_ser_info[] = {
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0,
        DEQ_NOT_IP_ERR_ENf,
        DEQ_NOT_IP_ERRf,
        INVALIDm, "MMU DEQ NOT IP",
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_START_ERR, NULL, 0,
        START_BY_START_ERR_ENf,
        START_BY_START_ERRf,
        INVALIDm, "MMU START BY START",
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_MMU_SER, NULL, 0,
        MEM_PAR_ERR_ENf,
        MEM_PAR_ERRf,
        INVALIDm, "MMU MEM PAR",
        INVALIDr, INVALIDf,
        MEM_FAIL_INT_STATr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_THDI_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_THDO_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_CFAP_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_td2_ser_info_t _soc_td2_cport_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO0_MEM_ERRf,
        TXFIFO0_MEM_ERRf,
        INVALIDm, "CDC RX FIFO MEMORY ECC",
        CPORT_ECC_CONTROLr, CDC_RXFIFO_MEM_ENf,
        CPORT_TXFIFO0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CDC_TXFIFO_MEM_ERRf,
        CDC_TXFIFO_MEM_ERRf,
        INVALIDm, "CDC TX FIFO MEMORY ECC",
        CPORT_ECC_CONTROLr, CDC_TXFIFO_MEM_ENf,
        CPORT_CDC_TXFIFO_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO0_MEM_ERRf,
        TXFIFO0_MEM_ERRf,
        INVALIDm, "TX FIFO ECC - XPORT CORE0 OR CPORT CORE",
        CPORT_ECC_CONTROLr, TXFIFO_MEM_ENf,
        CPORT_TXFIFO0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_td2_ser_reg_t _soc_td2_pg_bod_status_reg[] = {
    { PGW_BOD_XLP0_ECC_STATUSr, "PGW BOD XLP0 ECC" },
    { PGW_BOD_XLP1_ECC_STATUSr, "PGW BOD XLP1 ECC" },
    { PGW_BOD_XLP2_ECC_STATUSr, "PGW BOD XLP2 ECC" },
    { PGW_BOD_XLP3_ECC_STATUSr, "PGW BOD XLP3 ECC" },
    { INVALIDr }
};

STATIC _soc_td2_ser_info_t _soc_td2_pg_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        PGW_OBM_PERR_INTRf,
        PGW_OBM_PERR_INTRf,
        INVALIDm, "PGW OBM",
        PGW_OBM0_ECC_ENABLEr, ECC_ENABLEf,
        PGW_OBM0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        PGW_BOD_PERR_INTRf,
        PGW_BOD_PERR_INTRf,
        INVALIDm, "PGW BOD",
        PGW_BOD_ECC_ENABLEr, BOD_ECC_ENABLEf,
        INVALIDr, _soc_td2_pg_bod_status_reg },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC1_MEM_ERRf,
        MIB_RSC1_MEM_ERRf,
        INVALIDm, "PGW MIB RX CTR Instance 1",
        INVALIDr, INVALIDf,
        PGW_MIB_RSC1_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC0_MEM_ERRf,
        MIB_RSC0_MEM_ERRf,
        INVALIDm, "PGW MIB RX CTR Instance 0",
        PGW_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        PGW_MIB_RSC0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC1_MEM_ERRf,
        MIB_RSC1_MEM_ERRf,
        INVALIDm, "PGW MIB TX CTR Instance 1",
        INVALIDr, INVALIDf,
        PGW_MIB_TSC1_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC0_MEM_ERRf,
        MIB_RSC0_MEM_ERRf,
        INVALIDm, "PGW MIB TX CTR Instance 0",
        PGW_ECC_CONTROLr, MIB_TSC_MEM_ENf,
        PGW_MIB_TSC0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_CPORT, _soc_td2_cport_ser_info, 0,
        CPORT_ERRf,
        CPORT_ERRf,
        INVALIDm, "CPORT",
        CPORT_INTR_ENABLEr, INVALIDf, /* group enable */
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC const
_soc_td2_ser_route_block_t  _soc_td2_ser_route_blocks[] = {
    { 0x00000001, /* MMU_TO_CMIC_MEMFAIL_INTR */
      SOC_BLK_MMU, -1, MEM_FAIL_INT_ENr, MEM_FAIL_INT_STATr, INVALIDf, 
      _soc_td2_mmu_ser_info, 0 },
    { 0x00000002, /* X_EP1_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 0, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000004, /* Y_EP1_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 1, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000008, /* X_EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 0, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000010, /* Y_EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 1, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000020, /* X_IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000040, /* Y_IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000080, /* X_IP1_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000100, /* Y_IP1_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000200, /* X_IP2_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000400, /* Y_IP2_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000800, /* X_IP3_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00001000, /* Y_IP3_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00002000, /* X_IP4_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00004000, /* Y_IP4_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00008000, /* X_IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00010000, /* Y_IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00040000, /* PGW_0_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 0 },
    { 0x00080000, /* PGW_1_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 1 },
    { 0x00100000, /* PGW_2_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 2 },
    { 0x00200000, /* PGW_3_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 3 },
    { 0x00400000, /* PGW_4_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 4 },
    { 0x00800000, /* PGW_5_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 5 },
    { 0x01000000, /* PGW_6_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 6 },
    { 0x02000000, /* PGW_7_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 7 },
    { 0 } /* table terminator */
};

static const soc_reg_t mmu_ovs_group_regs[2][MAX_MMU_OVS_GROUP_COUNT] = {
    {
        ES_PIPE0_OVR_SUB_GRP0_TBLr, ES_PIPE0_OVR_SUB_GRP1_TBLr,
        ES_PIPE0_OVR_SUB_GRP2_TBLr, ES_PIPE0_OVR_SUB_GRP3_TBLr
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
        ES_PIPE0_OVR_SUB_GRP4_TBLr, ES_PIPE0_OVR_SUB_GRP5_TBLr,
        ES_PIPE0_OVR_SUB_GRP6_TBLr, ES_PIPE0_OVR_SUB_GRP7_TBLr
#endif
    },
    {
        ES_PIPE1_OVR_SUB_GRP0_TBLr, ES_PIPE1_OVR_SUB_GRP1_TBLr,
        ES_PIPE1_OVR_SUB_GRP2_TBLr, ES_PIPE1_OVR_SUB_GRP3_TBLr
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
        ES_PIPE1_OVR_SUB_GRP4_TBLr, ES_PIPE1_OVR_SUB_GRP5_TBLr,
        ES_PIPE1_OVR_SUB_GRP6_TBLr, ES_PIPE1_OVR_SUB_GRP7_TBLr
#endif
    }
};

static const soc_field_t pgw_tdm_fields[] = {
    TDM_ENTRY0_PORT_IDf, TDM_ENTRY1_PORT_IDf,
    TDM_ENTRY2_PORT_IDf, TDM_ENTRY3_PORT_IDf,
    TDM_ENTRY4_PORT_IDf, TDM_ENTRY5_PORT_IDf,
    TDM_ENTRY6_PORT_IDf, TDM_ENTRY7_PORT_IDf,
    TDM_ENTRY8_PORT_IDf, TDM_ENTRY9_PORT_IDf,
    TDM_ENTRY10_PORT_IDf, TDM_ENTRY11_PORT_IDf,
    TDM_ENTRY12_PORT_IDf, TDM_ENTRY13_PORT_IDf,
    TDM_ENTRY14_PORT_IDf, TDM_ENTRY15_PORT_IDf,
    TDM_ENTRY16_PORT_IDf, TDM_ENTRY17_PORT_IDf,
    TDM_ENTRY18_PORT_IDf, TDM_ENTRY19_PORT_IDf,
    TDM_ENTRY20_PORT_IDf, TDM_ENTRY21_PORT_IDf,
    TDM_ENTRY22_PORT_IDf, TDM_ENTRY23_PORT_IDf,
    TDM_ENTRY24_PORT_IDf, TDM_ENTRY25_PORT_IDf,
    TDM_ENTRY26_PORT_IDf, TDM_ENTRY27_PORT_IDf,
    TDM_ENTRY28_PORT_IDf, TDM_ENTRY29_PORT_IDf,
    TDM_ENTRY30_PORT_IDf, TDM_ENTRY31_PORT_IDf
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
    TDM_ENTRY32_PORT_IDf, TDM_ENTRY33_PORT_IDf,
    TDM_ENTRY34_PORT_IDf, TDM_ENTRY35_PORT_IDf,
    TDM_ENTRY36_PORT_IDf, TDM_ENTRY37_PORT_IDf,
    TDM_ENTRY38_PORT_IDf, TDM_ENTRY39_PORT_IDf,
    TDM_ENTRY40_PORT_IDf, TDM_ENTRY41_PORT_IDf,
    TDM_ENTRY42_PORT_IDf, TDM_ENTRY43_PORT_IDf,
    TDM_ENTRY44_PORT_IDf, TDM_ENTRY45_PORT_IDf,
    TDM_ENTRY46_PORT_IDf, TDM_ENTRY47_PORT_IDf,
    TDM_ENTRY48_PORT_IDf, TDM_ENTRY49_PORT_IDf,
    TDM_ENTRY50_PORT_IDf, TDM_ENTRY51_PORT_IDf,
    TDM_ENTRY52_PORT_IDf, TDM_ENTRY53_PORT_IDf,
    TDM_ENTRY54_PORT_IDf, TDM_ENTRY55_PORT_IDf,
    TDM_ENTRY56_PORT_IDf, TDM_ENTRY57_PORT_IDf,
    TDM_ENTRY58_PORT_IDf, TDM_ENTRY59_PORT_IDf,
    TDM_ENTRY60_PORT_IDf, TDM_ENTRY61_PORT_IDf,
    TDM_ENTRY62_PORT_IDf, TDM_ENTRY63_PORT_IDf
#endif
};

#ifdef BCM_TRIDENT2PLUS_SUPPORT
static soc_reg_t mmu_ovs_group_wt_select_regs[2] = {
    ES_PIPE0_GRP_WT_SELECTr,
    ES_PIPE1_GRP_WT_SELECTr
};
#endif

static soc_reg_t pgw_tdm_regs[] = {
    PGW_LR_TDM_REG_0r, PGW_LR_TDM_REG_1r,
    PGW_LR_TDM_REG_2r, PGW_LR_TDM_REG_3r,
    PGW_LR_TDM_REG_4r, PGW_LR_TDM_REG_5r,
    PGW_LR_TDM_REG_6r, PGW_LR_TDM_REG_7r
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
    PGW_LR_TDM_REG_8r,  PGW_LR_TDM_REG_9r,
    PGW_LR_TDM_REG_10r, PGW_LR_TDM_REG_11r,
    PGW_LR_TDM_REG_12r, PGW_LR_TDM_REG_13r,
    PGW_LR_TDM_REG_14r, PGW_LR_TDM_REG_15r
#endif
};

static soc_reg_t pgw_ovs_tdm_regs[] = {
    PGW_OS_TDM_REG_0r, PGW_OS_TDM_REG_1r,
    PGW_OS_TDM_REG_2r, PGW_OS_TDM_REG_3r,
    PGW_OS_TDM_REG_4r, PGW_OS_TDM_REG_5r,
    PGW_OS_TDM_REG_6r, PGW_OS_TDM_REG_7r
};

static soc_reg_t mmu_ovs_group_wt_regs_local[2][_MMU_OVS_WT_GROUP_COUNT] = {
    {
        ES_PIPE0_OVR_SUB_GRP0_WTr, ES_PIPE0_OVR_SUB_GRP1_WTr,
        ES_PIPE0_OVR_SUB_GRP2_WTr, ES_PIPE0_OVR_SUB_GRP3_WTr
    },
    {
        ES_PIPE1_OVR_SUB_GRP0_WTr, ES_PIPE1_OVR_SUB_GRP1_WTr,
        ES_PIPE1_OVR_SUB_GRP2_WTr, ES_PIPE1_OVR_SUB_GRP3_WTr
    }
};

static soc_ser_functions_t _td2_ser_functions;

uint8 _soc_alpm_mode[SOC_MAX_NUM_DEVICES];

static const int a1_freq_list[]      = { 760, 660, 608, 518, 415 };
static const int a2_793_freq_list[]  = { 793, 760, 635, 537, 415 };
static const int a2_635_freq_list[]  = { 635, 608, 537, 518, 415 };
static const int a1_td2p_freq_list[] = { 793, 760, 635, 537, 421 };

int
soc_trident2_pipe_select(int unit, int egress, int pipe)
{
    soc_reg_t reg;

    reg = egress ? EGR_SBS_CONTROLr : SBS_CONTROLr;
    return soc_reg_field32_modify(unit, reg, REG_PORT_ANY, PIPE_SELECTf, pipe);
}

STATIC int
_soc_trident2_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                              soc_reg_t group_reg, uint64 *group_rval,
                              const _soc_td2_ser_info_t *info_list,
                              soc_mem_t mem, int enable);
STATIC int
soc_trident2_ser_enable_by_acctype(int unit, soc_reg_t reg, 
                                                soc_field_t field, int enable,
                                                int egress);


enum _td2p_ovs_wt_speed_group {
    td2p_ovs_wt_group_speed_10G,
    td2p_ovs_wt_group_speed_20G,
    td2p_ovs_wt_group_speed_40G,
    td2p_ovs_wt_group_speed_NA
};

#ifdef BCM_TRIDENT2PLUS_SUPPORT

static int _mmu_16_mode = 0;

#define _SOC_TD2P_SER_TYPE_REG 0
#define _SOC_TD2P_SER_TYPE_MEM 1
#define _SOC_TD2P_SER_TYPE_BUS 2
#define _SOC_TD2P_SER_TYPE_BUF 3

/* These are now generated from the regsfile processing into bcm56860_a0.c */
extern _soc_mem_ser_en_info_t _soc_bcm56860_a0_ip_mem_ser_info[];
extern _soc_reg_ser_en_info_t _soc_bcm56860_a0_ip_reg_ser_info[];
extern _soc_mem_ser_en_info_t _soc_bcm56860_a0_ep_mem_ser_info[];
extern _soc_reg_ser_en_info_t _soc_bcm56860_a0_ep_reg_ser_info[];
extern _soc_mem_ser_en_info_t _soc_bcm56860_a0_mmu_mem_ser_info[];
/* Above structures are defined in chip.h */

/* Setup dynamically in enable ser */
static uint32 _soc_td2p_ip_pipe_fifo_bmask[] = {
    0, 0, 0, 0
};

_soc_bus_ser_en_info_t _soc_ep_bus_ser_info [] = {
    { "EFP",     EFP_PARITY_CONTROLr,      EFP_BUS_PARITY_ENf     },
    { "EFPPARS", EGR_EFPPARS_SER_CONTROLr, EFPPARS_BUS_PARITY_ENf },
    { "EHCPM",   EGR_EHCPM_SER_CONTROLr,   EHCPM_BUS_PARITY_ENf },
    { "EPMOD",   EGR_EPMOD_SER_CONTROLr,   EPMOD_BUS_PARITY_ENf },
    { "EVLAN",   EGR_VLAN_SER_CONTROLr,    EVLAN_BUS_PARITY_ENf },
    { "", INVALIDr } /* end */ 
};

_soc_buffer_ser_en_info_t _soc_ep_buffer_ser_info[] = {
    { "INITBUF", EGR_EL3_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf },
    { "EGR MPB",  EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPB_ECC_ENf },
    { "EDB_CM_MEM", EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf },
    { "XLP15_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP15_ECC_ENf },
    { "XLP14_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP14_ECC_ENf },
    { "XLP13_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP13_ECC_ENf },
    { "XLP12_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP12_ECC_ENf },
    { "XLP11_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP11_ECC_ENf },
    { "XLP10_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP10_ECC_ENf },
    { "XLP9_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP9_ECC_ENf  },
    { "XLP8_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP8_ECC_ENf  },
    { "XLP7_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP7_ECC_ENf  },
    { "XLP6_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP6_ECC_ENf  },
    { "XLP5_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP5_ECC_ENf  },
    { "XLP4_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP4_ECC_ENf  },
    { "XLP3_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP3_ECC_ENf  },
    { "XLP2_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP2_ECC_ENf  },
    { "XLP1_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP1_ECC_ENf  },
    { "XLP0_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP0_ECC_ENf  },
    { "CLP3_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP3_ECC_ENf  },
    { "CLP2_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP2_ECC_ENf  },
    { "CLP1_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP1_ECC_ENf  },
    { "CLP0_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP0_ECC_ENf  },
    { "EP_XLP15_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP15_ECC_ENf },
    { "EP_XLP14_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP14_ECC_ENf },
    { "EP_XLP13_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP13_ECC_ENf },
    { "EP_XLP12_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP12_ECC_ENf },
    { "EP_XLP11_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP11_ECC_ENf },
    { "EP_XLP10_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP10_ECC_ENf },
    { "EP_XLP9__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP9_ECC_ENf  },
    { "EP_XLP8__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP8_ECC_ENf  },
    { "EP_XLP7__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP7_ECC_ENf  },
    { "EP_XLP6__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP6_ECC_ENf  },
    { "EP_XLP5__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP5_ECC_ENf  },
    { "EP_XLP4__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP4_ECC_ENf  },
    { "EP_XLP3__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP3_ECC_ENf  },
    { "EP_XLP2__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP2_ECC_ENf  },
    { "EP_XLP1__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP1_ECC_ENf  },
    { "EP_XLP0__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP0_ECC_ENf  },
    { "EP_CLP3__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP3_ECC_ENf  },
    { "EP_CLP2__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP2_ECC_ENf  },
    { "EP_CLP1__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP1_ECC_ENf  },
    { "EP_CLP0__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP0_ECC_ENf  },


    { "", INVALIDr }
};


_soc_bus_ser_en_info_t _soc_ip_bus_ser_info [] = {
    { "IPARS", IPARS_SER_CONTROLr, IPARS_BUS_PARITY_ENf },
    { "IRSEL1", IRSEL1_SER_CONTROLr, IRSEL1_BUS_PARITY_ENf },
    { "IRSEL2", IRSEL2_SER_CONTROLr, IRSEL2_BUS_PARITY_ENf },
    { "ISW1", ISW1_SER_CONTROLr, ISW1_BUS_PARITY_ENf },
    { "IVXLT", IVXLT_SER_CONTROLr, IVXLT_BUS_PARITY_ENf },
    { "LEARN_FIFO", IARB_SER_CONTROLr, LEARN_FIFO_ECC_ENf },
    { "MPLS", MPLS_SER_CONTROLr, MPLS_BUS_PAR_ENf, },
    { "SW2_EOP_BUF_C", ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_C_PARITY_ENf },
    { "SW2_EOP_BUF_B", ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_B_PARITY_ENf },
    { "SW2_EOP_BUF_A", ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_A_PARITY_ENf },
    { "VP", VP_SER_CONTROLr, VP_BUS_PAR_ENf },
    { "IFP", IFP_PARITY_CONTROLr, IFP_BUS_PARITY_ENf },
    { "IL2L3", IL2L3_BUS_SER_CONTROLr, PARITY_ENf },
    { "", INVALIDr } /* end */ 
};

_soc_buffer_ser_en_info_t _soc_ip_buffer_ser_info[] = {
    { "COUNTER_STAGING", IFP_PARITY_CONTROLr, COUNTER_MUX_DATA_STAGING_PARITY_ENf },
    { "METER_STAGING", IFP_PARITY_CONTROLr, METER_MUX_DATA_STAGING_PARITY_ENf },
    { "CMIC", IARB_SER_CONTROLr, CMIC_BUF_ECC_ENf },
    { "IP STATS COUNTERS", ISW2_SER_CONTROL_1r, IP_COUNTERS_PARITY_ENf },
    { "RDISC/RUC/RPORTD/RDBGC0", ISW2_SER_CONTROL_1r, RDBGC_MEM_INST0_PARITY_ENf },
    { "HG STATS COUNTERS", ISW2_SER_CONTROL_1r, HG_COUNTERS_PARITY_ENf },
    { "RDBGC5/RDBGC6/RDBGC7/RDBGC8", ISW2_SER_CONTROL_1r, RDBGC_MEM_INST2_PARITY_ENf },
    { "RDBGC1/RDBGC2/RDBGC3/RDBGC4", ISW2_SER_CONTROL_1r, RDBGC_MEM_INST1_PARITY_ENf },
    { "ING_NIV_RX_FRAMES_ERRe", ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_ERROR_DROP_PARITY_ENf },
    { "ING_NIV_RX_FRAMES_FRWD", ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_FORWARDING_DROP_PARITY_ENf },
    { "ING_NIV_RX_FRAMES_VLAN", ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_VLAN_TAGGED_PARITY_ENf },
    { "ING_TRILL_RX_ACCESS", ISW2_SER_CONTROL_1r, ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_ENf },
    { "ING_TRILL_RX_NETWORK_PORT", ISW2_SER_CONTROL_1r, ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_ENf },
    { "ING_TRILL_RX_PKTS table", ISW2_SER_CONTROL_1r, ING_TRILL_RX_PKTS_PARITY_ENf },
    { "SFLOW_ING_THRESHOLD table", ISW2_SER_CONTROL_1r, SFLOW_ING_THRESHOLD_PARITY_ENf },
    { "DLB_HGT_FLOWSET_TIME", DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf },
    { "DLB_HGT_FLOWSET", DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_PARITY_ENf },

    { "", INVALIDr }
};

_soc_buffer_ser_en_info_t _soc_mmu_buffer_ser_info[] = {
    { "MMU EPRG", PARITY_ENr, EPRG_PARITY_ENf }, 
    { "MMU PQE", PARITY_ENr, PQE_PARITY_ENf }, 
    { "MMU WRED", PARITY_ENr, WRED_PARITY_ENf }, 
    { "MMU CTR", PARITY_ENr, CTR_PARITY_ENf }, 

    { "", INVALIDr }
};

typedef struct _soc_td2p_ser_block_info_s {
    int         type;
    soc_block_t blocktype;
    char        name[16];
    soc_reg_t   fifo_reset_reg;
    void        *info;
} _soc_td2p_ser_block_info_t;


static const
_soc_td2p_ser_block_info_t _soc_td2p_ser_block_info[] = {
    { _SOC_TD2P_SER_TYPE_REG, SOC_BLK_IPIPE, "IPIPE regs", INVALIDr, _soc_bcm56860_a0_ip_reg_ser_info },
    { _SOC_TD2P_SER_TYPE_MEM, SOC_BLK_IPIPE, "IPIPE mems", ING_SER_FIFO_CTRLr, _soc_bcm56860_a0_ip_mem_ser_info },
    { _SOC_TD2P_SER_TYPE_BUS, SOC_BLK_EPIPE, "IPIPE buses",INVALIDr, _soc_ip_bus_ser_info },
    { _SOC_TD2P_SER_TYPE_BUF, SOC_BLK_EPIPE, "IPIPE buff" ,INVALIDr, _soc_ip_buffer_ser_info },
    { _SOC_TD2P_SER_TYPE_REG, SOC_BLK_EPIPE, "EPIPE regs", INVALIDr, _soc_bcm56860_a0_ep_reg_ser_info },
    { _SOC_TD2P_SER_TYPE_BUS, SOC_BLK_EPIPE, "EPIPE buses",INVALIDr, _soc_ep_bus_ser_info },
    { _SOC_TD2P_SER_TYPE_BUF, SOC_BLK_EPIPE, "EPIPE buff" ,INVALIDr, _soc_ep_buffer_ser_info },
    { _SOC_TD2P_SER_TYPE_MEM, SOC_BLK_EPIPE, "EPIPE mems", EGR_SER_FIFO_CTRLr, _soc_bcm56860_a0_ep_mem_ser_info },
    { _SOC_TD2P_SER_TYPE_MEM, SOC_BLK_MMU,   "MMU mems", INVALIDr, _soc_bcm56860_a0_mmu_mem_ser_info },
    { _SOC_TD2P_SER_TYPE_BUF, SOC_BLK_MMU,   "MMU buff", INVALIDr, _soc_mmu_buffer_ser_info },
    { -1, 0 }
};

int
_soc_trident2p_ser_enable_all(int unit, const _soc_td2p_ser_block_info_t *ser_block_info, int enable)
{
    uint8                           rbi, bcount, type;
    uint16                          pcount;
    uint32                          cmic_rval;
    uint32                          rval, cmic_bit;
    int                             port = REG_PORT_ANY;
    int                             phy_port, cport, slot_port, obm_slot;
    int                             rv, block_info_idx;
    uint64                          rval64;
    soc_reg_t                       reg, ecc1b_reg;
    soc_field_t                     field, ecc1b_field;
    _soc_reg_ser_en_info_t          *reg_info;
    _soc_mem_ser_en_info_t          *mem_info;
    _soc_bus_ser_en_info_t          *bus_info;
    _soc_buffer_ser_en_info_t       *buf_info;
    char                            *str_type;
    char                            *str_name;
    const _soc_td2_ser_route_block_t *rb;
    static char *parity_module_str[4] = {"REG", "MEM", "BUS", "BUF"};
    soc_info_t *si = &SOC_INFO(unit);

    SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_PCIE_IRQ_MASK2r(unit, &cmic_rval));
    /* Enable new fifo mechanism based SER stuff */
    for (bcount = 0; ser_block_info[bcount].blocktype; bcount++) {
        int done = 0;

        LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                   (BSL_META_U(unit,
                               "Unit %d SER enable for: %s\n"),
                                    unit, ser_block_info[bcount].name));

        type = ser_block_info[bcount].type;
        reg_info = (_soc_reg_ser_en_info_t*)ser_block_info[bcount].info;
        mem_info = (_soc_mem_ser_en_info_t*)ser_block_info[bcount].info;
        bus_info = (_soc_bus_ser_en_info_t*)ser_block_info[bcount].info;
        buf_info = (_soc_buffer_ser_en_info_t*)ser_block_info[bcount].info;
        for (pcount = 0; ; pcount++) {
            ecc1b_reg = INVALIDr;    
            ecc1b_field = INVALIDf;
            switch (type) {
            case _SOC_TD2P_SER_TYPE_REG: 
                if (reg_info[pcount].reg == INVALIDr) { 
                    done = 1;
                } else {
                    reg = reg_info[pcount].en_reg;
                    field = reg_info[pcount].en_fld;
                    str_name = SOC_REG_NAME(unit, reg_info[pcount].reg);
                }
                break;
            case _SOC_TD2P_SER_TYPE_MEM:
                if (mem_info[pcount].mem == INVALIDm) { 
                    done = 1;
                } else {
                    if (soc_feature(unit, soc_feature_parity_injection_l2)) {
                        if ((mem_info[pcount].mem == L2_USER_ENTRYm) ||
                        	  (mem_info[pcount].mem == L2_USER_ENTRY_DATA_ONLYm)){ 
                            continue;
                        }
                    }

                    reg = mem_info[pcount].en_reg;
                    field = mem_info[pcount].en_fld;
                    ecc1b_reg = mem_info[pcount].ecc_1b_report_en_reg;
                    ecc1b_field = mem_info[pcount].ecc_1b_report_en_fld;
                    str_name = SOC_MEM_NAME(unit, mem_info[pcount].mem);
                }
                break;
            case _SOC_TD2P_SER_TYPE_BUS:
                if (bus_info[pcount].en_reg == INVALIDr) { 
                    done = 1;
                } else {
                    reg = bus_info[pcount].en_reg;
                    field = bus_info[pcount].en_fld;
                    str_name = bus_info[pcount].bus_name;
                }
                break;
            case _SOC_TD2P_SER_TYPE_BUF:
                if (buf_info[pcount].en_reg == INVALIDr) {
                    done = 1;
                } else {
                    reg = buf_info[pcount].en_reg;
                    field = buf_info[pcount].en_fld;
                    str_name = buf_info[pcount].buffer_name;
                }
                break;
            default:
                LOG_ERROR(BSL_LS_SOC_MEM,
                          (BSL_META_U(unit,
                                      "Unknown parity module [bcount: %d][pcount: %d].\n"),
                                       bcount, pcount));
                return SOC_E_INTERNAL;
            }
            if (done) { 
                break;
            } else {
                str_type = parity_module_str[type];
            }
            /* NOTE: Do not use the field modify routine in the following as
                     some regs do not return the correct value due to which the
                     modify routine skips the write */
            if (SOC_REG_IS_64(unit, reg)) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_get(unit, reg, port, 0, &rval64));
                soc_reg64_field32_set(unit, reg, &rval64, field, enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, port, 0, rval64));
            } else {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, port, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, port, 0, rval));
            }
            if (ecc1b_reg != INVALIDr && ecc1b_field != INVALIDf) {
                if (SOC_REG_IS_64(unit, ecc1b_reg)) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_get(unit, ecc1b_reg, port, 0, &rval64));
                    soc_reg64_field32_set(unit, ecc1b_reg, &rval64, ecc1b_field, enable ? 1 : 0);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, ecc1b_reg, port, 0, rval64));
                } else {
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_get(unit, ecc1b_reg, port, 0, &rval));
                    soc_reg_field_set(unit, ecc1b_reg, &rval, ecc1b_field, enable ? 1 : 0);
                    if (20 == SOC_REG_ACC_TYPE(unit, ecc1b_reg)) {
                        int inst, pipe;
                        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
                            inst = pipe | SOC_REG_ADDR_INSTANCE_MASK;
                            SOC_IF_ERROR_RETURN
                                (soc_reg32_set(unit, ecc1b_reg, inst, 0, rval));
                        }
                    } else {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_set(unit, ecc1b_reg, port, 0, rval));
                    }
                }
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                      (BSL_META_U(unit,
                                  "SER enable for %s: %s\n"),
                                   str_type, str_name));
        }

        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = &_soc_td2_ser_route_blocks[rbi];
            cmic_bit = rb->cmic_bit;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == ser_block_info[bcount].blocktype) {
                /* New SER mechanism (except IP.IDB) */
                cmic_rval |= cmic_bit;
                if (rb->enable_reg != INVALIDr && rb->enable_field != INVALIDf) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, rb->enable_reg,
                            REG_PORT_ANY, rb->enable_field, enable ? 1 : 0));
                }
                if (rb->blocktype == SOC_BLK_IPIPE) {
                    _soc_td2p_ip_pipe_fifo_bmask[rb->pipe] |= cmic_bit;
                }
            }
        }

        /* reset (toggle) fifo if applicable */
        if (ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }

    /* TBD: The following looks exactly the same like for TD2 */

    /* Enable 1B error reporting for some special items */
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, CMIC_BUFFER_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LEARN_FIFO_1BIT_ERROR_REPORTf, enable ? 1 : 0));

    /* Loop through each place-and-route block entry to enable legacy style SER stuff */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (rb->info == NULL) {
            continue;
        }
        if (enable) {
            cmic_rval |= cmic_bit;
        }

        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (rb->enable_reg != INVALIDr) {
            if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block,
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                    /* This port block is not configured */
                    continue;
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->enable_reg, port, 0, &rval64));
        }

        /*Find physical port number for the specified port */
        /* coverity[negative_returns: FALSE] */
        phy_port = si->port_l2p_mapping[port];

        /*Find the group and slot according to the physical port*/
        cport = phy_port / _TD2_PORTS_PER_PGW;
        slot_port = (phy_port % _TD2_PORTS_PER_PGW) / _TD2_XLPS_PER_PGW;

        /*If PGW number is even, the xlports are positive sequence */
        if((cport % 2) == 0) {
            obm_slot = slot_port;
        }else{
            /*If PGW number is odd, the xlports are reverse sequence */
            obm_slot = 3 - slot_port;
        }

        switch (obm_slot) {
            case 0:
                rb->info[0].enable_reg = PGW_OBM0_ECC_ENABLEr;
                break;
            case 1:
                rb->info[0].enable_reg = PGW_OBM1_ECC_ENABLEr;
                break;
            case 2:
                rb->info[0].enable_reg = PGW_OBM2_ECC_ENABLEr;
                break;
            case 3:
                rb->info[0].enable_reg = PGW_OBM3_ECC_ENABLEr;
                break;
            default:
                break;
        }

        rv = _soc_trident2_ser_enable_info(unit, block_info_idx, rb->id, port,
                                           rb->enable_reg, &rval64,
                                           rb->info, INVALIDm, enable);
        if (rv == SOC_E_NOT_FOUND) {
            continue;
        } else if (SOC_FAILURE(rv)) {
            return rv;
        }

        if (rb->enable_reg != INVALIDr) {
            /* Write per route block parity enable register */
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rval64));
        }
    }

    if (enable) {
        /* MMU enables */
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0); /* 1 */
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0x1FFFFE));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval);
    } else {
        /* MMU disables */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0);
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0));
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}

#endif

STATIC int
_soc_trident2_ser_enable_cport(int unit, int inst, const _soc_td2_ser_info_t *info,
                               soc_mem_t mem, int enable)
{
    soc_reg_t port_reg;
    uint64 port_rval;
    int block_info_idx, port;

    port = -1;
    SOC_BLOCK_ITER(unit, block_info_idx, SOC_BLK_CPORT) {
        if (SOC_BLOCK_INFO(unit, block_info_idx).number == inst) {
            port = SOC_BLOCK_PORT(unit, block_info_idx);
            break;
        }
    }

    if (port < 0) {
        return SOC_E_NONE;
    }

    port_reg = info->enable_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, port_reg, port, 0, &port_rval));

    SOC_IF_ERROR_RETURN
        (_soc_trident2_ser_enable_info(unit, block_info_idx, inst, port,
                                       port_reg, &port_rval,
                                       info->info, mem, enable));

    SOC_IF_ERROR_RETURN(soc_reg_set(unit, port_reg, port, 0, port_rval));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_enable_mmu_1bit_ecc(int unit, int enable)
{
    int i, f;
    uint64 rval64;
    uint32 rval;
    soc_field_info_t *fieldp;
    soc_reg_info_t   *regp;
    soc_reg_t reg;
    
    soc_reg_t _1b_reg_list[] = {
        MMU_CCP_EN_COR_ERR_RPTr,
        MMU_CFAP_EN_COR_ERR_RPTr,
        MMU_DEQ_EN_COR_ERR_RPTr,
        MMU_ENQ_EN_COR_ERR_RPTr,
        MMU_EPRG_EN_COR_ERR_RPTr,
        INTFI_EN_COR_ERR_RPTr,
        ES_PIPE0_LLS_EN_COR_ERR_RPT_1r,
        ES_PIPE0_LLS_EN_COR_ERR_RPT_2r,
        ES_PIPE1_LLS_EN_COR_ERR_RPT_1r,
        ES_PIPE1_LLS_EN_COR_ERR_RPT_2r,
        MMU_PQE_EN_COR_ERR_RPTr,
        MMU_QCN_EN_COR_ERR_RPTr,
        RQE_EN_COR_ERR_RPTr,
        MMU_TDM_EN_COR_ERR_RPTr,
        THDI_EN_COR_ERR_RPTr,
        MMU_THDM_DB_EN_COR_ERR_RPTr,
        MMU_THDM_MCQE_EN_COR_ERR_RPTr,
        MMU_THDU_EN_COR_ERR_RPTr,
        MMU_TOQ_EN_COR_ERR_RPTr,
        HSP_EN_COR_ERR_RPTr
    };
    for (i = 0; i < COUNTOF(_1b_reg_list); i++) {
        reg = _1b_reg_list[i];
        regp = &(SOC_REG_INFO(unit, reg));
        if (SOC_REG_IS_64(unit, reg)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64));
            for (f = 0; f < regp->nFields; f++) {
                fieldp = &(regp->fields[f]);
                soc_reg64_field32_set(unit, reg, &rval64, fieldp->field,
                                      enable ? 1 : 0);
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, REG_PORT_ANY, 0, rval64));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            for (f = 0; f < regp->nFields; f++) {
                fieldp = &(regp->fields[f]);
                soc_reg_field_set(unit, reg, &rval, fieldp->field,
                                  enable ? 1 : 0);
            }
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                              soc_reg_t group_reg, uint64 *group_rval,
                              const _soc_td2_ser_info_t *info_list,
                              soc_mem_t mem, int enable)
{
    const _soc_td2_ser_info_t *info;
    int info_index, rv, rv1;
    soc_reg_t reg;
    uint32 rval;
    uint64 rval64;

    rv = SOC_E_NOT_FOUND;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        if (mem != INVALIDm && info->mem != mem) {
            continue;
        }

        rv = SOC_E_NONE;

        /* Enable the info entry in the group register */
        if (info->group_reg_enable_field != INVALIDf) {
            soc_reg64_field32_set(unit, group_reg, group_rval,
                                  info->group_reg_enable_field, enable ? 1 : 0);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_ECC:
            reg = info->enable_reg;
            if (!SOC_REG_IS_VALID(unit, reg)) {
                break;
            }
            if (SOC_REG_IS_64(unit, reg)) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_get(unit, reg, port, 0, &rval64));
                soc_reg64_field32_set(unit, reg, &rval64, info->enable_field,
                                      enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, port, 0, rval64));
            } else {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, port, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, info->enable_field,
                                  enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, port, 0, rval));
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
            break;
        case _SOC_PARITY_TYPE_CPORT:
            /* One more level of enable tree structure */
            rv1 = _soc_trident2_ser_enable_cport(unit, inst, info, mem, enable);
            if (SOC_FAILURE(rv1) && rv1 != SOC_E_NOT_FOUND) {
                return rv;
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
            rv1 = _soc_trident2_ser_enable_mmu_1bit_ecc(unit, enable);
            if (SOC_FAILURE(rv1) && rv1 != SOC_E_NOT_FOUND) {
                return rv;
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"), 
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
            break;
        case _SOC_PARITY_TYPE_GENERIC:
        case _SOC_PARITY_TYPE_START_ERR:
        case _SOC_PARITY_TYPE_BST:
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
        default:
            break;
        } /* Handle different parity error reporting style */
        if (mem != INVALIDm) {
            break;
        }

    } /* Loop through each info entry in the route block */

    return rv;
}

STATIC int
_soc_trident2_ser_enable_all(int unit, int enable)
{
    int         rv, block_info_idx;
    int         phy_port, cport, slot_port, obm_slot, port = REG_PORT_ANY;
    int         egress = 0;
    uint8       rbi, bcount;
    uint16      pcount;
    uint32      rval, cmic_bit, cmic_rval;
    uint64      rb_rval64;
    soc_reg_t   reg;
    soc_field_t field;
    const       _soc_td2_ser_route_block_t *rb;
    soc_info_t *si = &SOC_INFO(unit);
    

    if (SOC_IS_TRIDENT2PLUS(unit)) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        SOC_IF_ERROR_RETURN(_soc_trident2p_ser_enable_all ( unit, _soc_td2p_ser_block_info, enable ));
#endif
        return SOC_E_NONE;
    }

    SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_PCIE_IRQ_MASK2r(unit, &cmic_rval));

    /* Enable new fifo mechanism based SER stuff */
    for (bcount = 0; _soc_td2_ser_block_info[bcount].blocktype; bcount++) {
        for (pcount = 0;
             _soc_td2_ser_block_info[bcount].info[pcount].enable_reg != INVALIDr;
             pcount++) {
            reg = _soc_td2_ser_block_info[bcount].info[pcount].enable_reg;
            field = _soc_td2_ser_block_info[bcount].info[pcount].enable_field;

            if (SOC_BLK_IPIPE == _soc_td2_ser_block_info[bcount].blocktype) {
                egress = 0;
            } else {
                egress = 1;
            }
            
            /*set reg according to the acctype, prevent only set pipe x when acctype is 6*/
            soc_trident2_ser_enable_by_acctype(unit, reg, field, enable, egress);
            
            switch (_soc_td2_ser_block_info[bcount].info[pcount].type) {
            case 0:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for mem: %s\n"),
                             _soc_td2_ser_block_info[bcount].info[pcount].mem != INVALIDm ?
                             SOC_MEM_NAME(unit, _soc_td2_ser_block_info[bcount].info[pcount].mem) :
                             _soc_td2_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            case 1:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for reg: %s\n"),
                             _soc_td2_ser_block_info[bcount].info[pcount].reg != INVALIDr ?
                             SOC_REG_NAME(unit, _soc_td2_ser_block_info[bcount].info[pcount].reg) :
                             _soc_td2_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            case 2:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for bus: %s\n"),
                             _soc_td2_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            default: break;
            }
        }

        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = &_soc_td2_ser_route_blocks[rbi];
            cmic_bit = rb->cmic_bit;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == _soc_td2_ser_block_info[bcount].blocktype) {
                /* New SER mechanism */
                cmic_rval |= cmic_bit;
                if (rb->enable_reg != INVALIDr) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, rb->enable_reg,
                            REG_PORT_ANY, rb->enable_field, enable ? 1 : 0));
                }
            }
        }

        /* reset (toggle) fifo if applicable */
        if (_soc_td2_ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }
    
    /* Enable 1B error reporting for some special items */
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IPARS_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LPORT_TABLEf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IPARS_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, SRC_TRUNKf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, CMIC_BUFFER_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LEARN_FIFO_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, ICFG_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, PORT_TABLEf, enable ? 1 : 0));
    
    /* Loop through each place-and-route block entry to enable legacy style SER stuff */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (rb->info == NULL) {
            continue;
        }
        if (enable) {
            cmic_rval |= cmic_bit;
        }
        
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block, 
            SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                /* This port block is not configured */
                continue;
        }
        if (rb->blocktype == SOC_BLK_PGW_CL) {
            /*Find physical port number for the specified port */
            /* coverity[negative_returns: FALSE] */
            phy_port = si->port_l2p_mapping[port];

            /*Find the group and slot according to the physical port*/
            cport = phy_port / _TD2_PORTS_PER_PGW;
            slot_port = (phy_port % _TD2_PORTS_PER_PGW) / _TD2_XLPS_PER_PGW;

            /*If PGW number is even, the xlports are positive sequence */
            if((cport % 2) == 0) {
                obm_slot = slot_port;
            }else{
                /*If PGW number is odd, the xlports are reverse sequence */
                obm_slot = 3 - slot_port;
            }

            switch (obm_slot) {
                case 0:
                    rb->info[0].enable_reg = PGW_OBM0_ECC_ENABLEr;
                    break;
                case 1:
                    rb->info[0].enable_reg = PGW_OBM1_ECC_ENABLEr;
                    break;
                case 2:
                    rb->info[0].enable_reg = PGW_OBM2_ECC_ENABLEr;
                    break;
                case 3:
                    rb->info[0].enable_reg = PGW_OBM3_ECC_ENABLEr;
                    break;
                default:
                    break;
            }
        }

        SOC_IF_ERROR_RETURN
            (soc_reg_get(unit, rb->enable_reg, port, 0, &rb_rval64));        
        rv = _soc_trident2_ser_enable_info(unit, block_info_idx, rb->id, port,
                                           rb->enable_reg, &rb_rval64,
                                           rb->info, INVALIDm, enable);
        if (rv == SOC_E_NOT_FOUND) {
            continue;
        } else if (SOC_FAILURE(rv)) {
            return rv;
        }

        /* Write per route block parity enable register */
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, rb->enable_reg, port, 0, rb_rval64));
    }
    if (enable) {
        /* MMU enables */
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0); /* 1 */
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0x1FFFFE));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval);
    } else {
        /* MMU disables */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0);
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0));
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}

void 
_soc_trident2_mem_rename(soc_mem_t *memory)
{
    switch(*memory) {
        case EGR_FRAGMENT_ID_TABLE_Xm:
        case EGR_FRAGMENT_ID_TABLE_Ym:
            *memory = EGR_FRAGMENT_ID_TABLEm;
            break;
            
        case EFP_COUNTER_TABLE_Xm:
        case EFP_COUNTER_TABLE_Ym:
            *memory = EFP_COUNTER_TABLEm;
            break;
            
        case EGR_PERQ_XMT_COUNTERS_Xm:
        case EGR_PERQ_XMT_COUNTERS_Ym:
            *memory = EGR_PERQ_XMT_COUNTERSm;
            break;
            
        case EFP_METER_TABLE_Xm:
        case EFP_METER_TABLE_Ym:
            *memory = EFP_METER_TABLEm;
            break;
            
        case EGR_PW_INIT_COUNTERS_Xm:
        case EGR_PW_INIT_COUNTERS_Ym:
            *memory = EGR_PW_INIT_COUNTERSm;
            break;
            
        case FP_COUNTER_TABLE_Xm:
        case FP_COUNTER_TABLE_Ym:
            *memory = FP_COUNTER_TABLEm;
            break;

        case FP_STORM_CONTROL_METERS_Xm:
        case FP_STORM_CONTROL_METERS_Ym:
            *memory = FP_STORM_CONTROL_METERSm;
            break;
            
        case DLB_HGT_FLOWSET_Xm:
        case DLB_HGT_FLOWSET_Ym:
            *memory = DLB_HGT_FLOWSETm;
            break;

        case DLB_HGT_FLOWSET_TIMESTAMP_PAGE_Xm:
        case DLB_HGT_FLOWSET_TIMESTAMP_PAGE_Ym:
            *memory = DLB_HGT_FLOWSET_TIMESTAMP_PAGEm;
            break;
            
        case ING_PW_TERM_SEQ_NUM_Xm:
        case ING_PW_TERM_SEQ_NUM_Ym:
            *memory = ING_PW_TERM_SEQ_NUMm;
            break;

        default:
            break;
    }
}

STATIC int
soc_trident2_ser_enable_by_acctype(int unit, soc_reg_t reg, 
                                                soc_field_t field, int enable,
                                                int egress)
{
    uint32  flags = 0;
    uint32  rval = 0;
    int     port = REG_PORT_ANY;
    int     rv = SOC_E_NONE;
    
    flags = SOC_REG_ACC_TYPE(unit, reg);
    if (_SOC_ACC_TYPE_PIPE_SBS == flags) {
        IP_ARBITER_LOCK(unit);
        /*set pipe x*/
        soc_trident2_pipe_select(unit, egress, 0);
        rv = soc_reg32_get(unit, reg, port, 0, &rval);
        if (rv != SOC_E_NONE) {
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
        if (soc_reg_field_valid(unit, reg, field)) {
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
        }
        rv = soc_reg32_set(unit, reg, port, 0, rval);
        if (rv != SOC_E_NONE) {
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
        
        /*set pipe y*/
        soc_trident2_pipe_select(unit, egress, 1);
        rv = soc_reg32_get(unit, reg, port, 0, &rval);
        if (rv != SOC_E_NONE) {
            soc_trident2_pipe_select(unit, egress, 0);
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
        if (soc_reg_field_valid(unit, reg, field)) {
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
        }
        rv = soc_reg32_set(unit, reg, port, 0, rval);
        if (rv != SOC_E_NONE) {
            soc_trident2_pipe_select(unit, egress, 0);
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
    
        soc_trident2_pipe_select(unit, egress, 0);
        IP_ARBITER_UNLOCK(unit);
    } else {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));
        if (soc_reg_field_valid(unit, reg, field)) {
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, rval));
    }

    return rv;
}

int
soc_trident2_mem_parity_control(int unit, soc_mem_t mem, int copyno, 
                                            int enable)
{
    int             bcount = 0;
    int             pcount = 0;
    int             egress = 0;
    int             rv = SOC_E_NONE;
    uint8           rbi = 0;
    uint32          rval = 0;
    uint32          cmic_rval = 0;
    soc_reg_t       reg;
    soc_field_t     field;
    const _soc_td2_ser_route_block_t *rb;

    _soc_trident2_mem_rename(&mem);
    
    SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_PCIE_IRQ_MASK2r(unit, &cmic_rval));
    
    for (bcount = 0; _soc_td2_ser_block_info[bcount].blocktype; bcount++) {
        for (pcount = 0; 
            _soc_td2_ser_block_info[bcount].info[pcount].enable_reg != INVALIDr;
            pcount++) {
            if (_soc_td2_ser_block_info[bcount].info[pcount].mem == mem) {
                reg = _soc_td2_ser_block_info[bcount].info[pcount].enable_reg;
                field = _soc_td2_ser_block_info[bcount].info[pcount].enable_field;

                if (SOC_BLK_IPIPE == _soc_td2_ser_block_info[bcount].blocktype) {
                    egress = 0;
                } else {
                    egress = 1;
                }

                /*set reg according to the acctype, prevent only set pipe x when acctype is 6*/
                rv = soc_trident2_ser_enable_by_acctype(unit, reg, field, enable, egress);
                if (SOC_FAILURE(rv)) {
                    return rv;
                }
            }
        }
        
        if (_soc_td2_ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }

    if ((rv == SOC_E_NONE) &&
        (SOC_BLOCK_TYPE(unit, SOC_MEM_BLOCK_ANY(unit, mem))) == SOC_BLK_MMU) {
        /* MMU controls */      
        for (rbi = 0; ; rbi++) {
            rb = &_soc_td2_ser_route_blocks[rbi];
            if (rb->cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == SOC_BLK_MMU) {
                cmic_rval |= rb->cmic_bit;
            }
        }
        
        if (enable) {
            /* MMU enables */
            /* TD-3384 */
            SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0); /* 1 */
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0x1FFFFE));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 0);
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 1);
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
            (void)soc_cmicm_intr2_enable(unit, cmic_rval);
        } else {
            /* MMU disables */
            SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0);
            /* TD-3384 */
            SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0));
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            (void)soc_cmicm_intr2_disable(unit, cmic_rval);
        }
    }

    return rv;
}

STATIC int
_soc_trident2_clear_mmu_memory(int unit, soc_mem_t mem)
{
    int i, count;
    static soc_mem_t mmu_mems[] = {
        MMU_INTFI_XPIPE_FC_MAP_TBL2m,
        MMU_INTFI_YPIPE_FC_MAP_TBL2m
    };

    count = COUNTOF(mmu_mems);
    /* MMU mem clear to avoid SER issue */
    for (i = 0; i < count; i++) {
        if (mem != INVALIDm) {
            if (mem == mmu_mems[i]) {
                SOC_IF_ERROR_RETURN
                    (soc_mem_clear(unit, mmu_mems[i], COPYNO_ALL, TRUE));
                break;
            }
        } else {
            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, mmu_mems[i], COPYNO_ALL, TRUE));
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_mmu_init_default_val(int unit)
{
    soc_mem_t           mem0, mem1;
    uint32              entry[SOC_MAX_MEM_WORDS];
    int                 index, unused_idx;

    /* Set LLS_Port memory. Point to Un-used L0 node.*/
    mem0 = ES_PIPE0_LLS_PORT_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_PORT_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 267;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }

    /* Set LLS_L0 memory. Point to Un-used L1 node.*/
    mem0 = ES_PIPE0_LLS_L0_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_L0_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 1023;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }

    /* Set LLS_L1 memory. Point to Un-used L2 child.*/
    mem0 = ES_PIPE0_LLS_L1_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_L1_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 1479;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_LIST_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_LIST_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }
    return SOC_E_NONE;
}

int
_soc_trident2_mem_ser_control(int unit, soc_mem_t mem, int copyno,
                              int enable)
{
    if (enable) {
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, TOP_SOFT_RESET_REGr,
                                           REG_PORT_ANY, TOP_MMU_RST_Lf, 0));
        sal_usleep(1000);
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, TOP_SOFT_RESET_REGr,
                                           REG_PORT_ANY, TOP_MMU_RST_Lf, 1));
        sal_usleep(1000);
    }
    if (soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        SOC_IF_ERROR_RETURN(_soc_trident2_clear_mmu_memory(unit, INVALIDm));
        SOC_IF_ERROR_RETURN(_soc_trident2_ser_enable_all(unit, enable));
    }
    if (enable) {
        SOC_IF_ERROR_RETURN
            (_soc_trident2_mmu_init_default_val(unit));
    }
    return SOC_E_NONE;
}

STATIC void
_soc_td2_mem_parity_info(int unit, int block_info_idx, int pipe,
                         soc_field_t field_enum, uint32 *minfo)
{
    *minfo = (SOC_BLOCK2SCH(unit, block_info_idx) << SOC_ERROR_BLK_BP)
        | ((pipe & 0xff) << SOC_ERROR_PIPE_BP)
        | (field_enum & SOC_ERROR_FIELD_ENUM_MASK);
}

STATIC int
_soc_trident2_mem_is_dyn(int unit, soc_mem_t mem)
{
    if (SOC_MEM_FIELD_VALID(unit, mem, HITf) ||
        SOC_MEM_FIELD_VALID(unit, mem, HIT0f) ||
        SOC_MEM_FIELD_VALID(unit, mem, HIT_0f) ||
        SOC_MEM_FIELD_VALID(unit, mem, HITDA_0f) ||
        SOC_MEM_FIELD_VALID(unit, mem, HITSA_0f) ||
        SOC_MEM_FIELD_VALID(unit, mem, HITSAf) ||
        SOC_MEM_FIELD_VALID(unit, mem, HITDAf) ||
        SOC_MEM_FIELD_VALID(unit, mem, B0_HITf) ||
        SOC_MEM_FIELD_VALID(unit, mem, B1_HITf)) {
        return 1;
    }
    return 0;
}

STATIC int
_soc_td2_populate_ser_log(int unit, soc_reg_t parity_enable_reg,
                          soc_field_t parity_enable_field,
                          soc_mem_t mem,
                          int mem_block,
                          soc_acc_type_t acc_type,
                          int index,
                          sal_usecs_t detect_time,
                          uint32 sblk,
                          uint32 address)
{
    uint32 tmp_entry[SOC_MAX_MEM_WORDS];
    int log_entry_size, id, entry_dw;
    uint32 *cache;
    uint8 *vmap;
    soc_ser_log_tlv_memory_t log_mem;
    soc_ser_log_tlv_generic_t log_generic;

    sal_memset(&log_generic, 0, sizeof(log_generic));
    sal_memset(&log_mem, 0, sizeof(log_mem));

    /*
    must be large enough for at least generic and terminator, as well as the
    memory type since we might decode it in soc_ser_correction.
    */
    log_entry_size = sizeof(soc_ser_log_tlv_hdr_t)*3 +
                     sizeof(soc_ser_log_tlv_generic_t) +
                     sizeof(soc_ser_log_tlv_memory_t);

    if (mem == INVALIDm) {
        mem = soc_addr_to_mem_extended(unit, sblk, acc_type, address);
        if (mem != INVALIDm) {
            if (sblk) {
                SOC_MEM_BLOCK_ITER(unit, mem, mem_block) {
                    if (SOC_BLOCK2OFFSET(unit, mem_block) == sblk) {
                        break;
                    }
                }
            } else {
                mem_block = SOC_MEM_BLOCK_ANY(unit, mem);
            }
        }
    }
    /*
    If we have decoded the memory we can record its contents/cache
    */
    if((mem != INVALIDm) &&
       (SOC_MEM_SER_CORRECTION_TYPE(unit, mem) != SOC_MEM_FLAG_SER_SPECIAL) &&
       (SOC_MEM_SER_CORRECTION_TYPE(unit, mem) != 0)) {
        entry_dw = soc_mem_entry_words(unit, mem);

        /* Check to make sure this isn't a duplicate */
        /* Search for a log entry with the same mem, and index with within the last 5 seconds */
        if (soc_ser_log_find_recent(unit, mem, index, sal_time_usecs()) > 0) {
            return 0;
        }

        log_entry_size += sizeof(soc_ser_log_tlv_hdr_t) + entry_dw*4;

        cache = SOC_MEM_STATE(unit, mem).cache[mem_block];
        vmap = SOC_MEM_STATE(unit, mem).vmap[mem_block];
        if(cache != NULL && CACHE_VMAP_TST(vmap, index)) {
            log_entry_size += sizeof(soc_ser_log_tlv_hdr_t) + entry_dw*4;
        }

        /* create the entry based on determined size, save id */
        id = soc_ser_log_create_entry(unit, log_entry_size);

        /* Add the memory information to the log now so we can detect duplicate errors */
        log_generic.time = detect_time;
        log_mem.memory = mem;
        log_mem.index = index;
        soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_MEMORY,
            sizeof(soc_ser_log_tlv_memory_t), &log_mem);
        soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_GENERIC,
            sizeof(soc_ser_log_tlv_generic_t), &log_generic);

        /* Disable Parity */
        if (!_soc_trident2_mem_is_dyn(unit, mem) &&
            (parity_enable_reg != INVALIDr) &&
            (parity_enable_field != INVALIDf)) {
            if (soc_reg_field32_modify(unit, parity_enable_reg,
                REG_PORT_ANY, parity_enable_field, 0) < 0) {
                return 0;
            }
        }

        /* Make sure the pipe is set correctly */
        soc_trident2_pipe_select(unit, TRUE,
            (acc_type == _SOC_ACC_TYPE_PIPE_Y ? 1 : 0));
        soc_trident2_pipe_select(unit, FALSE,
            (acc_type == _SOC_ACC_TYPE_PIPE_Y ? 1 : 0));

        /* read the memory into a buffer */
        if (acc_type == _SOC_ACC_TYPE_PIPE_Y) {
            soc_mem_pipe_select_read(unit, SOC_MEM_NO_FLAGS, mem, mem_block,
                                     acc_type, index, tmp_entry);
        } else {
            /*Enable NACK on read */
             soc_mem_read_extended(unit, SOC_MEM_SCHAN_ERR_RETURN,
                                   mem, 0, mem_block,
                                   index, tmp_entry);
        }

        /* Make sure the pipe is set correctly */
        soc_trident2_pipe_select(unit, TRUE, 0);
        soc_trident2_pipe_select(unit, FALSE, 0);

        /* Enable Parity */
        if (!_soc_trident2_mem_is_dyn(unit, mem) &&
            (parity_enable_reg != INVALIDr) &&
            (parity_enable_field != INVALIDf)) {
            if (soc_reg_field32_modify(unit, parity_enable_reg,
                REG_PORT_ANY, parity_enable_field, 1) < 0) {
                return 0;
            }
        }

        /* fill in the memory contents tlv */
        if (soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_CONTENTS,
            entry_dw*4, tmp_entry) < 0) {
            return 0;
        }


        if(cache != NULL && CACHE_VMAP_TST(vmap, index)) {
            /* fill in the memory cache tlv */
            if (soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_CACHE,
                entry_dw*4, (cache + index*entry_dw)) < 0) {
                return 0;
            }
        }
    } else {
        id = soc_ser_log_create_entry(unit, log_entry_size);
    }

    return id;
}

STATIC int
_soc_trident2_ser_process_parity(int unit, int block_info_idx, int pipe, int port,
                                 const _soc_td2_ser_info_t *info,
                                 int schan, char *prefix_str, char *mem_str)
{
    int rv;
    _soc_td2_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci;

    if (schan) {
        /* Some table does not have NACK register */
        return SOC_E_NONE;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            _soc_td2_mem_parity_info(unit, block_info_idx, pipe,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                               entry_idx, minfo);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s entry %d parity error\n"),
                       prefix_str, mem_str_ptr, entry_idx));
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple parity errors\n"),
                           prefix_str, mem_str_ptr));
            }
            if (idx == 0 && info->mem != INVALIDm) {
                sal_memset(&spci, 0, sizeof(spci));
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN | SOC_SER_LOG_WRITE_CACHE;
                if (multiple) {
                    spci.flags |= SOC_SER_ERR_MULTI;
                }
                spci.reg = INVALIDr;
                spci.mem = info->mem;
                spci.blk_type = -1;
                spci.index = entry_idx;
                spci.parity_type = info->type;
                spci.detect_time = sal_time_usecs();
                spci.log_id = _soc_td2_populate_ser_log(unit,
                                          info->enable_reg,
                                          info->enable_field,
                                          spci.mem,
                                          SOC_MEM_BLOCK_ANY(unit, spci.mem),
                                          spci.acc_type,
                                          spci.index,
                                          spci.detect_time,
                                          spci.sblk,
                                          spci.addr);
                rv = soc_ser_correction(unit, &spci);
                if (spci.log_id != 0) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                       SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                       spci.log_id, 0);
                }
                if (SOC_FAILURE(rv)) {
                    /* Add reporting failed to correct event flag to
                     * application */
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                            SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                            entry_idx, minfo);
                    return rv;
                }
            }
        }

        /* Clear parity status */
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, 0));
    }

    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s parity hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_ecc(int unit, int block_info_idx, int pipe, int port,
                              const _soc_td2_ser_info_t *info,
                              int schan, char *prefix_str, char *mem_str)
{
    int rv;
    _soc_td2_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 minfo;
    uint64 rval64;
    uint32 multiple, double_bit, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci;

    if (schan) {
        /* Some table does not have NACK register */
        return SOC_E_NONE;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN
            (soc_reg_get(unit, reg, port, 0, &rval64));

        if (soc_reg64_field32_get(unit, reg, rval64, ECC_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg64_field32_get(unit, reg, rval64, MULTIPLE_ERRf);
            double_bit = soc_reg64_field32_get(unit, reg, rval64, DOUBLE_BIT_ERRf);
            entry_idx = soc_reg64_field32_get(unit, reg, rval64, ENTRY_IDXf);
            _soc_td2_mem_parity_info(unit, block_info_idx, pipe,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                               entry_idx, minfo);
            sal_memset(&spci, 0, sizeof(spci));
            if (double_bit) {
                spci.double_bit = 1;
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d double-bit ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
            }
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple ECC errors\n"),
                           prefix_str, mem_str_ptr));
            }
            if (idx == 0 && info->mem != INVALIDm) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN | SOC_SER_LOG_WRITE_CACHE;
                if (multiple) {
                    spci.flags |= SOC_SER_ERR_MULTI;
                }
                spci.reg = INVALIDr;
                spci.mem = info->mem;
                spci.blk_type = -1;
                spci.index = entry_idx;
                spci.parity_type = info->type;
                spci.detect_time = sal_time_usecs();
                spci.log_id = _soc_td2_populate_ser_log(unit,
                                          info->enable_reg,
                                          info->enable_field,
                                          spci.mem,
                                          SOC_MEM_BLOCK_ANY(unit, spci.mem),
                                          spci.acc_type,
                                          spci.index,
                                          spci.detect_time,
                                          spci.sblk,
                                          spci.addr);
                rv = soc_ser_correction(unit, &spci);
                if (spci.log_id != 0) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                       SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                       spci.log_id, 0);
                }
                if (SOC_FAILURE(rv)) {
                    /* Add reporting failed to correct event flag to
                     * application */
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                            SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                            entry_idx, minfo);
                    return rv;
                }
            }
        }

        /* Clear parity status */
        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, reg, port, 0, rval64));
    }

    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_mmu_err(int unit, int block_info_idx,
                                  const _soc_td2_ser_info_t *info,
                                  char *prefix_str)
{
    uint32 rval, err, addr, bidx;
    uint64 rval64;
    soc_reg_t reg = MMU_MEM_FAIL_ADDR_64r;
    uint8 blk_idx;
    uint32 sblk = 0;
    int rv = SOC_E_NONE;
    _soc_ser_correct_info_t spci;
    
    SOC_IF_ERROR_RETURN(READ_MEM_SER_FIFO_STSr(unit, &rval));
    if (soc_reg_field_get(unit, MEM_SER_FIFO_STSr, rval, EMPTYf)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU SER interrupt with empty fifo !!\n"),
                              unit));
        SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_STATr(unit, &rval));
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU ERR status: 0x%08x\n"), unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_MEM_FAIL_INT_STATr(unit, 0));
        return rv;
    }
    SOC_BLOCK_ITER(unit, blk_idx, SOC_BLK_MMU) {
        sblk = SOC_BLOCK2SCH(unit, blk_idx);
        break;
    }
    do {
        SOC_IF_ERROR_RETURN(READ_MMU_MEM_FAIL_ADDR_64r(unit, &rval64));
        err = soc_reg64_field32_get(unit, reg, rval64, ERR_TYPEf);
        addr = soc_reg64_field32_get(unit, reg, rval64, EADDRf);
        bidx = soc_reg64_field32_get(unit, reg, rval64, BIDXf);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU ERR Type: %s, Addr: 0x%08x, module: %d\n"),
                              unit, (err == 1) ? "1B error" : "2B error", addr, bidx));
        /* Address reported in MMU_MEM_FAIL_ADDR_64 is the entry offset within 
         * MMU sub block. The complete Sbus address is composed of MMU sub block 
         * base address and offset within MMU sub block address space.
         */
        addr = (bidx << 26) | addr;
        sal_memset(&spci, 0, sizeof(spci));
        spci.flags |= SOC_SER_SRC_MEM;
        spci.reg = INVALIDr;
        spci.mem = INVALIDm;
        spci.blk_type = SOC_BLK_MMU;
        spci.sblk = sblk;
        spci.detect_time = sal_time_usecs();
        
        /* Try to decode memory */
        spci.mem = soc_addr_to_mem_extended(unit, sblk, _SOC_ACC_TYPE_PIPE_ANY, addr);
        if (spci.mem != INVALIDm) {
            spci.index = addr - soc_mem_base(unit, spci.mem);
            spci.flags |= SOC_SER_REG_MEM_KNOWN;
        } else {
            spci.flags |= SOC_SER_REG_MEM_UNKNOWN;
        }
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, addr);
        spci.flags |= SOC_SER_LOG_WRITE_CACHE;
        spci.log_id = _soc_td2_populate_ser_log(unit, INVALIDr, INVALIDf,
                                                spci.mem, blk_idx,
                                                _SOC_ACC_TYPE_PIPE_ANY, spci.index,
                                                spci.detect_time, spci.sblk,
                                                spci.addr);
 
        if ((spci.mem == INVALIDm) || 
            (SOC_MEM_SER_CORRECTION_TYPE(unit, spci.mem) != 0)) {            
            rv = soc_ser_correction(unit, &spci);
            if (SOC_FAILURE(rv)) {
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                   SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                   sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, addr);
            }
        } else {
            rv = SOC_E_NONE;
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_AUTO_CORRECTED,
                               sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, addr);
        }
        
        if (spci.log_id != 0) {
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_LOG, 
                               spci.log_id, 0);
        }
        SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_CTRr(unit, &rval));
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU ERR ctr: %d\n"), unit, rval));
        SOC_IF_ERROR_RETURN(READ_MEM_SER_FIFO_STSr(unit, &rval));
    } while (!soc_reg_field_get(unit, MEM_SER_FIFO_STSr, rval, EMPTYf));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, info->intr_status_reg, REG_PORT_ANY,
                                info->group_reg_status_field, 0));
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, MEM_FAIL_INT_CLEARr, REG_PORT_ANY,
                                    info->group_reg_status_field, 1));
    }
#endif
    return rv;
}

STATIC int
_soc_trident2_ser_process_start_err(int unit, int block_info_idx,
                                    const _soc_td2_ser_info_t *info,
                                    char *prefix_str)
{
    soc_info_t *si;
    uint64 rval64;
    uint32 pbmp_31_0, pbmp_63_32, pbmp_96_64, pbmp_116_97;
    soc_pbmp_t pbmp;
    uint32 minfo;
    int port, mmu_port, phy_port;
    soc_ser_log_tlv_generic_t log_generic;
    int log_id;

    sal_memset(&log_generic, 0, sizeof(soc_ser_log_tlv_generic_t));

    si = &SOC_INFO(unit);

    /* mmu port 52-0 */
    SOC_IF_ERROR_RETURN(READ_START_BY_START_ERROR_0r(unit, &rval64));
    pbmp_31_0 = COMPILER_64_LO(rval64);
    pbmp_63_32 = COMPILER_64_HI(rval64);
    /* mmu port 116-64 */
    SOC_IF_ERROR_RETURN(READ_START_BY_START_ERROR_1r(unit, &rval64));
    pbmp_96_64 = COMPILER_64_LO(rval64);
    pbmp_116_97 = COMPILER_64_HI(rval64);
    SOC_PBMP_CLEAR(pbmp);
    SOC_PBMP_WORD_SET(pbmp, 0, pbmp_31_0);
    SOC_PBMP_WORD_SET(pbmp, 1, pbmp_63_32);
    SOC_PBMP_WORD_SET(pbmp, 2, pbmp_96_64);
    SOC_PBMP_WORD_SET(pbmp, 3, pbmp_116_97);

    SOC_PBMP_ITER(pbmp, mmu_port) {
        phy_port = si->port_m2p_mapping[mmu_port];
        port = si->port_p2l_mapping[phy_port];
        _soc_td2_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        /* Report uncorrectable event flag to application */
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_UNCORRECTABLE, 0,
                           minfo);

        log_generic.time = sal_time_usecs();
        log_generic.boot_count = soc_ser_log_get_boot_count(unit);
        log_generic.block_type = SOC_BLOCK_INFO(unit, block_info_idx).type;
        log_generic.parity_type = info->type;

        log_id = soc_ser_log_create_entry(unit,
            sizeof(soc_ser_log_tlv_generic_t) +
            sizeof(soc_ser_log_tlv_hdr_t) *2);

        soc_ser_log_add_tlv(unit, log_id, SOC_SER_LOG_TLV_GENERIC,
            sizeof(soc_ser_log_tlv_generic_t), &log_generic);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_LOG, log_id, 0);

        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s port %d start error detected\n"), prefix_str,
                              port));
    }

    /* Clear parity status */
    COMPILER_64_ZERO(rval64);
    SOC_IF_ERROR_RETURN(WRITE_START_BY_START_ERROR_0r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_START_BY_START_ERROR_1r(unit, rval64));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_process_ser(int unit, int block_info_idx, int inst, int pipe,
                          int port, soc_reg_t group_reg, uint64 group_rval,
                          const _soc_td2_ser_info_t *info_list,
                          char *prefix_str);
STATIC int
_soc_trident2_ser_process_cport(int unit, int inst, int pipe,
                                const _soc_td2_ser_info_t *info)
{
    soc_reg_t port_reg;
    uint64 port_rval;
    int block_info_idx, port;
    char prefix_str[24];

    if (info->intr_status_reg == INVALIDr) {
        return SOC_E_NONE;
    }

    port = -1;
    SOC_BLOCK_ITER(unit, block_info_idx, SOC_BLK_CPORT) {
        if (SOC_BLOCK_INFO(unit, block_info_idx).number == inst) {
            port = SOC_BLOCK_PORT(unit, block_info_idx);
            break;
        }
    }
    if (port < 0) {
        return SOC_E_NONE;
    }

    port_reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, port_reg, port, 0, &port_rval));
    if (COMPILER_64_IS_ZERO(port_rval)) {
        return SOC_E_NONE;
    }

    sal_sprintf(prefix_str, "unit %d CPORT%d", unit, inst);
    SOC_IF_ERROR_RETURN
        (_soc_trident2_process_ser(unit, block_info_idx, inst, pipe, port,
                                   port_reg, port_rval, info->info, prefix_str));

    return SOC_E_NONE;
}

STATIC _soc_td2_bst_hw_cb td2_bst_cb;

STATIC int
_soc_td2_process_mmu_bst(int unit)
{
    int rv = SOC_E_NONE;
    if (td2_bst_cb) {
        rv = td2_bst_cb(unit);
    }
    return rv;
}

int soc_td2_set_bst_callback(int unit, _soc_td2_bst_hw_cb cb)
{
    td2_bst_cb = cb;
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_process_ser(int unit, int block_info_idx, int inst, int pipe,
                          int port, soc_reg_t group_reg, uint64 group_rval,
                          const _soc_td2_ser_info_t *info_list,
                          char *prefix_str)
{
    const _soc_td2_ser_info_t *info;
    int info_index;
    char *mem_str;
    uint32 minfo;
    soc_ser_log_tlv_generic_t log_generic;
    int log_id;

    sal_memset(&log_generic, 0, sizeof(soc_ser_log_tlv_generic_t));

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Check status for the info entry in the group register */
        if (!soc_reg64_field32_get(unit, group_reg, group_rval,
                                   info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_GENERIC:
            _soc_td2_mem_parity_info(unit, block_info_idx, 0,
                                     info->group_reg_status_field, &minfo);
            /* Report uncorrectable event flag to application */
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_UNCORRECTABLE, 0,
                               minfo);

            log_generic.time = sal_time_usecs();
            log_generic.boot_count = soc_ser_log_get_boot_count(unit);
            log_generic.block_type = SOC_BLOCK_INFO(unit, block_info_idx).type;
            log_generic.parity_type = info->type;

            log_id = soc_ser_log_create_entry(unit,
                sizeof(soc_ser_log_tlv_generic_t) +
                sizeof(soc_ser_log_tlv_hdr_t) *2);

            soc_ser_log_add_tlv(unit, log_id, SOC_SER_LOG_TLV_GENERIC,
                sizeof(soc_ser_log_tlv_generic_t), &log_generic);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_LOG, log_id, 0);

            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s asserted\n"), prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_parity(unit, block_info_idx,
                                                  pipe, port, info, FALSE,
                                                  prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_ecc(unit, block_info_idx, pipe,
                                               port, info, FALSE,
                                               prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_CPORT:
            /* One more level of report tree structure */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_cport(unit, inst, pipe, info));
            break;
        case _SOC_PARITY_TYPE_START_ERR:
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_start_err(unit, block_info_idx,
                                                     info, prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_mmu_err(unit, block_info_idx,
                                                   info, prefix_str));
            break;
        case _SOC_PARITY_TYPE_BST:
            SOC_IF_ERROR_RETURN(_soc_td2_process_mmu_bst(unit));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}

STATIC char *_soc_td2_ser_hwmem_base_info[] = {
    "CMIC PKT BUFFER - In Iarb",
    "CPU PKT BUFFER - In Iarb",
    "Invalid value",
    "EINITBUF_PACKET_BUFFER - In Iarb",
    "INGRESS PACKET BUFFER - In Ipars",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "EP MPB DATA - In El3",
    "EP INITBUF - In Ehcpm",
    "CM DATA BUFFER - In Edatabuf",
    "XLP0 DATA BUFFER - In Edatabuf",
    "XLP1 DATA BUFFER - In Edatabuf",
    "XLP2 DATA BUFFER - In Edatabuf",
    "XLP3 DATA BUFFER - In Edatabuf",
    "XLP4 DATA BUFFER - In Edatabuf",
    "XLP5 DATA BUFFER - In Edatabuf",
    "XLP6 DATA BUFFER - In Edatabuf",
    "XLP7 DATA BUFFER - In Edatabuf",
    "XLP8 DATA BUFFER - In Edatabuf",
    "XLP9 DATA BUFFER - In Edatabuf",
    "XLP10 DATA BUFFER - In Edatabuf",
    "XLP11 DATA BUFFER - In Edatabuf",
    "XLP12 DATA BUFFER - In Edatabuf",
    "XLP13 DATA BUFFER - In Edatabuf",
    "XLP14 DATA BUFFER - In Edatabuf",
    "XLP15 DATA BUFFER - In Edatabuf",
    "CLP0 DATA BUFFER - In Edatabuf",
    "CLP1 DATA BUFFER - In Edatabuf",
    "CLP2 DATA BUFFER - In Edatabuf",
    "CLP3 DATA BUFFER - In Edatabuf",
    "XLP RESI0 DATA BUFFER - In Edatabuf",
    "XLP RESI1 DATA BUFFER - In Edatabuf",
    "XLP RESI2 DATA BUFFER - In Edatabuf",
    "XLP RESI3 DATA BUFFER - In Edatabuf",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "XLP0 EDB CTRL BUFFER - In Edatabuf",
    "XLP1 EDB CTRL BUFFER - In Edatabuf",
    "XLP2 EDB CTRL BUFFER - In Edatabuf",
    "XLP3 EDB CTRL BUFFER - In Edatabuf",
    "XLP4 EDB CTRL BUFFER - In Edatabuf",
    "XLP5 EDB CTRL BUFFER - In Edatabuf",
    "XLP6 EDB CTRL BUFFER - In Edatabuf",
    "XLP7 EDB CTRL BUFFER - In Edatabuf",
    "XLP8 EDB CTRL BUFFER - In Edatabuf",
    "XLP9 EDB CTRL BUFFER - In Edatabuf",
    "XLP10 EDB CTRL BUFFER - In Edatabuf",
    "XLP11 EDB CTRL BUFFER - In Edatabuf",
    "XLP12 EDB CTRL BUFFER - In Edatabuf",
    "XLP13 EDB CTRL BUFFER - In Edatabuf",
    "XLP14 EDB CTRL BUFFER - In Edatabuf",
    "XLP15 EDB CTRL BUFFER - In Edatabuf",
    "CLP0 EDB CTRL BUFFER - In Edatabuf",
    "CLP1 EDB CTRL BUFFER - In Edatabuf",
    "CLP2 EDB CTRL BUFFER - In Edatabuf",
    "CLP3 EDB CTRL BUFFER - In Edatabuf",
    "LEARN FIFO - In IARB",
    "EGR VLAN BUS",
    "EGR HCPM BUS",
    "EGR PMOD BUS",
    "EGR FPPARS BUS",
    "EFP BUS",
    "IVP BUS",
    "ICFG BUS",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "IPARS BUS",
    "IVXLT BUS",
    "IMPLS BUS",
    "IL2L3 BUS",
    "Invalid value",
    "IFP BUS",
    "IRSEL1 BUS",
    "ISW1 BUS",
    "IRSEL2 BUS"
};

#define _SOC_TD2_SER_REG 1
#define _SOC_TD2_SER_MEM 0

STATIC void
_soc_trident2_print_ser_fifo_details(int unit, uint8 regmem, soc_block_t blk, 
                                     uint32 sblk, int pipe, uint32 address, 
                                     uint32 stage, uint32 base, uint32 index, 
                                     uint32 hwmbase, uint32 type, uint8 drop, 
                                     uint8 non_sbus)
{
    uint32 hwmbase_max = 0;
    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityError, unit)) {
        switch (type) {
        case 0:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SOP cell.\n")));
            break;
        case 1:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: MOP cell.\n")));
            break;
        case 2:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: EOP cell.\n")));
            break;
        case 3:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SBUS transaction.\n")));
            break;
        case 4:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: miscellaneous transaction.\n")));
            break;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid error reported !!\n")));
            break;
        }
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Blk: %d, Pipe: %d, Address: 0x%08x, base: 0x%x, stage: %d, index: %d\n"),
                              sblk, pipe, address, base, stage, index));
        if (regmem == _SOC_TD2_SER_MEM) {
            if (hwmbase >= 0x80) {
                hwmbase -= 0x38; /* handle the gap */
            }
            if (non_sbus) {
                hwmbase_max = sizeof(_soc_td2_ser_hwmem_base_info)/sizeof(_soc_td2_ser_hwmem_base_info[0]);
                /* coverity[overrun-local] */
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Mem hwbase: 0x%x [%s]\n"), hwmbase,
                                      (hwmbase < hwmbase_max) ? _soc_td2_ser_hwmem_base_info[hwmbase] : "--"));
            }
        }
        if (drop) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "SER caused packet drop.\n")));
        }
    }
}

#define IF_IPEP_SBS_CTRL_LOCK(_unit_) \
        IP_ARBITER_LOCK(_unit_);\
        if ((mem == EGR_SER_FIFOm) && (pipe != 0)) { \
            (void)soc_trident2_pipe_select(unit, TRUE, 1); \
        }

#define IF_IPEP_SBS_CTRL_UNLOCK(_unit_) \
        if ((mem == EGR_SER_FIFOm) && (pipe != 0)) { \
            (void)soc_trident2_pipe_select(unit, TRUE, 0); \
        } \
        IP_ARBITER_UNLOCK(_unit_)

STATIC uint32
_soc_trident2_flex_ctr_addr_check(int unit, uint32 address, soc_block_t blk,
                                  uint32 stage, uint32 index)
{
    uint32 index2 = index;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        if ((SOC_BLK_IPIPE == blk) && (21 == stage)) {
            switch (address & 0xfffff000) {
            /* ING_FLEX_CTR_OFFSET_TABLE_*m */
            case 0x56800000:
            case 0x56801000:
            case 0x56802000:
            case 0x56803000:
            case 0x56840000:
            case 0x56841000:
            case 0x56842000:
            case 0x56843000:
                index2 = address & 0x3ff; break; /* 1K depth */
            /* ING_FLEX_CTR_COUNTER_TABLE_*m */
            case 0x56804000:
            case 0x56808000:
            case 0x5680c000:
            case 0x56810000:
            case 0x56844000:
            case 0x56848000:
            case 0x5684c000:
            case 0x56850000:
                index2 = address & 0xfff; break; /* 4K depth */
            default:
                break;
            }
        }
    } else
#endif
    {
        if ((blk == SOC_BLK_IPIPE) && (stage == 17)) {
            switch (address & 0XFFFFF000) {
            case 0x46800000:
            case 0x46801000:
            case 0x46802000:
            case 0x46803000:
            case 0x46840000:
            case 0x46841000:
            case 0x46842000:
            case 0x46843000:
                index2 = address & 0x3ff; break; /* 1K depth */
            case 0x46804000:
            case 0x46808000:
            case 0x4680c000:
            case 0x46810000:
            case 0x46844000:
            case 0x46848000:
            case 0x4684c000:
            case 0x46850000:
                index2 = address & 0xfff; break; /* 4K depth */
            default:
                break;
            }
        }
    }
    if ((SOC_BLK_EPIPE == blk) && (10 == stage)) {
        switch (address & 0XFFFFF000) {
        case 0x2a800000:
        case 0x2a801000:
        case 0x2a802000:
        case 0x2a803000:
            index2 = address & 0x3ff; break; /* 1K depth */
        case 0x2a804000:
        case 0x2a808000:
        case 0x2a80c000:
        case 0x2a810000:
            index2 = address & 0xfff; break; /* 4K depth */
        default:
            break;
        }
    }
    return index2;
}

STATIC int
_soc_trident2_process_ser_fifo(int unit, soc_block_t blk, int pipe, char *prefix_str)
{
    int i, rv;
    uint8 bidx;
    soc_mem_t mem;
    char blk_str[10];
    int *acc_type_ptr;
    soc_reg_t reg = INVALIDr;
    _soc_ser_correct_info_t spci;
    _soc_td2_fifo_ser_info_t* ser_info_table = NULL;
    soc_reg_t parity_enable_reg = INVALIDr;
    soc_field_t parity_enable_field = INVALIDf;
    /* There are a few tables in TD2 (like is ING_NEXT_HOP, L2MC, L3_IPMC),
     * whose physical implementation is only one copy. They are written through
     * the X-pipe. Type 1 in Y-pipe list covers memories of this structure.
     */
    static int acc_type1[] = { 3, 2, 6, 4, 1, 0, -1 };
    static int acc_type0[] = { 1, 3, 6, 4, 0, -1 };
    uint32 reg_val, mask, entry[SOC_MAX_MEM_WORDS];
    uint32 stage = 0, addrbase = 0, index = 0, hwmbase = 0, type = 0;
    uint32 sblk = 0, regmem = 0, non_sbus = 0, drop = 0, ecc_parity = 0, address = 0;


    switch (blk) {
    case SOC_BLK_IPIPE:
        mem = pipe ? ING_SER_FIFO_Ym : ING_SER_FIFO_Xm;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            mask = _soc_td2p_ip_pipe_fifo_bmask [ pipe ];
        } else {
            mask = pipe ? 0x15540 : 0xAAA0; /* All IP bits based upon pipe */ 
        }
#else
        mask = pipe ? 0x15540 : 0xAAA0; /* All IP bits based upon pipe */ 
#endif
        ser_info_table = _soc_td2_ip_ser_info;
        sal_sprintf(blk_str, "IPIPE");
        break;
    case SOC_BLK_EPIPE:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            mem = EGR_SER_FIFOm;
        } else {
            mem = pipe ? EGR_SER_FIFO_Ym : EGR_SER_FIFO_Xm;
        }
#else
        mem = pipe ? EGR_SER_FIFO_Ym : EGR_SER_FIFO_Xm;
#endif
        mask = 0x00000001; /* SER_FIFO_NON_EMPTYf */
        reg = EGR_INTR_STATUSr;
        ser_info_table = _soc_td2_ep_ser_info;
        sal_sprintf(blk_str, "EPIPE");
        break;
    default:
        return SOC_E_PARAM;
    }

    IF_IPEP_SBS_CTRL_LOCK(unit);
    do {
        rv = soc_mem_pop(unit, mem, MEM_BLOCK_ANY, entry);
        if (rv != SOC_E_NONE) {
            IF_IPEP_SBS_CTRL_UNLOCK(unit);
        }
        SOC_IF_ERROR_RETURN(rv);
        /* process entry */
        if (soc_mem_field32_get(unit, mem, entry, VALIDf)) {
            ecc_parity = soc_mem_field32_get(unit, mem, entry, ECC_PARITYf);
            regmem = soc_mem_field32_get(unit, mem, entry, MEM_TYPEf);
            address = soc_mem_field32_get(unit, mem, entry, ADDRESSf);
            stage = soc_mem_field32_get(unit, mem, entry, PIPE_STAGEf);
            type = soc_mem_field32_get(unit, mem, entry, INSTRUCTION_TYPEf);
            drop = soc_mem_field32_get(unit, mem, entry, DROPf);
            SOC_BLOCK_ITER(unit, bidx, blk) {
                sblk = SOC_BLOCK2SCH(unit, bidx);
                break;
            }
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s\n"), prefix_str));
            if (soc_mem_field32_get(unit, mem, entry, MULTIPLEf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Multiple: ")));
            }
            if (regmem == _SOC_TD2_SER_REG) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Reg: ")));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Mem: ")));
            }
            spci.double_bit = 0;
            switch (ecc_parity) {
            case 0:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Parity error..\n")));
                break;
            case 1:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Corrected single bit ECC error..\n")));
                break;
            case 2:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Double or Multiple bit ECC error..\n")));
                spci.double_bit = 1;
                break;
            default:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid SER issue !!\n")));

                IF_IPEP_SBS_CTRL_UNLOCK(unit);
                return SOC_E_INTERNAL;
            }
            if (regmem == _SOC_TD2_SER_MEM) {
                /* process mem */
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, MEMBASEf);
                index = soc_mem_field32_get(unit, mem, entry, MEMINDEXf);
                hwmbase = soc_mem_field32_get(unit, mem, entry, HWMEMBASEf);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                if (SOC_IS_TRIDENT2PLUS(unit)){
                    if ((blk == SOC_BLK_IPIPE) && (stage == 9 || stage == 13)) {
                        /* Mems in these stages in IPIPE have more than 
                         * 256k indexes */
                        index |= hwmbase << 18;
                        hwmbase = addrbase = 0;
                    }
                } else 
#endif
                {
                    if ((blk == SOC_BLK_IPIPE) &&
                        (stage == 7 ||stage == 8 || stage == 11)) {
                        /* Mems in these stages in IPIPE have more than 
                         * 256k indexes */
                        index |= hwmbase << 18;
                        hwmbase = addrbase = 0;
                    }
                }
                index = _soc_trident2_flex_ctr_addr_check(unit, address, blk,
                                                          stage, index);
                if (non_sbus == 0) {
                    acc_type_ptr = pipe ? acc_type1 : acc_type0;
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_MEM;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.pipe_num = pipe;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address - index;
                    spci.index = index;
                    spci.stage = stage;
                    spci.detect_time = sal_time_usecs();

                    /* Try to decode mem first */
                    for (i = 0; acc_type_ptr[i] != -1; i++) {
                        spci.mem = soc_addr_to_mem_extended(unit,
                                    spci.sblk, acc_type_ptr[i], spci.addr);

                        if (spci.mem != INVALIDm) {
                            break;
                        }
                    }

                    if (spci.mem != INVALIDm) {
                        spci.acc_type = acc_type_ptr[i];
                        spci.flags |= SOC_SER_REG_MEM_KNOWN; 
                        spci.index = soc_trident2_mem_index_remap(unit, spci.mem, index);
                    }
                    else {
                        /* Invalid mem, use the first acc_type_ptr*/
                        spci.acc_type = acc_type_ptr[0];
                        spci.flags |= SOC_SER_REG_MEM_UNKNOWN;
                    }

                    if (spci.mem != INVALIDm) {
                        _soc_trident2_ser_control_reg_get(ser_info_table, 
                            spci.mem, 
                            &parity_enable_reg, 
                            &parity_enable_field);
                    }
                    
                    spci.flags |= SOC_SER_LOG_WRITE_CACHE;
                    spci.log_id = _soc_td2_populate_ser_log(unit,
                                              parity_enable_reg,
                                              parity_enable_field,
                                              spci.mem,
                                              bidx,
                                              spci.acc_type,
                                              spci.index,
                                              spci.detect_time,
                                              spci.sblk,
                                              spci.addr);

                    rv = soc_ser_correction(unit, &spci);
                    if (spci.log_id != 0) {
                        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                           SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                           spci.log_id, 0);
                    }
                    if (SOC_FAILURE(rv)) {
                        if (rv != SOC_E_NOT_FOUND) {
                            IF_IPEP_SBS_CTRL_UNLOCK(unit);
                            /* Add reporting failed to correct event flag to
                             * application */
                            soc_event_generate(unit,
                                    SOC_SWITCH_EVENT_PARITY_ERROR,
                                    SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                    sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                    SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                            return rv;
                        }
                    }
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER mem address un-accessable !!\n"), blk_str));
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            } else {
                /* process reg */
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, REGBASEf);
                index = soc_mem_field32_get(unit, mem, entry, REGINDEXf);
                if (non_sbus == 0) {
                    acc_type_ptr = pipe ? acc_type1 : acc_type0;
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 1, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, 0, type, 
                                                         drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_UNKNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address;
                    spci.index = index;
                    spci.stage = stage;
                    spci.detect_time = sal_time_usecs();
                    for (i = 0; acc_type_ptr[i] != -1; i++) {
                        spci.acc_type = acc_type_ptr[i];
                        spci.log_id = soc_ser_log_create_entry(unit,
                            sizeof(soc_ser_log_tlv_generic_t) +
                            sizeof(soc_ser_log_tlv_register_t) +
                            sizeof(soc_ser_log_tlv_hdr_t) *3);
                        rv = soc_ser_correction(unit, &spci);
                        if (spci.log_id != 0) {
                            soc_event_generate(unit,
                                               SOC_SWITCH_EVENT_PARITY_ERROR,
                                               SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                               spci.log_id, 0);
                        }
                        if (SOC_FAILURE(rv)) {
                            if (rv == SOC_E_NOT_FOUND) {
                                continue;
                            }
                            IF_IPEP_SBS_CTRL_UNLOCK(unit);
                            /* Add reporting failed to correct event flag to
                             * application */
                            soc_event_generate(unit,
                                    SOC_SWITCH_EVENT_PARITY_ERROR,
                                    SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                    sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                    SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                            return rv;
                        }
                        break;
                    }
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER reg address un-accessable !!\n"), blk_str));
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d Got invalid mem pop from %s !!\n"),
                                  unit, SOC_MEM_NAME(unit, mem)));
        }
        /* check if any more pending */
        if (reg == INVALIDr) {
            rv = READ_CMIC_CMC0_IRQ_STAT2r(unit, &reg_val);
        } else {
            rv = soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &reg_val);
        }
        if (rv != SOC_E_NONE) {
            IF_IPEP_SBS_CTRL_UNLOCK(unit);
        }
        SOC_IF_ERROR_RETURN(rv);
    } while (reg_val & mask);
    IF_IPEP_SBS_CTRL_UNLOCK(unit);
    return SOC_E_NONE;
}

STATIC void
_soc_trident2_ser_control_reg_get(CONST _soc_td2_fifo_ser_info_t *fifo_ser_list,
                                        soc_mem_t   mem,
                                        soc_reg_t   *ser_control_reg,
                                        soc_field_t *ser_enable_field)
{
    int i;

    if ((fifo_ser_list == NULL) || (ser_control_reg == NULL) || 
        (ser_enable_field == NULL)) {
        return;
    }

    for (i = 0; fifo_ser_list[i].enable_reg != INVALIDr; i++) {
        if (fifo_ser_list[i].mem == mem) {
            *ser_control_reg = fifo_ser_list[i].enable_reg;
            *ser_enable_field = fifo_ser_list[i].enable_field;
            break;
        }
    }

    return;
}


STATIC int
_soc_trident2_ser_process_all(int unit)
{
    uint8      rbi;
    int        port = REG_PORT_ANY;
    uint32     cmic_rval, cmic_bit;
    uint64     rb_enable64, rb_rval64, tmp64;
    const      _soc_td2_ser_route_block_t *rb;
    char       prefix_str[10];
    int        block_info_idx;
    soc_stat_t *stat = SOC_STAT(unit);

    sal_sprintf(prefix_str, "Unit: %d \n", unit);

    /* Read CMIC parity status register */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT2r(unit, &cmic_rval));
    if (cmic_rval == 0) {
        return SOC_E_NONE;
    }
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (!(cmic_rval & cmic_bit)) {
            /* No interrupt bit asserted for the route block */
            continue;
        }
        if (rb->blocktype == SOC_BLK_IPIPE || rb->blocktype == SOC_BLK_EPIPE) {
            /* New fifo style processing */
            (void)_soc_trident2_process_ser_fifo(unit, rb->blocktype, rb->pipe, prefix_str);
            stat->ser_err_fifo++;
        } else {
            /* Legacy processing */
            SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                    port = SOC_BLOCK_PORT(unit, block_info_idx);
                    break;
                }
            }
            if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block, 
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                    /* This port block is not configured */
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d SER error on disabled port block %d !!\n"),
                                          unit, block_info_idx));
                    sal_usleep(SAL_BOOT_QUICKTURN ? 10000000 : 1000000); /* Don't reenable too soon */
                    continue;
            }
            /* Read per route block parity status register */
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->status_reg, port, 0, &rb_rval64));
            if (COMPILER_64_IS_ZERO(rb_rval64)) {
                continue;
            }
            SOC_IF_ERROR_RETURN
                (_soc_trident2_process_ser(unit, block_info_idx, rb->id, rb->pipe,
                                           port, rb->status_reg, rb_rval64,
                                           rb->info, prefix_str));
            
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->enable_reg, port, 0, &rb_enable64));
            COMPILER_64_SET(tmp64, COMPILER_64_HI(rb_rval64), COMPILER_64_LO(rb_rval64));
            COMPILER_64_NOT(tmp64);
            COMPILER_64_AND(rb_enable64, tmp64);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rb_enable64));
            COMPILER_64_OR(rb_enable64, rb_rval64);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rb_enable64));
            
            stat->ser_err_int++;
        }
    }
    return SOC_E_NONE;
}



STATIC void
soc_trident2_ser_error(void *unit_vp, void *d1, void *d2, void *d3,
                       void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    (void)_soc_trident2_ser_process_all(unit);
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr2_enable(unit, PTR_TO_INT(d2));
    }
    /* soc_intr_enable(unit, IRQ_MEM_FAIL); */
}

/* SER processing for TCAMs */
static _soc_generic_ser_info_t _soc_td2_tcam_ser_info_template[] = {
    /* HW SER engine protection */
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ  |
      _SOC_SER_FLAG_SIZE_VERIFY},
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y |
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ  |
      _SOC_SER_FLAG_SIZE_VERIFY},
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y |
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 165}, {1, 165}, {166, 329}, {167, 329} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_1BIT,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 165}, {1, 165}, {166, 329}, {167, 329} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { ING_SNATm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { ING_SNATm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 105}, {1, 105}, {106, 210}, {107, 210} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { IP_MULTICAST_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { IP_MULTICAST_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},

    /* SW memscan SER engine protection */
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 436}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE | _SOC_SER_FLAG_OVERLAY},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 436}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE | _SOC_SER_FLAG_OVERLAY |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { FP_GM_FIELDSm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 330}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE |
      _SOC_SER_FLAG_OVERLAY | _SOC_SER_FLAG_OVERLAY_CASE},
    { FP_GM_FIELDSm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 330}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE |
      _SOC_SER_FLAG_OVERLAY | _SOC_SER_FLAG_OVERLAY_CASE |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { UDF_CONDITIONAL_CHECK_TABLE_CAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { UDF_CONDITIONAL_CHECK_TABLE_CAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    { MY_STATION_TCAM_2m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { MY_STATION_TCAM_2m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { SUBPORT_TAG_SGPP_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 32}, {1, 32}, {33, 64}, {34, 64} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { SUBPORT_TAG_SGPP_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 32}, {1, 32}, {33, 64}, {34, 64} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
#endif
    { INVALIDm },
};

static _soc_generic_ser_info_t *_soc_td2_tcam_ser_info[SOC_MAX_NUM_DEVICES];

#ifdef BCM_TRIDENT2PLUS_SUPPORT
STATIC int
_soc_trident2_tcam_idx_get(soc_mem_t mem)
{
    int idx;
    for (idx = 0; idx < COUNTOF(_soc_td2_tcam_ser_info_template); idx++) {
        if (_soc_td2_tcam_ser_info_template[idx].mem == mem) {
            break;
        }
    }
    return idx;
}

#define _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, table_index, section_index, start, end) \
    _soc_td2_tcam_ser_info[unit][table_index].start_end_bits[section_index].start_bit = start; \
    _soc_td2_tcam_ser_info[unit][table_index].start_end_bits[section_index].end_bit = end; \
    _soc_td2_tcam_ser_info[unit][table_index + 1].start_end_bits[section_index].start_bit = start; \
    _soc_td2_tcam_ser_info[unit][table_index + 1].start_end_bits[section_index].end_bit = end;
#endif

STATIC int
_soc_trident2_tcam_ser_init(int unit)
{
    int alloc_size;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int override_idx = 0;
#endif
    /* First, make per-unit copy of the master TCAM list */
    alloc_size = sizeof(_soc_td2_tcam_ser_info_template);
    if (NULL == _soc_td2_tcam_ser_info[unit]) {
        if ((_soc_td2_tcam_ser_info[unit] =
             sal_alloc(alloc_size, "td2 tcam list")) == NULL) {
            return SOC_E_MEMORY;
        }
    }
    /* Make a fresh copy of the TCAM template info */
    sal_memcpy(_soc_td2_tcam_ser_info[unit],
               &(_soc_td2_tcam_ser_info_template),
               alloc_size);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (!SOC_IS_TRIDENT2PLUS(unit)) {
        /* MY_STATION_TCAM_2m exists in TD2_PLUS, not in TD2,
         * set it to INVALIDm for TD2. */
        override_idx = _soc_trident2_tcam_idx_get(MY_STATION_TCAM_2m);
        _soc_td2_tcam_ser_info[unit][override_idx].mem = INVALIDm;
    }
    
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        /* override start and end bit for IP_MULTICAST_TCAMm */
        override_idx = _soc_trident2_tcam_idx_get(IP_MULTICAST_TCAMm);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 1, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 145, 288);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 146, 288);
        
        /* override start and end bit for L3_DEFIPm */
        override_idx = _soc_trident2_tcam_idx_get(L3_DEFIPm);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 97);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 1, 97);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 98, 193);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 99, 193);
        
        /* override start and end bit for L3_DEFIP_PAIR_128m */
        override_idx = _soc_trident2_tcam_idx_get(L3_DEFIP_PAIR_128m);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 99);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 100, 195);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 196, 291);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 292, 387);
        
        /* override start and end bit for CPU_COS_MAPm */
        override_idx = _soc_trident2_tcam_idx_get(CPU_COS_MAPm);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 1, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 145, 288);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 146, 288);
    }
#endif    
    return soc_generic_ser_init(unit, _soc_td2_tcam_ser_info[unit]);
}

STATIC void
soc_trident2_ser_fail(int unit)
{
    soc_generic_ser_process_error(unit, _soc_td2_tcam_ser_info[unit],
                                  _SOC_PARITY_TYPE_SER);
}

static soc_mem_t *_soc_td2_alpm_bkt_view_map[SOC_MAX_NUM_DEVICES];

#ifdef ALPM_ENABLE
int
soc_trident2_alpm_scrub(int unit)
{
    int ipv6;                   /* Iterate over ipv6 only flag. */
    int idx;                    /* Iteration index.             */
    int tmp_idx;                /* ipv4 entries iterator.       */
    int alloc_size;             /* Allocation size.             */
    int tbl_size;               /* HW table size.               */
    int rv = SOC_E_FAIL;        /* Operation return status.     */
    char *lpm_tbl_ptr = NULL;   /* Dma table pointer.           */
    int vrf, vrf_id, step_count;
    int idx_end, bkt_idx, bkt_ptr = 0, bkt_addr;
    int bank_num = 0, entry_num = 0, entry_count, bank_count;
    void *alpm_entry;
    uint32 rval;
    soc_mem_t alpm_mem;
    defip_entry_t *lpm_entry;   /* Hw entry buffer.             */
    defip_pair_128_entry_t *lpm_128_entry; /* Hw entry buffer.  */
    defip_alpm_ipv4_entry_t alpm_entry_v4;
    defip_alpm_ipv6_64_entry_t alpm_entry_v6_64;
    defip_alpm_ipv6_128_entry_t alpm_entry_v6_128;

    SOC_IF_ERROR_RETURN(READ_L3_DEFIP_RPF_CONTROLr(unit, &rval));
    if (0 == soc_reg_field_get(unit, L3_DEFIP_RPF_CONTROLr, rval, LPM_MODEf)) {
        return (SOC_E_NONE);
    }

    /* DMA the LPM table to software copy. Calculate table size. */
    tbl_size =  soc_mem_index_count(unit, L3_DEFIPm);
    if (!tbl_size) {
        return (SOC_E_NONE);
    }
    alloc_size = tbl_size * sizeof(defip_entry_t);

    /* Allocate memory buffer. */
    lpm_tbl_ptr = soc_cm_salloc(unit, alloc_size, "lpm scrub");
    if (lpm_tbl_ptr == NULL) {
        return (SOC_E_MEMORY);
    }

    /* Reset allocated buffer. */
    sal_memset(lpm_tbl_ptr, 0, alloc_size);

    /* Read table to the buffer. */
    if (soc_mem_read_range(unit, L3_DEFIPm, MEM_BLOCK_ANY,
                           soc_mem_index_min(unit, L3_DEFIPm),
                           soc_mem_index_max(unit, L3_DEFIPm), lpm_tbl_ptr) < 0) {
        soc_cm_sfree(unit, lpm_tbl_ptr);
        return (SOC_E_INTERNAL);
    }

    if (SOC_URPF_STATUS_GET(unit)) {
        tbl_size >>= 1;
    }

    idx_end = tbl_size;

    if (soc_reg_field_get(unit, L3_DEFIP_RPF_CONTROLr, rval, LOOKUP_MODEf)) {
        /* parallel search mode */
        if (SOC_URPF_STATUS_GET(unit)) {
            bank_count = 2;
        } else {
            bank_count = 4;
        }
    } else {
        bank_count = 4;
    }

    /* Walk all lpm entries */
    for (idx = 0; idx < idx_end; idx++) {
        /* Calculate entry offset */
        lpm_entry =
            soc_mem_table_idx_to_pointer(unit, L3_DEFIPm,
                                         defip_entry_t *, lpm_tbl_ptr, idx);

        ipv6 = soc_mem_field32_get(unit, L3_DEFIPm, lpm_entry, MODE0f);

        /* Each LPM index has two IPv4 entries */
        for (tmp_idx = 0; tmp_idx < 2; tmp_idx++) {

            if (tmp_idx) {  /* If index == 1*/
                if (ipv6) {
                    /* IPv6 LPM index has only one entry, skip processing */
                    continue;
                } else {
                    /* Copy upper half of lpm entry to lower half */
                    soc_alpm_lpm_ip4entry1_to_0(unit, lpm_entry, lpm_entry, TRUE);
                }
            }

            /* Make sure entry is valid. */
            if (!soc_L3_DEFIPm_field32_get(unit, lpm_entry, VALID0f)) {
                continue;
            }

            /* Get VRF */
            if (SOC_FAILURE(soc_alpm_lpm_vrf_get
                            (unit, lpm_entry, &vrf_id, &vrf))) {
                goto free_lpm_table;
            }

            /* VRF_OVERRIDE (Global High) entries, prefix resides in TCAM */
            if (vrf_id == SOC_L3_VRF_OVERRIDE) {
                continue;
            }

            if (ipv6 && tmp_idx) {
                bkt_ptr++;
            } else {
                bkt_ptr = soc_mem_field32_get(unit, L3_DEFIPm, lpm_entry,
                                              ALG_BKT_PTR0f);
            }

            if (ipv6) {
                /* IPv6 */
                alpm_mem    = L3_DEFIP_ALPM_IPV6_64m;
                alpm_entry  = &alpm_entry_v6_64;
                entry_count = 4;
            } else {
                /* IPv4 */
                alpm_mem    = L3_DEFIP_ALPM_IPV4m;
                alpm_entry  = &alpm_entry_v4;
                entry_count = 6;
            }

            entry_num = 0;
            bank_num = 0;

            /* Get the bucket pointer from lpm entry */
            for (bkt_idx = 0; bkt_idx < (entry_count * bank_count); bkt_idx++) {
                /* Calculate bucket memory address */
                /* Increment so next bucket address can be calculated */
                bkt_addr = (entry_num << 16) | (bkt_ptr << 2) |
                           (bank_num & 0x3);
                entry_num++;
                if (entry_num == entry_count) {
                    entry_num = 0;
                    bank_num++;
                    if (bank_num == bank_count) {
                        bank_num = 0;
                    }
                }

                /* Read entry from bucket memory */
                if (SOC_FAILURE(soc_mem_read(unit, alpm_mem, MEM_BLOCK_ANY,
                                             bkt_addr, alpm_entry))) {
                    goto free_lpm_table;
                }
                if (SOC_URPF_STATUS_GET(unit)) {
                    /* Read the other copy */
                    if (SOC_FAILURE(soc_mem_read(unit, alpm_mem, MEM_BLOCK_ANY,
                                                 _soc_alpm_rpf_entry(unit, bkt_addr),
                                                 alpm_entry))) {
                        goto free_lpm_table;
                    }
                }
            } /* End of bucket walk loop*/
        } /* End of lpm entry upper/lower half traversal */
    } /* End of lpm table traversal */
    soc_cm_sfree(unit, lpm_tbl_ptr);

    /* DMA the LPM_PAIR_128 table to software copy. Calculate table size. */
    tbl_size =  soc_mem_index_count(unit, L3_DEFIP_PAIR_128m);
    if (!tbl_size) {
        return (SOC_E_NONE);
    }
    alloc_size = tbl_size * sizeof(defip_pair_128_entry_t);

    /* Allocate memory buffer. */
    lpm_tbl_ptr = soc_cm_salloc(unit, alloc_size, "lpm scrub");
    if (lpm_tbl_ptr == NULL) {
        return (SOC_E_MEMORY);
    }

    /* Reset allocated buffer. */
    sal_memset(lpm_tbl_ptr, 0, alloc_size);

    /* Read table to the buffer. */
    if (soc_mem_read_range(unit, L3_DEFIP_PAIR_128m, MEM_BLOCK_ANY,
                           soc_mem_index_min(unit, L3_DEFIP_PAIR_128m),
                           soc_mem_index_max(unit, L3_DEFIP_PAIR_128m), lpm_tbl_ptr) < 0) {
        soc_cm_sfree(unit, lpm_tbl_ptr);
        return (SOC_E_INTERNAL);
    }

    /* bkt_count = ALPM_IPV6_128_BKT_COUNT; ?? */

    if (SOC_URPF_STATUS_GET(unit)) {
        tbl_size >>= 1;
        /* bucket size halves for parallel search mode */
        if (soc_alpm_mode_get(unit)) {
            /* bkt_count >>= 1; ?? */
        }
    }

    idx_end = tbl_size;
    entry_count = 2;
    alpm_entry = &alpm_entry_v6_128;

    if (SOC_ALPM_V6_SCALE_CHECK(unit, 1)) {
        step_count = 2;
    } else {
        step_count = 1;
    }

    /* Walk all lpm_pair_128 entries */
    for (idx = 0; idx < idx_end; idx++) {
        /* Calculate entry ofset. */
        lpm_128_entry =
            soc_mem_table_idx_to_pointer(unit, L3_DEFIP_PAIR_128m,
                                         defip_pair_128_entry_t *, lpm_tbl_ptr, idx);

        /* Each lpm entry contains upto 24 IPV4 entries. Check all */
        for (tmp_idx = 0; tmp_idx < step_count; tmp_idx++) {

            /* Make sure entry is valid. */
            if (!soc_mem_field32_get(unit, L3_DEFIP_PAIR_128m, lpm_128_entry,
                                     VALID0_LWRf)) {
                continue;
            }

            /* Get VRF */
            if (SOC_FAILURE(soc_alpm_128_lpm_vrf_get
                            (unit, lpm_128_entry, &vrf_id, &vrf))) {
                goto free_lpm_table;
            }

            /* VRF_OVERRIDE (Global High) entries, prefix resides in TCAM */
            if (vrf_id == SOC_L3_VRF_OVERRIDE) {
                continue;
            }

            if (tmp_idx) {
                bkt_ptr++;
            } else {
                bkt_ptr = soc_mem_field32_get(unit, L3_DEFIP_PAIR_128m, lpm_128_entry,
                                              ALG_BKT_PTRf);
            }

            entry_num = 0;
            bank_num = 0;

            /* Get the bucket pointer from lpm entry */
            for (bkt_idx = 0; bkt_idx < (entry_count * bank_count); bkt_idx++) {
                /* Calculate bucket memory address */
                /* Increment so next bucket address can be calculated */
                bkt_addr = (entry_num << 16) | (bkt_ptr << 2) |
                           (bank_num & 0x3);
                entry_num++;
                if (entry_num == entry_count) {
                    entry_num = 0;
                    bank_num++;
                    if (bank_num == bank_count) {
                        bank_num = 0;
                    }
                }

                /* Read entry from bucket memory */
                if (SOC_FAILURE(soc_mem_read(unit, L3_DEFIP_ALPM_IPV6_128m,
                                MEM_BLOCK_ANY, bkt_addr, alpm_entry))) {
                    goto free_lpm_table;
                }
                if (SOC_URPF_STATUS_GET(unit)) {
                    /* Read the other copy */
                    if (SOC_FAILURE(soc_mem_read(unit, L3_DEFIP_ALPM_IPV6_128m,
                                                 MEM_BLOCK_ANY,
                                                 _soc_alpm_rpf_entry(unit, bkt_addr),
                                                 alpm_entry))) {
                        goto free_lpm_table;
                    }
                }
            } /* End of bucket walk loop*/
        } /* End of lpm entry upper/lower half traversal */
    } /* End of lpm table traversal */

    rv = SOC_E_NONE;

free_lpm_table:
    soc_cm_sfree(unit, lpm_tbl_ptr);

    return (rv);
}
#endif /* ALPM_ENABLE */


STATIC int
soc_bcm56830_mem_config(int unit)
{
    soc_persist_t *sop;
    int         index_max;
    
    sop = SOC_PERSIST(unit);

    index_max = 23;
    sop->memState[TRUNK_GROUPm].index_max = index_max;
    sop->memState[TRUNK_BITMAPm].index_max = index_max;
    sop->memState[TRUNK_CBL_TABLEm].index_max = index_max;


    sop->memState[L2MCm].index_max = 8191;

    return SOC_E_NONE;
}

STATIC int
soc_bcm56834_mem_config(int unit)
{
    soc_persist_t *sop;
    int         index_max;
    
    sop = SOC_PERSIST(unit);

    index_max = 47;
    sop->memState[TRUNK_GROUPm].index_max = index_max;
    sop->memState[TRUNK_BITMAPm].index_max = index_max;
    sop->memState[TRUNK_CBL_TABLEm].index_max = index_max;


    sop->memState[L2MCm].index_max = 8191;

    return SOC_E_NONE;
}

int
soc_trident2_mem_config(int unit)
{
    soc_persist_t *sop;
    int l2_entries, cfg_l2_entries, shared_l2_banks;
    int l3_entries, cfg_l3_entries, shared_l3_banks;
    int alpm_enable;
    int num_ecmp_rh_flowset_entries;
    int shared_bank_size;
    int max_l2_entries;
    int max_l3_entries;
    int num_ipv6_128b_entries = 0;
    int config_v6_entries = 0;
    int defip_config = 0;
    uint16              dev_id;
    uint8               rev_id;

    sop = SOC_PERSIST(unit);

    /* TRIDENT2:
     * bank 0-1 are dedicated L2 banks (16k entries per bank)
     * bank 6-9 are dedicated L3 banks (4k entries per bank)
     * bank 2-5 are shared banks (64k entres per bank)
     * These dedicated/shared banks can be configured to one of the following
     * mode:
     *     mode 0: 288k L2 (bank 0-5),  16k L3 (bank 6-9),   no ALPM (default)
     *     mode 1: 224k L2 (bank 0-4),  80k L3 (bank 5-9),   no ALPM
     *     mode 2: 160k L2 (bank 0-3), 144k L3 (bank 4-9),   no ALPM
     *     mode 3:  96k L2 (bank 0-2), 208k L3 (bank 3-9),   no ALPM
     *     mode 4:  32k L2 (bank 0-1),  16k L3 (bank 6-9), 128k ALPM (bank 2-5)
     *
     * TRIDENT2+:
     * bank 0-1 are dedicated L2 banks (16k entries per bank)
     * bank 6-9 are dedicated L3 banks (4k entries per bank)
     * bank 2-5 are shared banks (64 or 128k entres per bank)
     * These dedicated/shared banks can be configured to one of the following
     * mode:
     *     mode 0: 544k L2 (bank 0-5),  16k L3 (bank 6-9),   no ALPM (default)
     *     mode 1: 416k L2 (bank 0-4), 144k L3 (bank 5-9),   no ALPM
     *     mode 2: 288k L2 (bank 0-3), 272k L3 (bank 4-9),   no ALPM
     *     mode 3: 160k L2 (bank 0-2), 400k L3 (bank 3-9),   no ALPM
     *     mode 4:  32k L2 (bank 0-1),  16k L3 (bank 6-9), 128k ALPM (bank 2-5)
     */

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    if (SOC_IS_TRIDENT2PLUS(unit)) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        shared_bank_size = soc_td2p_get_shared_bank_size (unit, dev_id, rev_id);
#endif
    } else {
        shared_bank_size = 64;
    }
    max_l2_entries = 32 + shared_bank_size * 4;
    max_l3_entries = 16 + shared_bank_size * 3;

    cfg_l2_entries = soc_property_get(unit, spn_L2_MEM_ENTRIES, -1);
    l2_entries = cfg_l2_entries == -1 ? max_l2_entries * 1024 : cfg_l2_entries;

    if ((dev_id == BCM56830_DEVICE_ID) || 
        ((dev_id == BCM56834_DEVICE_ID) && (l2_entries > 160 * 1024))) { 
        l2_entries = 160 * 1024;
    }

    if (l2_entries <= 32 * 1024) { /* 32k dedicated L2 entries */
        l2_entries = 32 * 1024;
        shared_l2_banks = 0;
    } else if (l2_entries <= max_l2_entries * 1024) {
        l2_entries -= 32 * 1024;
        shared_l2_banks = (l2_entries + (shared_bank_size * 1024 - 1)) / (shared_bank_size * 1024);
        l2_entries = 32 * 1024 + shared_l2_banks * shared_bank_size * 1024;
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "The specified l2_mem_entries (%d) exceeds 288K\n"),
                 cfg_l2_entries));
        return SOC_E_PARAM;
    }

    cfg_l3_entries = soc_property_get(unit, spn_L3_MEM_ENTRIES, -1);
    l3_entries = cfg_l3_entries == -1 ? 16384 : cfg_l3_entries;
    if (l3_entries <= 16 * 1024) { /* 16k dedicated L3 entries */
        l3_entries = 16 * 1024;
        shared_l3_banks = 0;
    } else if (l3_entries <= max_l3_entries * 1024) {
        l3_entries -= 16 * 1024;
        shared_l3_banks = (l3_entries + (shared_bank_size * 1024 - 1)) / (shared_bank_size * 1024);
        l3_entries = 16 * 1024 + shared_l3_banks * shared_bank_size * 1024;
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "The specified l3_mem_entries (%d) exceeds 208K\n"),
                 cfg_l3_entries));
        return SOC_E_PARAM;
    }

    alpm_enable = soc_property_get(unit, spn_L3_ALPM_ENABLE, 0);

    if (alpm_enable) {
        if (shared_l2_banks + shared_l3_banks != 0) {
            LOG_CLI((BSL_META_U(unit,
                                "Shared banks can not be used for L2 or L3 when "
                                "ALPM is enabled\n")));
            return SOC_E_PARAM;
        }
    } else if (shared_l2_banks + shared_l3_banks > 4) {
        if (cfg_l2_entries == -1) {
            LOG_CLI((BSL_META_U(unit,
                                "Default L2 size (294912) and the specified "
                                "l3_mem_entries (%d) require more than 4 shared "
                                "banks\n"),
                     cfg_l3_entries));
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "The specified l2_mem_entries (%d) and "
                                "l3_mem_entries (%d) require more than 4 shared "
                                "banks\n"),
                     cfg_l2_entries, cfg_l3_entries));
        }
        return SOC_E_PARAM;
    }
    _soc_alpm_mode[unit] = alpm_enable;

    /* Adjust table size to match L2_TABLE_HASH_CONTROL.MODE setting*/
    sop->memState[L2Xm].index_max = l2_entries - 1;
    sop->memState[L2_ENTRY_ONLYm].index_max = l2_entries - 1;
    
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        sop->memState[L2_ENTRY_ONLY_ECCm].index_max = l2_entries - 1;
    }
#endif

    sop->memState[L2_HITDA_ONLYm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITDA_ONLY_Xm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITDA_ONLY_Ym].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLYm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLY_Xm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLY_Ym].index_max = l2_entries / 4 - 1;
    sop->memState[L2_ENTRY_LPm].index_max = l2_entries / 4 - 1;

    /* Adjust table size to match L3_TABLE_HASH_CONTROL.MODE setting */
    sop->memState[L3_ENTRY_ONLYm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_ONLY_ECCm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_IPV4_UNICASTm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_IPV4_MULTICASTm].index_max = l3_entries / 2 - 1;
    sop->memState[L3_ENTRY_IPV6_UNICASTm].index_max = l3_entries/ 2 - 1;
    sop->memState[L3_ENTRY_IPV6_MULTICASTm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLYm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLY_Xm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLY_Ym].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_LPm].index_max = l3_entries / 4 - 1;

    /* Adjust table size to match L2/L3_TABLE_HASH_CONTROL.MODE setting */
    if (!alpm_enable) {
        sop->memState[L3_DEFIP_ALPM_RAWm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV4m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV4_1m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_64m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_64_1m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_128m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLY_Xm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLY_Ym].index_max = -1;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            sop->memState[L3_DEFIP_ALPM_ECCm].index_max = -1;
        }
#endif
    }

    /* LAG and ECMP resilient hashing features share the same flow set table.
     * The table can be configured in one of 3 modes:
     * - dedicated to LAG resilient hashing,
     * - dedicated to ECMP resilient hashing,
     * - split evenly between LAG and ECMP resilient hashing.
     */
    num_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_ECMP_RESILIENT_HASH_SIZE, 32768);
    switch (num_ecmp_rh_flowset_entries) {
        case 0:
            sop->memState[RH_ECMP_FLOWSETm].index_max = -1;
            break;
        case 32768:
            sop->memState[RH_LAG_FLOWSETm].index_max /= 2;
            sop->memState[RH_ECMP_FLOWSETm].index_max /= 2;
            break;
        case 65536:
            sop->memState[RH_LAG_FLOWSETm].index_max = -1;
            break;
        default:
            return SOC_E_CONFIG;
    }

    SOC_CONTROL(unit)->l3_defip_max_tcams = _SOC_TD2_DEFIP_MAX_TCAMS;
    SOC_CONTROL(unit)->l3_defip_tcam_size = _SOC_TD2_DEFIP_TCAM_DEPTH; 

    if (soc_property_get(unit, "l3_defip_sizing", TRUE)) {
        if (!soc_property_get(unit, spn_L3_ALPM_ENABLE, 0)) {
            defip_config = soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1);

            num_ipv6_128b_entries = soc_property_get(unit, 
                                        spn_NUM_IPV6_LPM_128B_ENTRIES, 
                                        (defip_config ? 2048 : 0));  
            num_ipv6_128b_entries = num_ipv6_128b_entries + 
                                    (num_ipv6_128b_entries % 2);

            config_v6_entries = num_ipv6_128b_entries;
            if (soc_property_get(unit, spn_LPM_SCALING_ENABLE, 0)) {
                num_ipv6_128b_entries = 0;
                if (!soc_property_get(unit, spn_LPM_IPV6_128B_RESERVED, 1)) {
                    config_v6_entries = ((config_v6_entries /
                                        SOC_CONTROL(unit)->l3_defip_tcam_size) +
                                        ((config_v6_entries %
                                         SOC_CONTROL(unit)->l3_defip_tcam_size)
                                        ? 1 : 0)) * SOC_CONTROL(unit)->l3_defip_tcam_size;
                }
            }
            sop->memState[L3_DEFIP_PAIR_128m].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Xm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Ym].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIPm].index_max = 
                                     (SOC_CONTROL(unit)->l3_defip_max_tcams * 
                                     SOC_CONTROL(unit)->l3_defip_tcam_size) - 
                                     (num_ipv6_128b_entries * 2) - 1;

            sop->memState[L3_DEFIP_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLY_Xm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLY_Ym].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            SOC_CONTROL(unit)->l3_defip_index_remap = num_ipv6_128b_entries;
        } else {
            if (soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1)) {
                /* slightly different processing for v6-128 */
                num_ipv6_128b_entries = soc_property_get(unit, 
                                            spn_NUM_IPV6_LPM_128B_ENTRIES, 
                                            2048);  
                num_ipv6_128b_entries = num_ipv6_128b_entries + 
                                        (num_ipv6_128b_entries % 2);
                config_v6_entries = num_ipv6_128b_entries;
                sop->memState[L3_DEFIP_PAIR_128m].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Xm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Ym].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIPm].index_max = 
                                  (SOC_CONTROL(unit)->l3_defip_max_tcams * 
                                  SOC_CONTROL(unit)->l3_defip_tcam_size) - 
                                  (num_ipv6_128b_entries * 2) - 1;
    
                sop->memState[L3_DEFIP_ONLYm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_HIT_ONLY_Xm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_HIT_ONLY_Ym].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;

                SOC_CONTROL(unit)->l3_defip_index_remap = 
                                       (num_ipv6_128b_entries / 2) * 2;
            } else {
                sop->memState[L3_DEFIP_PAIR_128m].index_max = -1;
            }
        }
        soc_l3_defip_indexes_init(unit, config_v6_entries); 
    }
    if (NULL == _soc_td2_alpm_bkt_view_map[unit]) {
        if ((_soc_td2_alpm_bkt_view_map[unit] = 
             sal_alloc(sizeof(soc_mem_t) * SOC_TD2_ALPM_MAX_BKTS, 
                       "alpm_bkt_map")) == NULL) {
            return SOC_E_MEMORY;
        }
    }    
    if (dev_id == BCM56830_DEVICE_ID) {
         soc_bcm56830_mem_config(unit);
    }
    if (dev_id == BCM56834_DEVICE_ID) {
         soc_bcm56834_mem_config(unit);
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
         soc_td2p_mem_config(unit, dev_id, rev_id);
    }    
#endif

    memset(_soc_td2_alpm_bkt_view_map[unit], INVALIDm,
           sizeof(soc_mem_t) * SOC_TD2_ALPM_MAX_BKTS);
    return SOC_E_NONE;
}

int 
soc_trident2_alpm_mode_get(int unit)
{
    return _soc_alpm_mode[unit];
}

#define _TD2_INDEX_1K_ENTRIES  1024
#define _TD2_INDEX_2K_ENTRIES  2048
#define _TD2_INDEX_3K_ENTRIES  3072
#define _TD2_INDEX_4K_ENTRIES  4096
#define _TD2_INDEX_6K_ENTRIES  6144

/* Map logical (always starts from 0 and contiguous) index to physical index 
   which can have a starting offset and/or holes.
   Input  : logical index
   Returns: physical index */
int
soc_trident2_l3_defip_index_map(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    int alpm_mode = _soc_alpm_mode[unit];
    int is_urpf_mode = SOC_CONTROL(unit)->l3_defip_urpf;
    int defip128_tbl_sz = SOC_CONTROL(unit)->l3_defip_index_remap;
    int tmp;

    /* don't remap for ALPM */
    if (defip128_tbl_sz == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Xm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Ym) {
        wide = 1;
    }

    if (alpm_mode == 2 && !is_urpf_mode) {
        tmp = defip128_tbl_sz / _TD2_INDEX_1K_ENTRIES;
        if (wide) {
            return index;
        } else {
            if (index < (_TD2_INDEX_1K_ENTRIES + (tmp * _TD2_INDEX_1K_ENTRIES) -
                defip128_tbl_sz)) {
                return index + defip128_tbl_sz + (tmp * _TD2_INDEX_1K_ENTRIES);
            } else {
                return index + (2 * defip128_tbl_sz);
            }
        }
    }

    if (alpm_mode == 1 && is_urpf_mode) {
        uint32 incr = soc_mem_index_count(unit, mem)/4;
        uint32 entries_per_tcam = _TD2_INDEX_1K_ENTRIES;
        uint32 tcam_num, tcam_idx;
        if (wide) {
            tcam_num = index/incr;
            tcam_idx = index % incr;
            return tcam_num * entries_per_tcam + tcam_idx;
        }
        incr = incr/2;
        tcam_num = index/incr;
        tcam_idx = index % incr;
        return tcam_num * entries_per_tcam + tcam_idx +
                            defip128_tbl_sz/4;
    }

    if (alpm_mode != 0) {
        uint32 cnt_128;

        if (wide > 0) {
            if (index < (soc_mem_index_count(unit, mem) / 2)) {
                return index;
            } 
            /* make index relative to upper half */
            index -= (soc_mem_index_count(unit, mem) / 2);
            return index + _TD2_INDEX_2K_ENTRIES;
        }

        cnt_128 = defip128_tbl_sz;
 
        if (cnt_128/2 <= _TD2_INDEX_1K_ENTRIES) {
            if ((cnt_128/2 + index) < _TD2_INDEX_1K_ENTRIES) {
                return index + cnt_128/2;
            } else if ((cnt_128 + index) < _TD2_INDEX_4K_ENTRIES) {
                return index + cnt_128;
            } else if ((cnt_128 + index + cnt_128/2) < 
                       (_TD2_INDEX_4K_ENTRIES + _TD2_INDEX_1K_ENTRIES)) {
                return index + cnt_128 + cnt_128/2;
            } else {
                return index + 2 * cnt_128;
            }
        } else {
            tmp = cnt_128 - _TD2_INDEX_2K_ENTRIES;
            if ((tmp/2 + index + _TD2_INDEX_2K_ENTRIES) < _TD2_INDEX_3K_ENTRIES) {
                return index + _TD2_INDEX_2K_ENTRIES + tmp/2;
            } else if ((cnt_128 + index) < _TD2_INDEX_4K_ENTRIES) {
                return index + cnt_128;
            } else if ((cnt_128 + tmp/2 + index + _TD2_INDEX_2K_ENTRIES) < 
                       (_TD2_INDEX_4K_ENTRIES + _TD2_INDEX_3K_ENTRIES)) {
                return index + cnt_128 + tmp/2 + _TD2_INDEX_2K_ENTRIES;
            } else {
                return index + cnt_128 * 2;
            }
        }
    }

    if (is_urpf_mode) { /* URPF mode */
        return soc_l3_defip_urpf_index_map(unit, wide, index);
    }

    return soc_l3_defip_index_map(unit, wide, index);
}

/* Reverse map physical index to logical index.
   Input  : physical index
   Returns: logical index */
int
soc_trident2_l3_defip_index_remap(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    int alpm_mode = _soc_alpm_mode[unit];
    int is_urpf_mode = SOC_CONTROL(unit)->l3_defip_urpf;
    int defip128_tbl_sz = SOC_CONTROL(unit)->l3_defip_index_remap;    
    int tmp;

    /* don't remap for ALPM */
    if (defip128_tbl_sz == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Xm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Ym) {
        wide = 1;
    }

    if (alpm_mode == 2 && !is_urpf_mode) {
        tmp = defip128_tbl_sz / _TD2_INDEX_1K_ENTRIES;
        if (wide) {
            return index;
        } else {
            if (index < (tmp * _TD2_INDEX_2K_ENTRIES) + _TD2_INDEX_1K_ENTRIES){
                return index - ( defip128_tbl_sz + (tmp * _TD2_INDEX_1K_ENTRIES));
            } else {
                return (index -  (2 * defip128_tbl_sz));
            }
        }
    } 
    if (alpm_mode == 1 && is_urpf_mode) {
        uint32 num_chunks, chunk_offset;
        if (wide) {
            num_chunks = index / _TD2_INDEX_1K_ENTRIES;
            chunk_offset = index % _TD2_INDEX_1K_ENTRIES;
            return num_chunks * soc_mem_index_count(unit, mem)/4
                   + chunk_offset;
        }
        num_chunks = index / _TD2_INDEX_1K_ENTRIES;
        chunk_offset = index % _TD2_INDEX_1K_ENTRIES;
        chunk_offset -= (defip128_tbl_sz/4);
        return num_chunks*soc_mem_index_count(unit, mem)/8 + chunk_offset;

    }
    if (alpm_mode != 0) {
        int cnt_128 = defip128_tbl_sz;
        
        if (wide) {
            if (index < cnt_128/2) {
                return index;
            } else if ((index >= _TD2_INDEX_2K_ENTRIES) && 
                       (index < _TD2_INDEX_2K_ENTRIES + cnt_128/2)){
                return index - _TD2_INDEX_2K_ENTRIES + cnt_128/2;               
            } else {
                return -1;
            }
        }

        if (cnt_128/2 <= _TD2_INDEX_1K_ENTRIES) {
            if ((index < _TD2_INDEX_1K_ENTRIES) &&
                (index >= cnt_128/2)) {
                return index - cnt_128/2;
            } else if ((index >= _TD2_INDEX_1K_ENTRIES + cnt_128/2) && 
                           (index < _TD2_INDEX_4K_ENTRIES)) {
                return index - cnt_128;
            } else if ((index < _TD2_INDEX_4K_ENTRIES + _TD2_INDEX_1K_ENTRIES) &&
                           (index >= _TD2_INDEX_4K_ENTRIES + cnt_128/2)) {
                return index - cnt_128 - cnt_128/2;
            } else {
                return index - cnt_128 * 2;
            }
        } else if (cnt_128/2 <= _TD2_INDEX_2K_ENTRIES) {
            if (index < _TD2_INDEX_3K_ENTRIES) {
                return index - _TD2_INDEX_2K_ENTRIES - \
                       (cnt_128 - _TD2_INDEX_2K_ENTRIES)/2;
            } else if (index < _TD2_INDEX_4K_ENTRIES) {
                return index - cnt_128;
            } else if (index < _TD2_INDEX_4K_ENTRIES + _TD2_INDEX_3K_ENTRIES) {
                return index - cnt_128 - _TD2_INDEX_2K_ENTRIES - \
                       (cnt_128 - _TD2_INDEX_2K_ENTRIES)/2;
            } else {
                return index - cnt_128 * 2;
            }
        }
    }
    if (is_urpf_mode) { /* URPF mode */
        return soc_l3_defip_urpf_index_remap(unit, wide, index);
    }

    return soc_l3_defip_index_remap(unit, wide, index);
}

/* Given a physical index (always in terms of the narrow entry) 
   return the logical index and memory type */
int
soc_trident2_l3_defip_mem_index_get(int unit, int pindex, soc_mem_t *mem)
{
    return soc_l3_defip_index_mem_map(unit, pindex, mem);
}

int
soc_trident2_mem_index_remap(int unit, soc_mem_t mem, int index)
{
    switch (mem) {
        case L3_DEFIPm:
        case L3_DEFIP_PAIR_128m:    
        case L3_DEFIP_ONLYm:    
        case L3_DEFIP_PAIR_128_ONLYm:
        case L3_DEFIP_DATA_ONLYm:    
        case L3_DEFIP_PAIR_128_DATA_ONLYm:
            return soc_trident2_l3_defip_index_remap(unit, mem, index);
        default:
            return index;
    }
}

void
_soc_trident2_alpm_bkt_view_set(int unit, int index, soc_mem_t view)
{
    int bkt = (index >> 2) & SOC_TD2_ALPM_BKT_MASK;

    if (view != INVALIDm) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "ALPM bkt set index:%d bkt:%d view:%s\n"),
                     index, bkt, SOC_MEM_NAME(unit, view)));
    }
    _soc_td2_alpm_bkt_view_map[unit][bkt] = view;
}

soc_mem_t
_soc_trident2_alpm_bkt_view_get(int unit, int index)
{
    soc_mem_t view;
    int bkt = (index >> 2) & SOC_TD2_ALPM_BKT_MASK;
    
    view = _soc_td2_alpm_bkt_view_map[unit][bkt];
    if (view != INVALIDm) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "ALPM bkt get index:%d bkt:%d view:%s\n"),
                     index, bkt, SOC_MEM_NAME(unit, view)));
    }
    return view;
}

int
_soc_trident2_mem_sram_info_get(int unit, soc_mem_t mem, int index, 
                                _soc_ser_sram_info_t *sram_info)
{
    soc_mem_t view;
    int i, j, base, base_index, offset, base_bucket, bkt_offset;
    int entries_per_ram = 0, entries_per_bank, contiguous = 0;
    
    sram_info->disable_reg = INVALIDr;
    sram_info->disable_field = INVALIDf;
    sram_info->force_reg = INVALIDr;
    sram_info->force_field = INVALIDf;
    
    switch (mem) {
    case L2Xm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L2_ENTRY_ONLY_ECCm:
#endif
        if (!SOC_IS_TRIDENT2PLUS(unit)) {
            sram_info->disable_reg = L2_ENTRY_PARITY_CONTROLr;
            sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
            sram_info->force_field = FORCE_XOR_GENERATIONf;
        }
        if (index < SOC_TD2_NUM_ENTRIES_L2_BANK) {
            if (!SOC_IS_TRIDENT2PLUS(unit)) {
                sram_info->force_reg = L2_ENTRY_CONTROL_6r;
            }
            sram_info->ram_count = SOC_TD2_NUM_EL_L2;
            entries_per_ram = SOC_TD2_RAM_OFFSET_L2_BANK;
            offset = index % entries_per_ram;
            base = offset;
            if (index >= SOC_TD2_NUM_ENTRIES_PER_L2_BANK) {                
                base = offset + SOC_TD2_NUM_ENTRIES_PER_L2_BANK;
            }
        } else {
            if (!SOC_IS_TRIDENT2PLUS(unit)) {
                sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
            }
            sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
            entries_per_ram = SOC_TD2_RAM_OFFSET_L2_SHARED_BANK;
            base_index = SOC_TD2_NUM_ENTRIES_L2_BANK;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            offset = base_index + (index % entries_per_ram);
            base = offset;
            for (i = 1; i < SOC_TD2_NUM_EL_L2; i++) {
                if (index >= (base_index + (entries_per_bank * i))) {
                    base = offset + (entries_per_bank * i);
                }
            }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TRIDENT2PLUS(unit)) {
                sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED;
                entries_per_bank = entries_per_ram * sram_info->ram_count;
                for (i = 1; i < SOC_TD2_NUM_EL_L2; i++) {
                    if (index >= (base_index + (entries_per_bank * i))) {
                        base = offset + (entries_per_bank * i);
                    }
                }
            }
#endif
        }
        break;
    case L3_ENTRY_ONLYm:
    case L3_ENTRY_IPV4_UNICASTm:
    case L3_ENTRY_IPV4_MULTICASTm:
    case L3_ENTRY_IPV6_UNICASTm:
    case L3_ENTRY_IPV6_MULTICASTm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L3_ENTRY_ONLY_ECCm:
#endif
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            if (index < SOC_TD2_NUM_ENTRIES_L3_BANK) {
                /* dedicated L3 entries - hash table */
                sram_info->ram_count = 1;
                entries_per_ram = SOC_TD2_NUM_ENTRIES_L3_BANK;
                base = index;
            } else {
                sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED;
                entries_per_ram = SOC_TD2_RAM_OFFSET_L3_NARROW;
                base_index = SOC_TD2_NUM_ENTRIES_L3_BANK;
                entries_per_bank = entries_per_ram * sram_info->ram_count;
                offset = base_index + (index % entries_per_ram);
                base = offset;
                for (i = 1; i < SOC_TD2P_NUM_EL_L3; i++) {
                    if (index >= (base_index + (entries_per_bank * i))) {
                        base = offset + (entries_per_bank * i);
                    }
                }
            }
        } else 
#endif
        {
            if ((soc_mem_index_count(unit, L3_ENTRY_ONLYm) <= SOC_TD2_NUM_ENTRIES_L3_BANK) ||
                (index < SOC_TD2_NUM_ENTRIES_L3_BANK)) {
                /* No SRAM XOR RAM in L3 banks, or the entry locates at dedicated L3 banks */
                return SOC_E_UNAVAIL;
            }
            sram_info->disable_reg = L3_ENTRY_PARITY_CONTROLr;
            sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
            sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
            sram_info->force_field = FORCE_XOR_GENERATIONf;
            sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
            entries_per_ram = ((mem == L3_ENTRY_ONLYm || mem == L3_ENTRY_IPV4_UNICASTm) ? 
                               SOC_TD2_RAM_OFFSET_L3_NARROW : (mem == L3_ENTRY_IPV6_MULTICASTm) ?
                               SOC_TD2_RAM_OFFSET_L3_DOUBLE_WIDE :
                               SOC_TD2_RAM_OFFSET_L3_WIDE);
            base_index = ((mem == L3_ENTRY_ONLYm || mem == L3_ENTRY_IPV4_UNICASTm) ?
                          SOC_TD2_NUM_ENTRIES_L3_BANK : (mem == L3_ENTRY_IPV6_MULTICASTm) ?
                          SOC_TD2_NUM_ENTRIES_L3_BANK_DOUBLE_WIDE :
                          SOC_TD2_NUM_ENTRIES_L3_BANK_WIDE);
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            offset = base_index + (index % entries_per_ram);
            base = offset;
            for (i = 1; i < SOC_TD2_NUM_EL_ALPM; i++) {
                if (index >= (base_index + (entries_per_bank * i))) {
                    base = offset + (entries_per_bank * i);
                }
            }
        }
        break;
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
    case L3_DEFIP_ALPM_RAWm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L3_DEFIP_ALPM_ECCm:
#endif
        if (!SOC_IS_TRIDENT2PLUS(unit)) {
            sram_info->disable_reg = ILPM_SER_CONTROLr;
            sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
            sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
            sram_info->force_field = FORCE_XOR_GENERATIONf;
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED;
            base_bucket = ((index >> 2) & SOC_TD2_ALPM_BKT_MASK);
            base = index & 0x3;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "reported bucket: 0x%08x, bank:%d\n"), base_bucket, base));
            base_bucket = base_bucket % SOC_TD2_ALPM_BKT_OFFFSET;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "base bucket: 0x%08x\n"), base_bucket));
            for (i = 0; i < SOC_TD2P_NUM_EL_SHARED; i++) {
                sram_info->view[i] = mem;
                sram_info->index_count[i] = 1;
                bkt_offset = base_bucket + SOC_TD2_ALPM_BKT_OFFFSET * i;
                sram_info->mem_indexes[i][0] =
                    (index & SOC_TD2P_ALPM_MODE0_BKT_MASK) |
                    (bkt_offset << 2) | base;
            }
        } else
#endif
        {
            sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
            base_bucket = ((index  >> 2) & SOC_TD2_ALPM_BKT_MASK);
            base = index & 0x3;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "reported bucket: 0x%08x, bank:%d\n"), base_bucket, base));
            base_bucket = base_bucket % SOC_TD2_ALPM_BKT_OFFFSET;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "base bucket: 0x%08x\n"), base_bucket));
            
            for (i = 0; i < SOC_TD2_NUM_EL_SHARED; i++) {
                /* Retreive views for all 8 buckets */
                bkt_offset = base_bucket + SOC_TD2_ALPM_BKT_OFFFSET * i;
                view = _soc_td2_alpm_bkt_view_map[unit][bkt_offset];
                if (INVALIDm != view) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                            "\nbucket[%d]: 0x%08x view: %s\n"), i, bkt_offset,
                                            SOC_MEM_NAME(unit, view)));
                }
                /* Use RAW view to recovery those unused ALPM buckets and avoid
                 * false alarm */
                if (INVALIDm == view) {
                    view = L3_DEFIP_ALPM_RAWm;
                }
                sram_info->view[i] = view;
                switch (view) {
                case L3_DEFIP_ALPM_RAWm:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_PER_BKT_COUNT;
                    sram_info->mem_indexes[i][0] = (bkt_offset << 2) | base;
                    break;
                case L3_DEFIP_ALPM_IPV6_128m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV6_128_PER_BKT_COUNT;
                    sram_info->mem_indexes[i][0] = (bkt_offset << 2) | base;
                    sram_info->mem_indexes[i][1] = (1 << 16) | (bkt_offset << 2) | base;
                    break;
                case L3_DEFIP_ALPM_IPV6_64_1m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV6_64_1_PER_BKT_COUNT;
                    sram_info->mem_indexes[i][0] = (bkt_offset << 2) | base;
                    sram_info->mem_indexes[i][1] = (1 << 16) | (bkt_offset << 2) | base;
                    sram_info->mem_indexes[i][2] = (2 << 16) | (bkt_offset << 2) | base;
                    break;
                case L3_DEFIP_ALPM_IPV4m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV4_PER_BKT_COUNT;
                    for (j = 0; j < SOC_TD2_L3_DEFIP_ALPM_IPV4_PER_BKT_COUNT; j++) {
                        sram_info->mem_indexes[i][j] = (j << 16) | (bkt_offset << 2) |
                                                       base;                
                    }
                    break;
                case L3_DEFIP_ALPM_IPV4_1m:
                case L3_DEFIP_ALPM_IPV6_64m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV6_64_PER_BKT_COUNT;
                    for (j = 0; j < SOC_TD2_L3_DEFIP_ALPM_IPV6_64_PER_BKT_COUNT; j++) {
                        sram_info->mem_indexes[i][j] = (j << 16) | (bkt_offset << 2) |
                                                       base;                
                    }
                default:
                    break;
                }
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "Entries per bkt: %d\n"), sram_info->index_count[i]));
                for (j = 0; j < sram_info->index_count[i]; j++) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                            "Index[%d]: [0x%08x]%d\n"), j, sram_info->mem_indexes[i][j],
                                            sram_info->mem_indexes[i][j]));
                }
            }
        }
        return SOC_E_NONE;
    case VLAN_XLATEm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case VLAN_XLATE_ECCm:
#endif
        contiguous = 1;
        sram_info->disable_reg = VLAN_XLATE_DBGCTRL_0r;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = VLAN_XLATE_DBGCTRL_0r;
        sram_info->force_field = FORCE_XOR_GENf;
        sram_info->ram_count = SOC_TD2_NUM_EL_VLAN_XLATE;
        base = (index/4) * 4;
        break;
    case EGR_VLAN_XLATEm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case EGR_VLAN_XLATE_ECCm:
#endif
        contiguous = 1;
        sram_info->disable_reg = EGR_VLAN_XLATE_CONTROLr;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = EGR_VLAN_XLATE_CONTROLr;
        sram_info->force_field = FORCE_XOR_GENf;
        sram_info->ram_count = SOC_TD2_NUM_EL_EGR_VLAN_XLATE;
        base = (index/4) * 4;
        break;
    case ING_L3_NEXT_HOPm:
        sram_info->ram_count = SOC_TD2_NUM_EL_ING_L3_NEXT_HOP;
        entries_per_ram = SOC_TD2_RAM_OFFSET_ING_L3_NEXT_HOP;
        base = index % entries_per_ram;
        break;
    case L3_IPMCm:
        sram_info->ram_count = SOC_TD2_NUM_EL_L3_IPMC;
        entries_per_ram = SOC_TD2_RAM_OFFSET_L3_IPMC;
        base = index % entries_per_ram;
        break;
    case L2MCm:
        sram_info->ram_count = SOC_TD2_NUM_EL_L2MC;
        entries_per_ram = SOC_TD2_RAM_OFFSET_L2MC;
        base = index % entries_per_ram;
        break;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L2_ENTRY_LPm:
    case L3_ENTRY_LPm:
    case VLAN_XLATE_LPm:
    case EGR_VLAN_XLATE_LPm:
        sram_info->view[0] = mem;
        sram_info->index_count[0] = 1;
        sram_info->ram_count = 1;
        entries_per_ram = 0;
        base = index;
        break;
#endif
    default: return SOC_E_PARAM;
    }
    sram_info->mem_indexes[0][0] = base;
    if (contiguous) {
        for (i = 1; i < sram_info->ram_count; i++) {
            sram_info->mem_indexes[i][0] = sram_info->mem_indexes[i-1][0] + 1;
        }
    } else {
        for (i = 1; i < sram_info->ram_count; i++) {
            sram_info->mem_indexes[i][0] =  sram_info->mem_indexes[i-1][0] + entries_per_ram;
        }
    }
    return SOC_E_NONE;
}

int
_soc_trident2_mem_cpu_write_control(int unit, soc_mem_t mem, int copyno,
                                    int enable, int *orig_enable)
{
    soc_reg_t reg;
    soc_field_t field;
    int blk, port;
    uint32 rval, fval, orig_fval, enable_fval, disable_fval;

    enable_fval = 1;
    disable_fval = 0;

    switch (mem) {
    case XLPORT_WC_UCMEM_DATAm:
        reg = XLPORT_WC_UCMEM_CTRLr;
        field = ACCESS_MODEf;
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            port = SOC_BLOCK_PORT(unit, blk);
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            /* It will use the setting from the last block */
            *orig_enable = soc_reg_field_get(unit, reg, rval, field);
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        }
        return SOC_E_NONE;
    case MMU_CFAP_BANK0m:
    case MMU_CFAP_BANK1m:
    case MMU_CFAP_BANK10m:
    case MMU_CFAP_BANK11m:
    case MMU_CFAP_BANK12m:
    case MMU_CFAP_BANK13m:
    case MMU_CFAP_BANK14m:
    case MMU_CFAP_BANK15m:
    case MMU_CFAP_BANK16m:
    case MMU_CFAP_BANK17m:
    case MMU_CFAP_BANK18m:
    case MMU_CFAP_BANK19m:
    case MMU_CFAP_BANK2m:
    case MMU_CFAP_BANK20m:
    case MMU_CFAP_BANK3m: 
    case MMU_CFAP_BANK4m: 
    case MMU_CFAP_BANK5m: 
    case MMU_CFAP_BANK6m: 
    case MMU_CFAP_BANK7m: 
    case MMU_CFAP_BANK8m:
    case MMU_CFAP_BANK9m:
        reg=MISCCONFIGr;
        field=INIT_MEMf;
        enable_fval=1;
        disable_fval=0;
        break;

    case L3_DEFIP_ALPM_RAWm:
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
        reg = ISS_MEMORY_CONTROL_84r;
        field = BYPASS_ISS_MEMORY_LPf;
        enable_fval = 0xf;
        break;
    case MMU_INTFI_PFC_ST_TBLm:
        reg = INTFI_CFGr;
        field = PFC_ST_TBL_DISABLEf;
        break;
    case LINK_STATUSm:
        reg = SW2_HW_CONTROLr;
        field = LINK_STATUS_UPDATE_ENABLEf;
        break;
    case MMU_INTFO_QCN_CNM_TIMER_TBLm:
    case MMU_INTFI_XPIPE_FC_MAP_TBL2m:
    case MMU_INTFI_YPIPE_FC_MAP_TBL2m:
        reg = MISCCONFIGr;
        field = REFRESH_ENf;
        enable_fval = 0;
        disable_fval = 1;
        break;
    default:
        return SOC_E_NONE;
    }

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    orig_fval = soc_reg_field_get(unit, reg, rval, field);
    fval = enable ? enable_fval : disable_fval;

    *orig_enable = orig_fval == enable_fval;
    if (fval != orig_fval) {
        soc_reg_field_set(unit, reg, &rval, field, fval);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
    }

    return SOC_E_NONE;
}

/*
 * cpu port (mmu port 0): 48 queues (2000-2047)
 * loopback port (mmu port 116): 8 queues (4048-4055)
 */
int
soc_trident2_num_cosq_init(int unit)
{
    soc_info_t *si;
    int port, phy_port, mmu_port, mmu_port_offset, pipe;
    int uc_cosq_base, mc_cosq_base, uc_cosq_per_port;

    si = &SOC_INFO(unit);

    if (soc_feature(unit, soc_feature_cmic_reserved_queues)) {
        si->port_num_cosq[CMIC_PORT(unit)] = 44;
    } else {
        si->port_num_cosq[CMIC_PORT(unit)] = 48;
    }
    si->port_cosq_base[CMIC_PORT(unit)] = 520;
    si->port_num_cosq[LB_PORT(unit)] = 9; 
    si->port_cosq_base[LB_PORT(unit)] = 1088;

    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        if (pipe) { /* Y-pipe */
            uc_cosq_base = 1480;
            mc_cosq_base = 568;
        } else { /* X-pipe */
            uc_cosq_base = 0;
            mc_cosq_base = 0;
        }
        for (mmu_port_offset = 0; mmu_port_offset < _TD2_MMU_PORTS_PER_PIPE;
             mmu_port_offset++) {
            mmu_port = si->mmu_port_base[pipe] + mmu_port_offset;
            phy_port = si->port_m2p_mapping[mmu_port];
            if (phy_port == -1) {
                continue;
            }
            port = si->port_p2l_mapping[phy_port];

            if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
                continue;
            }

            if (SOC_PBMP_MEMBER(si->eq_pbm, port)) { /* VBS (HSP) port */
                si->port_num_cosq[port] = 10;
                si->port_cosq_base[port] = mc_cosq_base + (mmu_port_offset * si->port_num_cosq[port]);
                si->port_num_uc_cosq[port] = 10;
                si->port_uc_cosq_base[port] = uc_cosq_base;
                uc_cosq_base += si->port_num_uc_cosq[port];
            } else {
                uc_cosq_per_port =
                    soc_property_port_get(unit, port, spn_LLS_NUM_L2UC, 10);
                if (uc_cosq_per_port < 10 || uc_cosq_per_port > 16) {
                    uc_cosq_per_port = 10;
                }
                uc_cosq_per_port = (uc_cosq_per_port + 3) & ~3;

                si->port_num_cosq[port] = 10;
                si->port_cosq_base[port] = mc_cosq_base + (mmu_port_offset * si->port_num_cosq[port]);
                si->port_num_uc_cosq[port] = uc_cosq_per_port;
                /*uc_cosq_base for LLS port must be 
                 *divisible by 4 for PFC to work */ 
                uc_cosq_base = (uc_cosq_base + 3) & (~3);
                si->port_uc_cosq_base[port] = uc_cosq_base;
                uc_cosq_base += si->port_num_uc_cosq[port];
            }
        }
    }

    return SOC_E_NONE;
}

STATIC int
soc_trident2_max_frequency_get(int unit,  uint16 dev_id, uint8 rev_id,
                               int skew_id, int *frequency)
{
    switch (dev_id) {
    case BCM56860_DEVICE_ID:
        *frequency = 793;
        break;
    case BCM56861_DEVICE_ID:
        *frequency = 635;
        break;
    case BCM56862_DEVICE_ID:
        *frequency = 793;
        break;
    case BCM56864_DEVICE_ID:
        *frequency = 635;
        break;
    case BCM56865_DEVICE_ID:
    case BCM56867_DEVICE_ID:
    case BCM56760_DEVICE_ID:
        *frequency = 793;
        break;
    case BCM56832_DEVICE_ID:
    case BCM56833_DEVICE_ID:
        *frequency = 537;
        break;
    case BCM56850_DEVICE_ID:
    case BCM56852_DEVICE_ID:
    case BCM56853_DEVICE_ID:
    case BCM56855_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56830_DEVICE_ID:
    case BCM56834_DEVICE_ID:   	
        *frequency = rev_id < BCM56850_A2_REV_ID ? 760 : 793;
        break;
    case BCM56851_DEVICE_ID: /* Cannot handle 56851P */
        if (skew_id == 2) { /* 56851P */
            *frequency = rev_id < BCM56851_A2_REV_ID ? 518 : 537;
        } else {
            *frequency = rev_id < BCM56851_A2_REV_ID ? 608 : 635;
        }
        break;
    case BCM56854_DEVICE_ID:
        *frequency = rev_id < BCM56854_A2_REV_ID ? 608 : 635;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    return SOC_E_NONE;
}

STATIC int
soc_trident2_max_io_frequency_get(int unit,  uint16 dev_id, uint8 rev_id,
                               int skew_id, int *iof)
{
    int frequency;

    switch (dev_id) {
    case BCM56860_DEVICE_ID:
    case BCM56861_DEVICE_ID:
    case BCM56867_DEVICE_ID:
    case BCM56760_DEVICE_ID:
        frequency = 1280000;
        break;
    case BCM56862_DEVICE_ID:
        frequency = 960000;
        break;
    case BCM56864_DEVICE_ID:
        frequency = 720000;
        break;
    case BCM56832_DEVICE_ID:
    case BCM56833_DEVICE_ID:
        frequency = 1080000;
        break;
    /*TD2*/ 
    case BCM56850_DEVICE_ID:
    case BCM56851_DEVICE_ID:
    case BCM56853_DEVICE_ID:
	case BCM56855_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56830_DEVICE_ID:
    case BCM56834_DEVICE_ID:   	
        frequency = 1280000;
        break;
    case BCM56852_DEVICE_ID:
        frequency = 960000;
        break;
    case BCM56854_DEVICE_ID:
        frequency = 720000;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    *iof = frequency;

    return SOC_E_NONE;
}

int
soc_trident2_tsc_map_get(int unit, uint32 *tsc_map)
{
    uint16 dev_id;
    uint8 rev_id;

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    switch (dev_id) {
    case BCM56861_DEVICE_ID: 
    case BCM56867_DEVICE_ID: 
    case BCM56860_DEVICE_ID: 
    case BCM56760_DEVICE_ID:
    case BCM56850_DEVICE_ID:
    case BCM56851_DEVICE_ID:
    case BCM56853_DEVICE_ID:
    case BCM56855_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56834_DEVICE_ID:   
    case BCM56833_DEVICE_ID:
        *tsc_map = 0xffffffff;
        break;
    case BCM56862_DEVICE_ID:
    case BCM56852_DEVICE_ID:
    case BCM56830_DEVICE_ID:
        *tsc_map = 0xe7e7e7ef;
        break;
    case BCM56854_DEVICE_ID:
    case BCM56864_DEVICE_ID:
    case BCM56865_DEVICE_ID:
        *tsc_map = 0x0f1ff8e8;
        break;
    case BCM56832_DEVICE_ID: 
        *tsc_map = 0xffffffff;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    return SOC_E_NONE;
}

typedef struct soc_td2_valid_fallback_lanes_s {
    soc_100g_lane_config_t lane_config;
    int                    valid_lanes[3];
}soc_td2_valid_fallback_lanes_t;

const soc_td2_valid_fallback_lanes_t soc_td2_valid_lanes[] = {
    {SOC_LANE_CONFIG_100G_4_4_2, {TRUE, TRUE, TRUE} },
    {SOC_LANE_CONFIG_100G_3_4_3, {TRUE, TRUE, TRUE} },
    {SOC_LANE_CONFIG_100G_2_4_4, {TRUE, TRUE, TRUE} },
    {SOC_INVALID_LANE_CONFIG}
};

/*
 * Trident2 port mapping
 *     130 physical ports: port 0-64 in X pipe, port 65-129 in Y pipe
 *     106 logical ports
 *     108 mmu ports: port 0-53 in X pipe, port 64-117 in Y pipe
 *     cpu port number is fixed: physical 0, logical 0, mmu 52
 *     loopback port number is fixed: physical 129, logical 105, mmu 116
 *     mmu port 53 and mmu port 117 are purge port
 *     mmu port can only map to physical port ID in the same pipe
 *     XLPORT3 (physical port 13-16) can be configured as management port(s)
 *     management port can be:
 *     - one 10G port
 *     - one to four ports with speed up to 2.5G each
 * Physical port number in eacc port group
 *     PGW_CL0: CPORT0   TSC 0-2   port 1
 *              XLPORT0  TSC 0     port 1-4
 *              XLPORT1  TSC 1     port 5-8
 *              XLPORT2  TSC 2     port 9-12
 *              XLPORT3  TSC 3     port 13-16
 *     PGW_CL1: CPORT1   TSC 5-7   port 21
 *              XLPORT7  TSC 4     port 17-20
 *              XLPORT6  TSC 5     port 21-24
 *              XLPORT5  TSC 6     port 25-28
 *              XLPORT4  TSC 7     port 29-32
 *     PGW_CL2: CPORT2   TSC 8-10  port 33
 *              XLPORT8  TSC 8     port 33-36
 *              XLPORT9  TSC 9     port 37-40
 *              XLPORT10 TSC 10    port 41-44
 *              XLPORT11 TSC 11    port 45-48
 *     PGW_CL3: CPORT3   TSC 13-15 port 53
 *              XLPORT15 TSC 12    port 49-52
 *              XLPORT14 TSC 13    port 53-56
 *              XLPORT13 TSC 14    port 57-60
 *              XLPORT12 TSC 15    port 61-64
 *     PGW_CL4: CPORT4   TSC 16-18 port 65
 *              XLPORT16 TSC 16    port 65-68
 *              XLPORT17 TSC 17    port 69-72
 *              XLPORT18 TSC 18    port 73-76
 *              XLPORT19 TSC 19    port 77-80
 *     PGW_CL5: CPORT5   TSC 21-23 port 85
 *              XLPORT23 TSC 20    port 81-84
 *              XLPORT22 TSC 21    port 85-88
 *              XLPORT21 TSC 22    port 89-92
 *              XLPORT20 TSC 23    port 93-96
 *     PGW_CL6: CPORT6   TSC 24-26 port 97
 *              XLPORT24 TSC 24    port 97-100
 *              XLPORT25 TSC 25    port 101-104
 *              XLPORT26 TSC 26    port 105-108
 *              XLPORT27 TSC 27    port 109-112
 *     PGW_CL7: CPORT7   TSC 29-31 port 117
 *              XLPORT31 TSC 28    port 113-116
 *              XLPORT30 TSC 29    port 117-120
 *              XLPORT29 TSC 30    port 121-124
 *              XLPORT28 TSC 31    port 125-128
 * This routine will setup:
 *     SOC_INFO(unit).port_p2l_mapping[]
 *     SOC_INFO(unit).port_l2p_mapping[]
 *     SOC_INFO(unit).port_p2m_mapping[]
 *     SOC_INFO(unit).port_m2p_mapping[]
 *     SOC_INFO(unit).port_speed_max[]
 *     SOC_INFO(unit).port_group[]
 *     SOC_INFO(unit).port_serdes[]
 *     SOC_INFO(unit).port_num_lanes[]
 *     SOC_INFO(unit).phy_port_base[]
 *     SOC_INFO(unit).mmu_port_base[]
 * 100+G port:
 *     - can only be @ 760MHz
 *     - needs to be HSP
 *     - cannot be in oversubscribe mode
 * 40/42G port:
 *     - needs to be HSP except @ 760MHz
 *     - oversubscribe mode can support both cut-through and store-and-forward
 * sub-40G port:
 *     - oversubscribe mode can only support store-and-forward
 */
int
soc_trident2_port_config_init(int unit, uint16 dev_id, uint8 rev_id)
{
    soc_info_t *si;
    char *config_str, *sub_str, *sub_str_end;
    static const char str_2p5[] = "2.5";
    static const char str_osg[] = "OSG.";
    char str_buf[8];
    int rv;
    int num_port, num_phy_port, num_mmu_port;
    int port, phy_port, mmu_port;
    int port_cpu, phy_port_cpu, mmu_port_cpu;
    int port_lb, phy_port_lb, mmu_port_lb;
    int pipe, quad, pgw, blk;
    int port_bandwidth, frequency;
    int blk_linerate_bandwidth, blk_oversub_bandwidth;
    int pgw_linerate_bandwidth, pgw_oversub_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    int index, tsc_id;
    int port_count[_TD2_PIPES_PER_DEV], lane_count;
    int pgw_port[_TD2_PORTS_PER_PGW], *blk_port;
    int pgw_port_bandwidth[_TD2_PORTS_PER_PGW], *blk_port_bandwidth;
    int max_quad_core_bandwidth[_TD2_QUADS_PER_DEV];
    soc_100g_lane_config_t lane_config;
    int fallback_lane = 1;
    int i;
    soc_pbmp_t pbmp, oversub_pbm, pbmp_mmu_reserved;
    uint32 tsc_map;
    uint32 blk_configured_map;
    uint32 blk_management_map, blk_inactive_map, blk_oversub_map;
    char option;
    int freq_list_len;
    int const *freq_list;
    int osg_cnt, osg_str_cnt; /* Oversub Speed Group count and string count */

    si = &SOC_INFO(unit);

    num_port = 106;
    num_phy_port = 130;
    num_mmu_port = 117; /* mmu port 53 to 63 are not used */

    /* cpu port is logical port 0, physical port 0, mmu port 0 */
    port_cpu = 0;
    phy_port_cpu = 0;
    mmu_port_cpu = 52;

    /* loopback port is logical port 105, physical port 129, mmu port 65 */
    port_lb = 105;
    phy_port_lb = 129;
    mmu_port_lb = 116;

    /* Can't read skew_id from TOP register at this point */
    SOC_IF_ERROR_RETURN
        (soc_trident2_max_frequency_get(unit, dev_id, rev_id, -1, 
                                                    &si->frequency));
    if (SOC_IS_TRIDENT2(unit)) {
        frequency = rev_id == BCM56850_A0_REV_ID ? 415 : -1;
    } else {
        frequency = -1;
    }
    frequency = soc_property_get(unit, spn_CORE_CLOCK_FREQUENCY, frequency);

    if (frequency != -1 && frequency < si->frequency) {
        if (SOC_IS_TRIDENT2(unit)) {
            if (rev_id <= BCM56850_A1_REV_ID) {
                freq_list = a1_freq_list;
                freq_list_len = sizeof(a1_freq_list) / sizeof(int);
            } else {
                if (si->frequency == 793) {
                    freq_list = a2_793_freq_list;
                    freq_list_len = sizeof(a2_793_freq_list) / sizeof(int);
                } else {
                    freq_list = a2_635_freq_list;
                    freq_list_len = sizeof(a2_635_freq_list) / sizeof(int);
                }
            }
        } else {
            freq_list = a1_td2p_freq_list;
            freq_list_len = sizeof(a1_td2p_freq_list) / sizeof(int);
        }

        for (index = 1; index < freq_list_len; index++) { /* skip index 0 */
            if (freq_list[index] < si->frequency &&
                frequency == freq_list[index]) {
                break;
            }
        }

        if (index < freq_list_len) {
            si->frequency = frequency;
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "*** Input core clock frequency %dMHz is not "
                                "supported!\n"), frequency));
        }
    } else if (frequency > si->frequency) {
        LOG_CLI((BSL_META_U(unit,
                            "*** Input core clock frequency %dMHz is not supported!\n"),
                 frequency));
    }

    /* Setup max I/O bandwidth */
    SOC_IF_ERROR_RETURN
        (soc_trident2_max_io_frequency_get(unit, dev_id, rev_id, -1, 
                                           &si->io_bandwidth));

    /* Setup max core bandwidth */
    if (si->frequency >= 760) {
        si->bandwidth = 960000;
    } else if (si->frequency >= 608) {
        si->bandwidth = 720000;
    } else if (si->frequency >= 518) {
        si->bandwidth = 640000;
    } else {
        if (SOC_IS_TRIDENT2(unit)) {
            si->bandwidth = 480000;
        } else {
            if (si->frequency >= 517) {
                si->bandwidth = 640000;
            } else {
                si->bandwidth = 480000;
            }
        }
    }

    /* Setup max bandwidth for each per quadrant */
    if (si->bandwidth == 720000) {
        max_quad_core_bandwidth[0] = max_quad_core_bandwidth[3] = 160000;
        max_quad_core_bandwidth[1] = max_quad_core_bandwidth[2] = 200000;
    } else {
        for (quad = 0; quad < _TD2_QUADS_PER_DEV; quad++) {
            max_quad_core_bandwidth[quad] = si->bandwidth / 4;
        }
    }

    SOC_PBMP_CLEAR(oversub_pbm);
    if (si->io_bandwidth > si->bandwidth) {
        oversub_pbm =
            soc_property_get_pbmp(unit, spn_PBMP_OVERSUBSCRIBE, 0);
    }

    pbmp_mmu_reserved = 
        soc_property_get_pbmp(unit, "pbmp_mmu_reserved", 0);

    SOC_IF_ERROR_RETURN
        (soc_trident2_tsc_map_get(unit, &tsc_map));

    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        si->port_p2l_mapping[phy_port] = -1;
        si->port_p2m_mapping[phy_port] = -1;
    }
    for (port = 0; port < num_port; port++) {
        si->port_l2p_mapping[port] = -1;
        si->port_speed_max[port] = -1;
        si->port_group[port] = -1;
        si->port_serdes[port] = -1;
        si->port_num_lanes[port] = -1;
    }
    for (mmu_port = 0; mmu_port < num_mmu_port; mmu_port++) {
        si->port_m2p_mapping[mmu_port] = -1;
    }

    si->port_p2l_mapping[phy_port_cpu] = port_cpu;
    si->port_p2m_mapping[phy_port_cpu] = mmu_port_cpu;
    si->port_p2l_mapping[phy_port_lb] = port_lb;
    si->port_p2m_mapping[phy_port_lb] = mmu_port_lb;
    SOC_PBMP_PORT_SET(si->xpipe_pbm, port_cpu);
    SOC_PBMP_PORT_SET(si->ypipe_pbm, port_lb);
    SOC_PBMP_CLEAR(si->oversub_pbm);
    SOC_PBMP_CLEAR(si->management_pbm);
    SOC_PBMP_CLEAR(si->all.disabled_bitmap);

    si->phy_port_base[0] = 0;               /* First physical port in X pipe */
    si->phy_port_base[1] = num_phy_port / 2;/* First physical port in Y pipe */
    si->mmu_port_base[0] = 0;               /* First mmu port in X pipe */
    si->mmu_port_base[1] = 64;              /* First mmu port in Y pipe */

    port_count[0] = 0; /* X pipe */
    port_count[1] = 0; /* Y pipe */

    rv = SOC_E_NONE;
    for (port = 0; port < num_port; port++) {
        if (port == port_cpu || port == port_lb) {
            continue;
        }
        config_str = soc_property_port_get_str(unit, port, spn_PORTMAP);
        if (config_str == NULL) {
            continue;
        }

        /*
         * portmap.<port>=<physical port number>:<bandwidth in Gb>:<OSG.0xf>:<100G TSC lanes>:<100G Fallback XLMAC>:i
         * If the port config ends with 'i', the port is not enabled, but can
         * be enabled later as a flexport.
         */
        sub_str = config_str;

        /* Parse physical port number */
        phy_port = sal_ctoi(sub_str, &sub_str_end);
        if (sub_str == sub_str_end) {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Missing physical port information \"%s\"\n"),
                     port, config_str));
            rv = SOC_E_FAIL;
            continue;
        }
        if (phy_port < 1 || phy_port > (num_phy_port - 2)) {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Invalid physical port number %d\n"),
                     port, phy_port));
            rv = SOC_E_FAIL;
            continue;
        }
        tsc_id = (phy_port - 1) / 4;
        if (!(tsc_map & (1 << tsc_id))) {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Physical port %d is in disabled TSC %d\n"),
                     port, phy_port, tsc_id));
            rv = SOC_E_FAIL;
            continue;
        }
        if (si->port_p2l_mapping[phy_port] != -1) {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Physical port %d is used by port %d\n"),
                     port, phy_port, si->port_p2l_mapping[phy_port]));
            rv = SOC_E_FAIL;
            continue;
        }
        pipe = phy_port < si->phy_port_base[1] ? 0 : 1;
        if (port_count[pipe] >= num_port / 2 - 1) {
            LOG_CLI((BSL_META_U(unit,
                                "Can not configure more than %d port in "
                                "%c pipeline\n"), num_port / 2 - 1,
                     pipe ? 'Y' : 'X'));
            rv = SOC_E_FAIL;
            continue;
        }

        /* Skip ':' between physical port number and bandwidth */
        sub_str = sub_str_end;
        if (*sub_str != '\0') {
            if (*sub_str != ':') {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d: Bad config string \"%s\"\n"),
                         port, config_str));
                rv = SOC_E_FAIL;
                continue;
            }
            sub_str++;
        }

        /* Parse bandwidth */
        for (index = 0; index < sizeof(str_2p5) - 1; index++) {
            if (sub_str[index] == '\0') {
                break;
            }
            str_buf[index] = sub_str[index];
        }
        str_buf[index] = '\0';
        if (!sal_strcmp(str_buf, str_2p5)) {
            port_bandwidth = 2500;
            sub_str_end = &sub_str[sizeof(str_2p5) - 1];
        } else {
            port_bandwidth = sal_ctoi(sub_str, &sub_str_end) * 1000;
            if (sub_str == sub_str_end) {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d: Missing bandwidth information \"%s\"\n"),
                         port, config_str));
                rv = SOC_E_FAIL;
                continue;
            }
            if (port_bandwidth != 1000 && port_bandwidth != 10000 &&
                port_bandwidth != 15000 && port_bandwidth != 20000 &&
                port_bandwidth != 30000 && port_bandwidth != 40000 &&
                port_bandwidth != 100000 && port_bandwidth != 120000) {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d: Invalid bandwidth %d Gb\n"),
                         port, port_bandwidth / 1000));
                rv = SOC_E_FAIL;
                continue;
            }
        }
        /* Skip ':' between Bandwidth and OSG */
        sub_str = sub_str_end;
        if (*sub_str != '\0') {
            if (*sub_str != ':') {
                LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit, "Port %d: Bad config string \"%s\"\n"),
                             port, config_str));
                rv = SOC_E_FAIL;
                continue;
            }
            sub_str_end++;
        }

        /* All OSGs are availiable by default */
        osg_cnt = GET_MMU_OVS_GCOUNT(unit);
        if (SOC_PBMP_MEMBER(oversub_pbm, port)) {
            si->port_osg_bitmap[phy_port] = (1 << osg_cnt) - 1;
        }

        /*Read OSG configuration.  skip if options are present*/
        sub_str = sub_str_end;
        if (*sub_str != '\0' && (*sub_str != 'm' && *sub_str != 'i')) {
            /* OSG.0xf <=> OSG.  0x  f*/
            osg_str_cnt = sal_strlen(str_osg) + 2 + (osg_cnt + 3) / 4;
            for (index = 0; index < osg_str_cnt; index++) {
                if (sub_str[index] == '\0') {
                    break;
                }
                str_buf[index] = sub_str[index];
            }
            str_buf[index] = '\0';
            if (!sal_strncmp(str_buf, str_osg, sal_strlen(str_osg))) {
                if (!SOC_PBMP_MEMBER(oversub_pbm, port)) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Port %d: Bad config string \"%s\"\n"),
                             port, config_str));
                    rv = SOC_E_FAIL;
                    continue;
                }
                sub_str += sal_strlen(str_osg);
                si->port_osg_bitmap[phy_port] = 
                            sal_ctoi(sub_str, &sub_str_end);
                if (sub_str == sub_str_end) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Port %d: Missing OSG bitmap information \"%s\"\n"),
                             port, config_str));
                    rv = SOC_E_FAIL;
                    continue;
                }
                si->port_osg_bitmap[phy_port] &= (1 << osg_cnt) - 1;

                if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Port %d OSG bitmap: 0x%x\n"),
                             port, si->port_osg_bitmap[phy_port]));
                }
                sub_str_end = &sub_str[osg_str_cnt - sal_strlen(str_osg)]; /*Advance */
                
                /* Skip ':' between OSG and 100G lane config */
                sub_str = sub_str_end;
                if (*sub_str != '\0') {
                    if (*sub_str != ':') {
                        LOG_CLI((BSL_META_U(unit,
                                            "Port %d: Bad config string \"%s\"\n"),
                                 port, config_str));
                        rv = SOC_E_FAIL;
                        continue;
                    }
                    sub_str_end++;
                }
            }
        }
        /*Read 100G lane configuration if present.  skip if options are present*/
        sub_str = sub_str_end;
        lane_config = SOC_LANE_CONFIG_100G_4_4_2;
        if (*sub_str != '\0' && (*sub_str != 'm' && *sub_str != 'i')) {
            for (index = 0; index < 3; index++) {
                if (sub_str[index] == '\0') {
                    break;
                }
                str_buf[index] = sub_str[index];
            }
            str_buf[index] = '\0';
            if (!sal_strcmp(str_buf, "442")) {
                lane_config = SOC_LANE_CONFIG_100G_4_4_2;
            } else if (!sal_strcmp(str_buf, "244")) {
                lane_config = SOC_LANE_CONFIG_100G_2_4_4;
            } else if (!sal_strcmp(str_buf, "343")) {
                lane_config = SOC_LANE_CONFIG_100G_3_4_3;
            } else {
                LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit, "Port %d: Invalid lane configuration: %s\n"),
                           port, str_buf));
                rv = SOC_E_FAIL;
                continue;
            }
            sub_str_end = &sub_str[3]; /*Advance */

            /* Skip ':' between 100G lane config and 100G fallback port*/
            sub_str = sub_str_end;
            if (*sub_str != '\0') {
                if (*sub_str != ':') {
                    LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit, "Port %d: Bad config string \"%s\"\n"),
                                 port, config_str));
                    rv = SOC_E_FAIL;
                    continue;
                }
                sub_str_end++;
            }
        }
        sub_str = sub_str_end;
        /*Gather the desired fallback TSC for 100G auto-negotiation*/
        if (*sub_str != '\0' && (*sub_str != 'm' && *sub_str != 'i')) {
            fallback_lane = sal_ctoi(sub_str, &sub_str_end);
            if (fallback_lane > 2 || fallback_lane < 0) {
                LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit, "Port %d: invalid default lane \"%d\"\n"),
                          port, fallback_lane));
                rv = SOC_E_FAIL;
                continue;
            } else {
                /*Validate that for a given lane configuration the selected
                 * fallback lane is valid.*/
                for (i = 0; soc_td2_valid_lanes[i].lane_config !=
                     SOC_INVALID_LANE_CONFIG; i++) {
                    if (soc_td2_valid_lanes[i].lane_config == lane_config) {
                        if (!soc_td2_valid_lanes[i].valid_lanes[fallback_lane]) {
                            fallback_lane = -1;
                            break;
                        }
                    }
                }
            }
            if (fallback_lane < 0) {
                LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit, "Port %d: invalid default lane \"%d\"\n"),
                           port, fallback_lane));
            }

            /* Skip ':' between 100G fallback port and options */
            sub_str = sub_str_end;
            if (*sub_str != '\0') {
                if (*sub_str != ':') {
                    LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit, "Port %d: Bad config string \"%s\"\n"),
                                        port, config_str));
                    rv = SOC_E_FAIL;
                    continue;
                }
                sub_str_end++;
            }
        }
        /* Check if option presents */
        option = 0;
        sub_str = sub_str_end;

        if (*sub_str != '\0') {
            if (*sub_str == 'm') {
                if (phy_port < 13 || phy_port > 16) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Port %d: Physical port %d can not be "
                                        "configured as management port\n"),
                             port, phy_port));
                    rv = SOC_E_FAIL;
                    continue;
                }
            } else if (*sub_str != 'i') {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d: Bad config string \"%s\"\n"),
                                    port, config_str));
                rv = SOC_E_FAIL;
                continue;
            }
            option = *sub_str;
            sub_str++;
        }

        /* Check trailing string */
        if (*sub_str != '\0') {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Bad config string \"%s\"\n"),
                     port, config_str));
            rv = SOC_E_FAIL;
            continue;
        }

        /* Update soc_info */
        si->port_p2l_mapping[phy_port]  = port;
        si->port_l2p_mapping[port]      = phy_port;
        si->port_speed_max[port]        = port_bandwidth;
        si->port_100g_lane_config[port] = lane_config;
        si->port_fallback_lane[port]    = fallback_lane;

        if (option == 'i') {
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port);
        } else if (option == 'm') {
            SOC_PBMP_PORT_ADD(si->management_pbm, port);
        }

        if (SOC_PBMP_MEMBER(oversub_pbm,port)) {
            SOC_PBMP_PORT_ADD(si->oversub_pbm, port);
        }

        port_count[pipe]++;
    }
    
    if (port_count[0] == 0 && port_count[1] == 0) {
        if (SOC_CONTROL(unit)->soc_flags & SOC_F_ATTACHED) { /* not for PCID */
            rv = SOC_E_FAIL;
        }
    }

    /* Bandwidth check for ports in each XLPORT/CPORT block */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        for (quad = 0; quad < _TD2_QUADS_PER_PIPE; quad++) {
            quad_linerate_bandwidth = 0;
            quad_oversub_bandwidth = 0;
            for (pgw = 0; pgw < _TD2_PGWS_PER_QUAD; pgw++) {
                pgw_linerate_bandwidth = 0;
                pgw_oversub_bandwidth = 0;

                /* Prepare per PGW local variables for ease of processing */
                for (index = 0; index < _TD2_PORTS_PER_PGW; index++) {
                    phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE +
                        quad * _TD2_PORTS_PER_QUAD +
                        pgw * _TD2_PORTS_PER_PGW + index;
                    port = si->port_p2l_mapping[phy_port];
                    pgw_port[index] = port;
                    if (port == -1) {
                        pgw_port_bandwidth[index] = 0;
                    } else if (si->port_speed_max[port] < 2500) {
                        pgw_port_bandwidth[index] = 2500;
                    } else {
                        pgw_port_bandwidth[index] = si->port_speed_max[port];
                    }
                }

                for (blk = 0; blk < _TD2_XLPS_PER_PGW; blk++) {
                    blk_port = &pgw_port[blk * _TD2_PORTS_PER_XLP];
                    blk_port_bandwidth =
                        &pgw_port_bandwidth[blk * _TD2_PORTS_PER_XLP];
                    blk_configured_map = 0;
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        if (blk_port[index] != -1) {
                            blk_configured_map |= 1 << index;
                        }
                    }
                    if (blk_configured_map == 0) {
                        continue;
                    }

                    /* Management port block (XLPORT3) handling */
                    if (pipe == 0 && quad == 0 && pgw == 0 && blk == 3 &&
                        SOC_PBMP_NOT_NULL(si->management_pbm)) {
                        blk_management_map = 0;
                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            port = blk_port[index];
                            if (port == -1) {
                                continue;
                            }
                            if (SOC_PBMP_MEMBER(si->management_pbm, port)) {
                                blk_management_map |= 1 << index;
                            }
                        }
                        if (blk_management_map != blk_configured_map) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port")));
                            for (index = 0; index < _TD2_PORTS_PER_XLP;
                                 index++) {
                                if (blk_port[index] != -1) {
                                    LOG_CLI((BSL_META_U(unit,
                                                        " %d"), blk_port[index]));
                                }
                            }
                            LOG_CLI((BSL_META_U(unit,
                                                ": Can not be configured to "
                                                "different management port status\n")));
                            rv = SOC_E_FAIL;
                            continue;
                        }

                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            port = blk_port[index];
                            if (port == -1) {
                                continue;
                            }
                            phy_port = si->port_l2p_mapping[port];
                            port_bandwidth = blk_port_bandwidth[index];
                            if (port_bandwidth > 10000 ||
                                (port_bandwidth > 2500 && index != 0)) {
                                LOG_CLI((BSL_META_U(unit,
                                                    "Management port %d: "
                                                    "Physical port %d can not be "
                                                    "configured to %d Gb\n"),
                                         port, phy_port,
                                         port_bandwidth / 1000));
                                rv = SOC_E_FAIL;
                                continue;
                            }
                        }
                        port_bandwidth = blk_port_bandwidth[0];
                        if (port_bandwidth > 2500) {
                            for (index = 1; index < _TD2_PORTS_PER_XLP;
                                 index++) {
                                port = blk_port[index];
                                if (port == -1) {
                                    continue;
                                }
                                LOG_CLI((BSL_META_U(unit,
                                                    "Management port %d bandwidth %d "
                                                    "Gb and port %d can not be both "
                                                    "configured\n"),
                                         blk_port[0],
                                         port_bandwidth / 1000, port));
                                rv = SOC_E_FAIL;
                            }
                        }
                        continue;
                    }

                    /* Normal port block handling */
                    blk_inactive_map = 0;
                    blk_oversub_map = 0;
                    blk_linerate_bandwidth = 0;
                    blk_oversub_bandwidth = 0;
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        port = blk_port[index];
                        if (port == -1) {
                            continue;
                        }
                        port_bandwidth = blk_port_bandwidth[index];
                        if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
                            blk_oversub_map |= 1 << index;
                        }
                        if (SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
                            blk_inactive_map |= 1 << index;
                        } else {
                            if (blk_oversub_map & (1 << index)) {
                                blk_oversub_bandwidth += port_bandwidth;
                            } else {
                                blk_linerate_bandwidth += port_bandwidth;
                            }
                        }
                        if ((port_bandwidth > 42000 &&
                             (index != 0 || blk != (pgw & 1))) ||
                            (port_bandwidth > 21000 && index != 0) ||
                            (port_bandwidth > 10000 && (index & 1))) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d: Physical port %d can not "
                                                "be configured to %d Gb\n"),
                                     port, si->port_l2p_mapping[port],
                                     port_bandwidth / 1000));
                            rv = SOC_E_FAIL;
                        }
                    }

                    /* Check if any the lanes used by first port of block is
                     * not used by other port */
                    port_bandwidth = blk_port_bandwidth[0];
                    if (port_bandwidth > 42000) {
                        lane_count = 12;
                    } else if (port_bandwidth > 21000) {
                        lane_count = 4;
                    } else if (port_bandwidth > 10000) {
                        lane_count = 2;
                    } else {
                        lane_count = 1;
                    }
                    for (index = 1; index < lane_count; index++) {
                        port = blk_port[index];
                        if (port == -1 ||
                            SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
                            continue;
                        }
                        LOG_CLI((BSL_META_U(unit,
                                            "Port %d bandwidth %d Gb and "
                                            "port %d can not be both configured\n"),
                                 blk_port[0], port_bandwidth / 1000, port));
                        rv = SOC_E_FAIL;
                    }

                    /* Check if any the lanes used by third port of block is
                     * not used by other port */
                    port_bandwidth = blk_port_bandwidth[2];
                    if (port_bandwidth > 10000) {
                        port = blk_port[3];
                        if (port != -1 &&
                            !SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d bandwidth %d Gb and port %d "
                                                "can not be both configured\n"),
                                     blk_port[2], port_bandwidth / 1000,
                                     port));
                            rv = SOC_E_FAIL;
                        }
                        if (blk_port[0] == -1) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Physical port %d needs to be "
                                                "configured in order to work with "
                                                "port %d\n"),
                                     1 + pipe * _TD2_PORTS_PER_PIPE +
                                     pgw * _TD2_PORTS_PER_PGW +
                                     blk * _TD2_PORTS_PER_XLP,
                                     blk_port[2]));
                            rv = SOC_E_FAIL;
                        }
                    }

                    if (blk_inactive_map == blk_configured_map) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Flex port")));
                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            if (blk_port[index] != -1) {
                                LOG_CLI((BSL_META_U(unit,
                                                    " %d"), blk_port[index]));
                            }
                        }
                        LOG_CLI((BSL_META_U(unit,
                                            ": Can not be all inactive\n")));
                        rv = SOC_E_FAIL;
                        continue;
                    }

                    if (blk_oversub_map != 0 &&
                        blk_oversub_map != blk_configured_map) {
                        /*
                         * Check whether user mixed line-rate and  
                         * oversubscription ports together within a TSC
                         */
                        LOG_CLI((BSL_META_U(unit,
                                            "%s"), 
                                 blk_inactive_map ? "Flex port" : "Port"));
                        for (index = 0; index < _TD2_PORTS_PER_XLP;
                             index++) {
                            if (blk_port[index] != -1) {
                                LOG_CLI((BSL_META_U(unit,
                                                    " %d"), blk_port[index]));
                            }
                        }
                        LOG_CLI((BSL_META_U(unit,
                                            ": Can not be configured to "
                                            "different oversubscription "
                                            "status\n")));
                        rv = SOC_E_FAIL;
                        continue;
                    }

                    port = blk_port[2];
                    if (port != -1) {
                        /* Check reserved bandwidth if lane 3 is inactive flex
                         * port and lane 2 is active */
                        if ((blk_inactive_map & 0x0c) == 0x08 &&
                            blk_port_bandwidth[2] <
                            blk_port_bandwidth[3] * 2) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d bandwidth %d Gb is not "
                                                "enough to cover flex port for "
                                                "port %d\n"),
                                     port, si->port_speed_max[port] / 1000,
                                     blk_port[3]));
                            rv = SOC_E_FAIL;
                        }
                    }

                    port = blk_port[0];
                    if (port != -1) {
                        /* Check reserved bandwidth if lane 3 is inactive flex
                         * port and lane 0 is active */
                        if ((blk_inactive_map & 0x09) == 0x08 &&
                            blk_port_bandwidth[0] <
                            blk_port_bandwidth[3] * 4) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d bandwidth %d Gb is not "
                                                "enough to cover flex port for "
                                                "port %d\n"),
                                     port, si->port_speed_max[port] / 1000,
                                     blk_port[3]));
                            rv = SOC_E_FAIL;
                        }

                        /* Check reserved bandwidth if lane 2 is inactive flex
                         * port and lane 0 is active */
                        if ((blk_inactive_map & 0x05) == 0x04 &&
                            blk_port_bandwidth[0] <
                            blk_port_bandwidth[2] * 2) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d bandwidth %d Gb is not "
                                                "enough to cover flex port for "
                                                "port %d\n"),
                                     port, si->port_speed_max[port] / 1000,
                                     blk_port[2]));
                            rv = SOC_E_FAIL;
                        }

                        /* Check reserved bandwidth if lane 1 is inactive flex
                         * port and lane 0 is active */
                        if ((blk_inactive_map & 0x03) == 0x02 &&
                            blk_port_bandwidth[0] <
                            blk_port_bandwidth[1] * 4) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d bandwidth %d Gb is not "
                                                "enough to cover flex port for "
                                                "port %d\n"),
                                     port, si->port_speed_max[port] / 1000,
                                     blk_port[1]));
                            rv = SOC_E_FAIL;
                        }
                    }
                    pgw_linerate_bandwidth += blk_linerate_bandwidth;
                    pgw_oversub_bandwidth += blk_oversub_bandwidth;
                } /* for (blk = 0; blk < _TD2_XLPS_PER_PGW; blk++) */
                quad_linerate_bandwidth += pgw_linerate_bandwidth;
                quad_oversub_bandwidth += pgw_oversub_bandwidth;
            } /* for (pgw = 0; pgw < _TD2_PGWS_PER_QUAD; pgw++) */

            index = pipe * _TD2_QUADS_PER_PIPE + quad;
            if (quad_linerate_bandwidth > max_quad_core_bandwidth[index]) {
                LOG_CLI((BSL_META_U(unit,
                                    "PGW_CL%d and PGW_CL%d total line rate bandwidth "
                                    "(%d Gb) exceeds %d Gb\n"),
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD,
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD + 1,
                         quad_linerate_bandwidth / 1000,
                         max_quad_core_bandwidth[index] / 1000));
                rv = SOC_E_FAIL;
            } else if (quad_linerate_bandwidth ==
                       max_quad_core_bandwidth[index] &&
                       quad_oversub_bandwidth != 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "PGW_CL%d and PGW_CL%d total line rate bandwidth "
                                    "(%d Gb) equals to max core bandwidth, no extra "
                                    "bandwidth for oversubscription ports\n"),
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD,
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD + 1,
                         quad_linerate_bandwidth / 1000));
                rv = SOC_E_FAIL;
            } else if (quad_oversub_bandwidth >
                       (max_quad_core_bandwidth[index] -
                        quad_linerate_bandwidth) * 2) {
                LOG_CLI((BSL_META_U(unit,
                                    "PGW_CL%d and PGW_CL%d total I/O "
                                    "oversubscription bandwidth (%d Gb) is more than "
                                    "2 times of core oversubscription bandwidth "
                                    "(2 * %d Gb)\n"),
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD,
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD + 1,
                         quad_oversub_bandwidth / 1000,
                         (max_quad_core_bandwidth[index] -
                         quad_linerate_bandwidth) / 1000));
                rv = SOC_E_FAIL;
            }
        } /* for (quad = 0; quad < _TD2_QUADS_PER_PIPE; quad++) */
    } /* for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) */

    if (SOC_FAILURE(rv)) {
        for (phy_port = 1; phy_port < 129; phy_port++) {
            si->port_p2l_mapping[phy_port] = -1;
        }
        return rv;
    }

    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
        LOG_CLI((BSL_META_U(unit,
                            "physical to logical mapping:")));
        for (index = 0; index < num_phy_port; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            LOG_CLI((BSL_META_U(unit,
                                " %3d"),
                     si->port_p2l_mapping[index]));
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
        LOG_CLI((BSL_META_U(unit,
                            "physical port bandwidth:")));
        for (index = 0; index < num_phy_port; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            port = si->port_p2l_mapping[index];
            if (port == -1) {
                LOG_CLI((BSL_META_U(unit,
                                    "  -1")));
            } else if (si->port_speed_max[port] == 2500) {
                LOG_CLI((BSL_META_U(unit,
                                    " 2.5")));
            } else {
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         si->port_speed_max[port] / 1000));
            }
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

    /* Setup port_group, num_lanes, xpipe_pbm and ypipe_pbm */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) { /* cpu, loopback, or unused port */
            continue;
        }
        /* 16 ports per PGW_CL */
        si->port_group[port] = (phy_port - 1) / _TD2_PORTS_PER_PGW;
        si->port_serdes[port] = (phy_port - 1) / _TD2_PORTS_PER_XLP;
        if (si->port_speed_max[port] > 107000) {
            si->port_num_lanes[port] = 12;
        } else if (si->port_speed_max[port] > 42000) {
            si->port_num_lanes[port] =  10;
        } else if (si->port_speed_max[port] > 20000) {
            si->port_num_lanes[port] =  4;
        } else if (si->port_speed_max[port] > 10000) {
            si->port_num_lanes[port] =  2;
        } else {
            si->port_num_lanes[port] =  1;
        }
        if (phy_port < si->phy_port_base[1]) { /* X-pipe */
            SOC_PBMP_PORT_ADD(si->xpipe_pbm, port);
        } else { /* Y-pipe */
            SOC_PBMP_PORT_ADD(si->ypipe_pbm, port);
        }
    }

    SOC_PBMP_ASSIGN(si->pipe_pbm[0], si->xpipe_pbm);
    SOC_PBMP_ASSIGN(si->pipe_pbm[1], si->ypipe_pbm);

    /* Setup vector-based scheduler (VBS)
     * a.k.a high speed port scheduler (HSP) pbm */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) { /* cpu, loopback, or unused port */
            continue;
        }
        if (si->port_speed_max[port] >= 100000 ||
            (si->port_speed_max[port] >= 40000 && si->frequency < 760) ||
            soc_property_port_get(unit, port, spn_PORT_SCHED_HSP, 0)) {
            SOC_PBMP_PORT_ADD(si->eq_pbm, port);
        }
    }

    /* Assign MMU port */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        mmu_port = pipe * _TD2_PORTS_PER_PIPE;
        /* First assign the lowest MMU port number for VBS (HSP) ports */
        pbmp = pipe ? si->ypipe_pbm : si->xpipe_pbm;
        SOC_PBMP_AND(pbmp, si->eq_pbm);
        SOC_PBMP_ITER(pbmp, port) {
            phy_port = si->port_l2p_mapping[port];
            while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                mmu_port++;
            }
            si->port_p2m_mapping[phy_port] = mmu_port;
            /* for HSP PBM, In TD2+, mmu_port + 36 is reserved */
            
            SOC_PBMP_PORT_ADD(pbmp_mmu_reserved, mmu_port+36);
            mmu_port++;
        }
        /* Then assign the next lowest MMU port number for 40+G ports */
        for (index = 0; index < _TD2_PORTS_PER_PIPE; index += 4) {
            phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
            port = si->port_p2l_mapping[phy_port];
            if (si->port_p2m_mapping[phy_port] == -1 &&
                si->port_speed_max[port] > 20000) {
                while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                    mmu_port++;
                }
                si->port_p2m_mapping[phy_port] = mmu_port;
                mmu_port++;
            }
        }
        /* Then assign the next lowest MMU port number for 20+G ports */
        for (index = 0; index < _TD2_PORTS_PER_PIPE; index += 2) {
            phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
            port = si->port_p2l_mapping[phy_port];
            if (si->port_p2m_mapping[phy_port] == -1 &&
                si->port_speed_max[port] > 10000) {
                while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                    mmu_port++;
                }
                si->port_p2m_mapping[phy_port] = mmu_port;
                mmu_port++;
            }
        }
        /* Finally assign MMU port number for all other ports */
        for (index = 0; index < _TD2_PORTS_PER_PIPE; index++) {
            phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
            port = si->port_p2l_mapping[phy_port];
            if (si->port_p2m_mapping[phy_port] == -1 &&
                si->port_speed_max[port] > 0) {
                while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                    mmu_port++;
                }
                si->port_p2m_mapping[phy_port] = mmu_port;
                mmu_port++;
            }
        }
        /* if we've gone out of range of the MMU ports per pipe (0-52 in X pipe, 64-116 in Y Pipe) */
        if ((mmu_port < 0) ||
            (mmu_port > 53 && mmu_port < 64) ||
            (mmu_port > 117)) {
             LOG_VERBOSE(BSL_LS_SOC_MMU,
                 (BSL_META_U(unit,
                             "MMU port resource allocation failure mmu_port %d\n"), mmu_port));
            return SOC_E_RESOURCE; 
        } 
    }

    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
        LOG_CLI((BSL_META_U(unit,
                            "physical to mmu mapping:")));
        for (index = 0; index < num_phy_port; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            LOG_CLI((BSL_META_U(unit,
                                " %3d"),
                     si->port_p2m_mapping[index]));
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

    return SOC_E_NONE;
}

int
soc_trident2_lls_bmap_alloc(int unit)
{
    soc_control_t *soc;
    soc_info_t *si;
    int port, phy_port, mmu_port, index;
    int alloc_size_l0, alloc_size_l1, alloc_size_l2;

    soc = SOC_CONTROL(unit);
    si = &SOC_INFO(unit);

    alloc_size_l0 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L0_PARENTm));
    alloc_size_l1 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L1_PARENTm));
    alloc_size_l2 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L2_PARENTm));

    PBMP_ALL_ITER(unit, port) {
        soc->port_lls_l0_bmap[port] = sal_alloc(alloc_size_l0, "LLS_L0_BMAP");
        soc->port_lls_l1_bmap[port] = sal_alloc(alloc_size_l1, "LLS_L1_BMAP");
        soc->port_lls_l2_bmap[port] = sal_alloc(alloc_size_l2, "LLS_L2_BMAP");
        sal_memset(soc->port_lls_l0_bmap[port], 0, alloc_size_l0);
        sal_memset(soc->port_lls_l1_bmap[port], 0, alloc_size_l1);
        sal_memset(soc->port_lls_l2_bmap[port], 0, alloc_size_l2);
        if (SOC_PBMP_MEMBER(si->eq_pbm, port)) { /* VBS (HSP) port */
            phy_port = si->port_l2p_mapping[port];
            mmu_port = si->port_p2m_mapping[phy_port];
            for (index = 0; index < 5; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l0_bmap[port],
                           (mmu_port & 0x3f) * 5 + index);
            }
            for (index = 0; index < 10; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l1_bmap[port],
                           (mmu_port & 0x3f) * 10 + index);
            }
            for (index = 0; index < 10; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l2_bmap[port],
                           (mmu_port & 0x3f) * 10 + index);
            }
        }
    }

    return SOC_E_NONE;
}

int
soc_trident2_chip_reset(int unit)
{
    soc_info_t *si;
    uint16 dev_id;
    uint8 rev_id;
    int skew_id;
    int max_frequency;
    uint32 rval, to_usec;
    soc_reg_t reg;
    int index;
    int num_ecmp_rh_flowset_entries;
    int rh_table_config_encoding;
    soc_field_t fields[4];
    uint32 values[4];
    int freq_list_len, sel;
    int const *freq_list;
#ifdef BCM_RIOT_SUPPORT
    int num_overlay_ecmp_rh_flowset_entries;
    int rh_bank_sel = 0x0;
    int ecmp_levels = 1;
#endif
    static const soc_reg_t lcpll_ctrl1_reg[] = {
        TOP_XG_PLL0_CTRL_1r, TOP_XG_PLL1_CTRL_1r,
        TOP_XG_PLL2_CTRL_1r, TOP_XG_PLL3_CTRL_1r
    };
    static const soc_reg_t lcpll_ctrl2_reg[] = {
        TOP_XG_PLL0_CTRL_2r, TOP_XG_PLL1_CTRL_2r,
        TOP_XG_PLL2_CTRL_2r, TOP_XG_PLL3_CTRL_2r
    };
    static const soc_reg_t lcpll_ctrl3_reg[] = {
        TOP_XG_PLL0_CTRL_3r, TOP_XG_PLL1_CTRL_3r,
        TOP_XG_PLL2_CTRL_3r, TOP_XG_PLL3_CTRL_3r
    };
    static const soc_reg_t lcpll_ctrl4_reg[] = {
        TOP_XG_PLL0_CTRL_4r, TOP_XG_PLL1_CTRL_4r,
        TOP_XG_PLL2_CTRL_4r, TOP_XG_PLL3_CTRL_4r
    };
    static const soc_reg_t lcpll_status_reg[] = {
        TOP_XG_PLL0_STATUSr, TOP_XG_PLL1_STATUSr,
        TOP_XG_PLL2_STATUSr, TOP_XG_PLL3_STATUSr
    };
    soc_field_t top_soft_rst_field = TOP_TEMP_MON_PEAK_RST_Lf;


    si = &SOC_INFO(unit);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        top_soft_rst_field = TOP_PVT_MON_MIN_RST_Lf;
    }
#endif

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    to_usec = SAL_BOOT_QUICKTURN ? (250 * MILLISECOND_USEC) :
                                   (10 * MILLISECOND_USEC);

    /*             Trident 2
     * SBUS ring and block number:
     * ring 0: IP(1)
     * ring 1: EP(2)
     * ring 2: MMU(3)
     * ring 3: PGW_CL0(6), CPORT0(14), XLPORT0(15)-XLPORT3(18)
     *         PGW_CL1(7), CPORT1(19), XLPORT4(20)-XLPORT7(23)
     * ring 4: PGW_CL2(8), CPORT2(24), XLPORT8(25)-XLPORT11(28)
     *         PGW_CL3(9), CPORT3(29), XLPORT12(30)-XLPORT15(33)
     * ring 5: OTPC(5), TOP(57), SER(58)
     * ring 6: PGW_CL4(10), CPORT4(34), XLPORT16(35)-XLPORT19(38)
     *         PGW_CL5(11), CPORT5(39), XLPORT20(40)-XLPORT23(43)
     * ring 7: PGW_CL6(12), CPORT6(44), XLPORT24(45)-XLPORT27(48)
     *         PGW_CL7(13), CPORT7(49), XLPORT28(50)-XLPORT31(53)
     */

    /*             Trident 2+
     * SBUS ring and block number:
     * ring 0: IP(1)
     * ring 1: EP(2)
     * ring 2: MMU(3)
     * ring 3: PGW_CL0(6), CPORT0(14), XLPORT0(15)-XLPORT3(18)
     *         PGW_CL1(7), CPORT1(19), XLPORT4(20)-XLPORT7(23)
     * ring 4: PGW_CL2(8), CPORT2(24), XLPORT8(25)-XLPORT11(28)
     *         PGW_CL3(9), CPORT3(29), XLPORT12(30)-XLPORT15(33)
     * ring 5: OTPC(4), TOP(57), SER(58), AVS(59)
     * ring 6: PGW_CL4(10), CPORT4(34), XLPORT16(35)-XLPORT19(38)
     *         PGW_CL5(11), CPORT5(39), XLPORT20(40)-XLPORT23(43)
     * ring 7: PGW_CL6(12), CPORT6(44), XLPORT24(45)-XLPORT27(48)
     *         PGW_CL7(13), CPORT7(49), XLPORT28(50)-XLPORT31(53)
     *
     *      OTPC  => {
     *          REGBASE    => 0,
     *          MEMBASE    => 0,
     *          DESC       => 'OTP',
     *          BLKTYPE    => OTPC,
     *          SCHANNUM   => 4,
     *          BLOCKNUM   => 4, <---- 
     *          VENDOR     => 'BROADCOM',
     *      },
     *
     */

    WRITE_CMIC_SBUS_RING_MAP_0_7r(unit, 0x33052100);
    WRITE_CMIC_SBUS_RING_MAP_8_15r(unit, 0x33776644);
    WRITE_CMIC_SBUS_RING_MAP_16_23r(unit, 0x33333333);
    WRITE_CMIC_SBUS_RING_MAP_24_31r(unit, 0x44444444);
    WRITE_CMIC_SBUS_RING_MAP_32_39r(unit, 0x66666644);
    WRITE_CMIC_SBUS_RING_MAP_40_47r(unit, 0x77776666);
    WRITE_CMIC_SBUS_RING_MAP_48_55r(unit, 0x00777777);
    if (!SOC_IS_TRIDENT2PLUS(unit)) {
        WRITE_CMIC_SBUS_RING_MAP_56_63r(unit, 0x00000550);
    } else {
        /*Adding AVS to ring 5*/
        WRITE_CMIC_SBUS_RING_MAP_56_63r(unit, 0x00005550);
    }

    WRITE_CMIC_SBUS_TIMEOUTr(unit, 0x7d0);

    sal_usleep(to_usec);


    SOC_IF_ERROR_RETURN(READ_TOP_DEV_REV_IDr(unit, &rval));
    skew_id = soc_reg_field_get(unit, TOP_DEV_REV_IDr, rval, DEVICE_SKEWf);
    SOC_IF_ERROR_RETURN
        (soc_trident2_max_frequency_get(unit, dev_id, rev_id, skew_id,
                                        &max_frequency));

    if (SOC_IS_TRIDENT2(unit)) {
        if (rev_id <= BCM56850_A1_REV_ID) {
            freq_list = a1_freq_list;
            freq_list_len = sizeof(a1_freq_list) / sizeof(int);
        } else {
            if (max_frequency == 793) {
                freq_list = a2_793_freq_list;
                freq_list_len = sizeof(a2_793_freq_list) / sizeof(int);
            } else {
                freq_list = a2_635_freq_list;
                freq_list_len = sizeof(a2_635_freq_list) / sizeof(int);
            }
        }
    } else {
        freq_list = a1_td2p_freq_list;
        freq_list_len = sizeof(a1_td2p_freq_list) / sizeof(int);
    }
        
    if ((si->frequency != max_frequency) 
        || (si->frequency != freq_list[0])) {
        if (si->frequency > max_frequency) {
            si->frequency = max_frequency;
        }
        for (sel = 1; sel < freq_list_len; sel++) { /* skip index 0 */
            if (si->frequency == freq_list[sel]) {
                break;
            }
        }
        if (sel < freq_list_len) {
            LOG_CLI((BSL_META_U(unit,
                                "*** change CORE_CLK_FREQ_SEL to %d\n"), sel));
            LOG_CLI((BSL_META_U(unit,
                                "*** change core clock frequency to %dMHz\n"),
                     si->frequency));

            SOC_IF_ERROR_RETURN(READ_TOP_CORE_CLK_FREQ_SELr(unit, &rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval,
                              SW_CORE_CLK_SEL_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval,
                              CORE_CLK_FREQ_SELf, sel);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));

            if (SOC_IS_TRIDENT2(unit)) {
                soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval, LOAD_ENf,
                                  1);
                SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
                soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval, LOAD_ENf,
                                  0);
                SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
            }

            sal_usleep(to_usec);
        }
    }


    /* Program LCPLL frequency */
    for (index = 0; index < 4; index++) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, lcpll_ctrl1_reg[index],
                                    REG_PORT_ANY, PDIVf, 7));
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, lcpll_ctrl2_reg[index],
                                    REG_PORT_ANY, NDIV_INTf, 140));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, lcpll_ctrl3_reg[index],
                                    REG_PORT_ANY, CML_BYP_ENf, 1));
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, lcpll_ctrl4_reg[index],
                                    REG_PORT_ANY, NDIV_INTf, 140));
        }
    }
    fields[0] = CMIC_TO_XG_PLL0_SW_OVWRf;
    values[0] = 1;
    fields[1] = CMIC_TO_XG_PLL1_SW_OVWRf;
    values[1] = 1;
    fields[2] = CMIC_TO_XG_PLL2_SW_OVWRf;
    values[2] = 1;
    fields[3] = CMIC_TO_XG_PLL3_SW_OVWRf;
    values[3] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, TOP_MISC_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    rval = 0;

    /* Configure TS PLL */ 
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_PDIV, 1));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_MNDIV, 14));
        WRITE_TOP_TS_PLL_CTRL_3r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_2r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_PDIV, 1));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_MNDIV, 14));
        WRITE_TOP_TS_PLL_CTRL_2r(unit, rval);
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_4r(unit,&rval));    
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, NDIV_INTf,
                      soc_property_get(unit, spn_PTP_TS_PLL_N, 140));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_TS_PLL_CTRL_4r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit,&rval));    
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_INTf,
                      soc_property_get(unit, spn_PTP_TS_PLL_N, 140));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_TS_PLL_CTRL_3r(unit, rval);
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_5r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_5r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_TS_KA, 0));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_5r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_TS_KI, 2));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_5r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_TS_KP, 3));
        WRITE_TOP_TS_PLL_CTRL_5r(unit, rval);

        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_1r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_1r, &rval, FREF_SELf, 0);
        WRITE_TOP_TS_PLL_CTRL_1r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_TS_KA, 2));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_TS_KI, 4));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_TS_KP, 9));
        if (soc_property_get(unit, spn_PTP_TS_PLL_FREF, 0) == 0) {
            soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, REFCLK_SELf, 0);
        }
        else {
            soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, REFCLK_SELf, 1);
        }
        WRITE_TOP_TS_PLL_CTRL_4r(unit, rval);
    }
    
    /* Set 250Mhz (implies 4ns resolution) default timesync clock to 
       calculate assymentric delays */
    SOC_TIMESYNC_PLL_CLOCK_NS(unit) = (1/250 * 1000); /* clock period in nanoseconds */
     
    /* Configure BS PLL */
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_0r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_0r, &rval, VCO_FB_DIV2f,
                      1);  /* soc_property_get(unit, spn_BROAD_SYNC_VCO_DIV2, 1)); */
        WRITE_TOP_BS_PLL_CTRL_0r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_0r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_0r, &rval, VCO_DIV2f,
                      1);  /* soc_property_get(unit, spn_BROAD_SYNC_VCO_DIV2, 1)); */
        WRITE_TOP_BS_PLL_CTRL_0r(unit, rval);
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_BS_PDIV, 1));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_BS_MNDIV, 250));
        WRITE_TOP_BS_PLL_CTRL_3r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_2r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_2r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_BS_PDIV, 1));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_BS_MNDIV, 175));
        WRITE_TOP_BS_PLL_CTRL_2r(unit, rval);
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, NDIV_INTf, 140);
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_BS_PLL_CTRL_4r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, NDIV_INTf, 140);
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_BS_PLL_CTRL_3r(unit, rval);
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_5r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_5r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_BS_KA, 0));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_5r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_BS_KI, 2));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_5r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_BS_KP, 3));
        WRITE_TOP_BS_PLL_CTRL_5r(unit, rval);

        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_1r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_1r, &rval, FREF_SELf, 0);
        WRITE_TOP_TS_PLL_CTRL_1r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_BS_KA, 2));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_BS_KI, 4));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_BS_KP, 9));
        if (soc_property_get(unit, spn_PTP_BS_FREF, 0) == 0) {
            soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, REFCLK_SELf, 0);
        }
        else {
            soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, REFCLK_SELf, 1);
        }
        WRITE_TOP_BS_PLL_CTRL_4r(unit, rval);
    }

    /* Bring LCPLL, time sync PLL, BroadSync PLL out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit,&rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL0_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL1_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL2_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL3_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL_RST_Lf,
                      1);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_ARS_PMB_CLK_ENf,
                      1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_AVS_PMB_RST_Lf,
                      1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_ARS_RST_Lf,
                      1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_AVS_PVTMON_RST_Lf,
                      1);
    }
#endif

    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    sal_usleep(to_usec);

    if (!SAL_BOOT_SIMULATION) {
        /* Check LCPLL lock status */
        for (index = 0; index < 4; index++) {
            reg = lcpll_status_reg[index];
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            if (!soc_reg_field_get(unit, reg, rval, TOP_XGPLL_LOCKf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "LCPLL %d not locked on unit %d "
                                      "status = 0x%08x\n"), index, unit, rval));
            }
        }
        /* Check time sync lock status */
        reg = TOP_TS_PLL_STATUSr;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "TS_PLL %d not locked on unit %d "
                                  "status = 0x%08x\n"), index, unit, rval));
        }
        /* Check BroadSync lock status */
        reg = TOP_BS_PLL_STATUSr;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "BS_PLL %d not locked on unit %d "
                                  "status = 0x%08x\n"), index, unit, rval));
        }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            /* Check Core PLL lock status */
            reg = TOP_CORE_PLL_STATUSr;
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "CORE_PLL %d not locked on unit %d "
                                    "status = 0x%08x\n"), index, unit, rval));
            }
            /* Check Mcs PLL lock status */
            reg = TOP_MCS_PLL_STATUSr;
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "MCS_PLL %d not locked on unit %d "
                                    "status = 0x%08x\n"), index, unit, rval));
            }
        }
#endif
    }

    /* De-assert LCPLL's post reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL0_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL1_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL2_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL3_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TS_PLL_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_BS_PLL_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      top_soft_rst_field, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    sal_usleep(to_usec);

    /* Bring port blocks out of reset */
    rval = 0;
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP0_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP1_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP2_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP3_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP4_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP5_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP6_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP7_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_TS_RST_Lf, 1);
    WRITE_TOP_SOFT_RESET_REGr(unit, rval);

    sal_usleep(to_usec);

    /* Bring IP, EP, and MMU blocks out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_IP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_EP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_MMU_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));

    sal_usleep(to_usec);

    num_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_ECMP_RESILIENT_HASH_SIZE, 32768);
    switch (num_ecmp_rh_flowset_entries) {
        case 0:
            rh_table_config_encoding = 2;
            break;
        case 32768:
            rh_table_config_encoding = 0;
            break;
        case 65536:
            rh_table_config_encoding = 1;
            break;
        default:
            return SOC_E_CONFIG;
    }
#ifdef BCM_RIOT_SUPPORT
    ecmp_levels = soc_property_get(unit, spn_L3_ECMP_LEVELS, 1);
    if (soc_feature(unit, soc_feature_riot) &&
        ecmp_levels > 1) {

        num_overlay_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_RIOT_OVERLAY_ECMP_RESILIENT_HASH_SIZE, 0);

        if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 0, 16384)) {  

            num_overlay_ecmp_rh_flowset_entries = 16384;
        } else if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 16384, 32768)) {  

            num_overlay_ecmp_rh_flowset_entries = 32768;
        } else if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 32768, 49152)) {  

            num_overlay_ecmp_rh_flowset_entries = 49152;
        } else if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 49152, 65536)) {  

            num_overlay_ecmp_rh_flowset_entries = 65536;
        }

        switch (num_overlay_ecmp_rh_flowset_entries) {
        case 0:
            rh_bank_sel = 0x0;
            break;
        case 16384:
            if (num_ecmp_rh_flowset_entries >= 16384) {
                rh_bank_sel = 0x1;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        case 32768:
            if (num_ecmp_rh_flowset_entries >= 32768) {
                rh_bank_sel = 0x3;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        case 49152:
            if (num_ecmp_rh_flowset_entries >= 49152) {
                rh_bank_sel = 0x7;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        case 65536:
            if (num_ecmp_rh_flowset_entries >= 65536) {
                rh_bank_sel = 0xf;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        default:
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s: Value for overlay RH entries is not correct : %d \n"), 
                    FUNCTION_NAME(),  num_overlay_ecmp_rh_flowset_entries)); 
            return SOC_E_CONFIG;
    }
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, RH_ECMP_FLOWSET_BANK_SELr,
                REG_PORT_ANY, BANK_SELf,
                rh_bank_sel));
  }
#endif

    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, ENHANCED_HASHING_CONTROLr,
                REG_PORT_ANY, RH_FLOWSET_TABLE_CONFIG_ENCODINGf,
                rh_table_config_encoding));

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        READ_TOP_PVTMON_CTRL_1r(unit, &rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_ADC_RESETBf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_ADC_RESETBf, 0);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_ADC_RESETBf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    } else {
        READ_TOP_PVTMON_CTRL_1r(unit, &rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 0);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    }

    sal_usleep(1000);

    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    /* Do not use SBUS MDIO by default */
    SOC_FUNCTIONS(unit)->soc_sbus_mdio_read = NULL;
    SOC_FUNCTIONS(unit)->soc_sbus_mdio_write = NULL;

    /* Optionally allow SBUS MDIO for debug */
    if (soc_property_get(unit, "td2_sbus_mdio", 0)) {
        SOC_FUNCTIONS(unit)->soc_sbus_mdio_read = _soc_trident2_mdio_reg_read;
        SOC_FUNCTIONS(unit)->soc_sbus_mdio_write = _soc_trident2_mdio_reg_write;
    }

    return SOC_E_NONE;
}

int
soc_trident2_tsc_reset(int unit)
{
    int blk, port;
    uint32 rval;

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    /* TSC reset is controlled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_NONE;
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);

        SOC_IF_ERROR_RETURN(READ_XLPORT_MAC_CONTROLr(unit, port, &rval));
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
        sal_udelay(10);
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_enabled_port_data(int unit)
{
    uint32 rval;
    uint64 rval64;
    int port, block, pgw;
    uint32 evc = 0;
    
    /* Some registers are implemented in memory, need to clear them in order
     * to have correct parity value */
    COMPILER_64_ZERO(rval64);
    PBMP_ALL_ITER(unit, port) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
            egr_vlan_control_1_entry_t entry;
            sal_memset(&entry, 0, sizeof(entry));
            WRITE_EGR_VLAN_CONTROL_1m(unit, MEM_BLOCK_ANY, port, &entry);
        } else
#endif
        {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, 0));
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
            egr_vlan_control_2_entry_t entry;
            sal_memset(&entry, 0, sizeof(entry));
            WRITE_EGR_VLAN_CONTROL_2m(unit, MEM_BLOCK_ANY, port, &entry);
        } else
#endif
        {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_2r(unit, port, 0));
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
            egr_vlan_control_3_entry_t entry;
            sal_memset(&entry, 0, sizeof(entry));
            WRITE_EGR_VLAN_CONTROL_3m(unit, MEM_BLOCK_ANY, port, &entry);
        } else
#endif
        {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_3r(unit, port, 0));
        }
        SOC_IF_ERROR_RETURN(WRITE_EGR_PVLAN_EPORT_CONTROLr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_SF_SRC_MODID_CHECKr(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_EGR_1588_LINK_DELAY_64r(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_EGR_FCOE_INVALID_CRC_FRAMESr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_FCOE_DELIMITER_ERROR_FRAMESr(unit, port, 0));
        if (SOC_MEM_IS_VALID(unit, EGR_IPMC_CFG2m)) {
            SOC_IF_ERROR_RETURN(WRITE_EGR_IPMC_CFG2m(unit, MEM_BLOCK_ALL, port, &evc));
        } else {
            SOC_IF_ERROR_RETURN(WRITE_EGR_IPMC_CFG2r(unit, port, 0));
        }
        SOC_IF_ERROR_RETURN(WRITE_ING_TRILL_ADJACENCYr(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_STORM_CONTROL_METER_CONFIGr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_SFLOW_ING_THRESHOLDr(unit, port, 0));
    }
    rval = 0;
    soc_reg_field_set(unit, PGW_MIB_RESETr, &rval, CLR_CNTf, 0xffff);
    for (pgw = 0; pgw < 8; pgw++) {
        block = PGW_CL_BLOCK(unit, pgw);
        port = SOC_BLOCK_PORT(unit, block);
        if (port < 0) { /* the PGW_CL block is not in use */
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, PGW_MIB_RESETr, port, 0, rval));
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, PGW_MIB_RESETr, port, 0, 0));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_all_port_data(int unit)
{
    int r, p;
    uint32 addr;
    
    SOC_IF_ERROR_RETURN(_soc_trident2_clear_enabled_port_data(unit));
    
    /* Clear TDBGCn regs for all indexes */
    for (r = 0; r < 12; r++) {
        addr = 0x28000000 + r*0x100;
        for (p = 0; p < 106; p++) {
            _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
            _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
        }
    }

    /* Clear EGR_TRILL_TX_PKTS */
    addr = 0x28000c00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear EGR_TRILL_TX_ACCESS_PORT_TRILL_PKTS_DISCARDED */
    addr = 0x28000d00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear EGR_TRILL_TX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED */
    addr = 0x28000e00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear TPCE */
    addr = 0x28000f00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_all_memory(int unit, int mmu_init)
{
    uint32              rval, in_progress;
    int                 pipe_init_usec, index, count;
    soc_timeout_t       to;
    static const struct {
        soc_mem_t mem;
        uint32 skip_flags; /* always skip on QUICKTURN or XGSSIM */
    } cam_list[] = {
        { CPU_COS_MAPm,                     BOOT_F_PLISIM },
        { EFP_TCAMm,                        BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAMm,             BOOT_F_PLISIM },
        { FP_TCAMm,                         BOOT_F_PLISIM },
        { FP_UDF_TCAMm,                     BOOT_F_PLISIM },
        { ING_SNATm,                        BOOT_F_PLISIM },
        { IP_MULTICAST_TCAMm,               BOOT_F_PLISIM },
        { L2_USER_ENTRYm,                   BOOT_F_PLISIM },
        { L3_DEFIPm,                        BOOT_F_PLISIM },
        { L3_DEFIP_PAIR_128m,               BOOT_F_PLISIM },
        { L3_TUNNELm,                       BOOT_F_PLISIM },
        { MY_STATION_TCAMm,                 BOOT_F_PLISIM },
        { UDF_CONDITIONAL_CHECK_TABLE_CAMm, BOOT_F_PLISIM },
        { VFP_TCAMm,                        BOOT_F_PLISIM },
        { VLAN_SUBNETm,                     0 },/* VLAN API needs all 0 mask */
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        { MY_STATION_TCAM_2m,               BOOT_F_PLISIM },
        { SUBPORT_TAG_SGPP_MAPm,            BOOT_F_PLISIM },
#endif
#ifdef PLISIM
        /* In HW, these are the same as FP_GLOBAL_MASK_TCAM.
         * In simulation, they are separate instances.
         */
        { FP_GM_FIELDSm,                    BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAM_Xm,           BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAM_Ym,           BOOT_F_PLISIM }
#endif
    };

    if (mmu_init) {
        /* Start MMU memory initialization */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, MISCCONFIGr, REG_PORT_ANY, INIT_MEMf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, MISCCONFIGr, REG_PORT_ANY, INIT_MEMf, 1));
        sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
    }
    SOC_IF_ERROR_RETURN
        (_soc_trident2_mmu_init_default_val(unit));

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries of largest IPIPE table */
    count = soc_mem_index_count(unit, RH_HGT_FLOWSETm);
    if (count < soc_mem_index_count(unit, L2Xm)) {
        count = soc_mem_index_count(unit, L2Xm);
    }
    if (count < soc_mem_index_count(unit, L3_ENTRY_ONLYm)) {
        count = soc_mem_index_count(unit, L3_ENTRY_ONLYm);
    }
    if (count < soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV4m)) {
        count = soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV4m);
    }
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, count);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /* Set count to # entries of largest EPIPE table (EGR_L3_NEXT_HOP) */
    count = soc_mem_index_count(unit, EGR_L3_NEXT_HOPm);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, COUNTf, count);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    in_progress = 3;
    do {
        if (in_progress & 0x1) { /* X pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2_Xr(unit, &rval));
            if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2_Xr, rval,
                                  DONEf)) {
                in_progress &= ~0x1;
            }
        }
        if (in_progress & 0x2) { /* Y pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2_Yr(unit, &rval));
            if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2_Yr, rval,
                                  DONEf)) {
                in_progress &= ~0x2;
            }
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : ING_HW_RESET timeout\n"), unit));
            break;
        }
    } while (in_progress != 0);

    /* Wait for EPIPE memory initialization done. */
    in_progress = 3;
    do {
        if (in_progress & 0x1) { /* X pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1_Xr(unit, &rval));
            if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1_Xr, rval,
                                  DONEf)) {
                in_progress &= ~0x1;
            }
        }
        if (in_progress & 0x2) { /* Y pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1_Yr(unit, &rval));
            if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1_Yr, rval,
                                  DONEf)) {
                in_progress &= ~0x2;
            }
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : EGR_HW_RESET timeout\n"), unit));
            break;
        }
    } while (in_progress != 0);

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* TCAM tables are not handled by hardware reset control */
    if (!SAL_BOOT_QUICKTURN && !SAL_BOOT_XGSSIM) {
        for (index = 0; index < sizeof(cam_list) / sizeof(cam_list[0]);
             index++) {
            if (sal_boot_flags_get() & cam_list[index].skip_flags) {
                continue;
            }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (!SOC_IS_TRIDENT2PLUS(unit) && 
            	  ((cam_list[index].mem == MY_STATION_TCAM_2m) || 
            	   (cam_list[index].mem == SUBPORT_TAG_SGPP_MAPm))) {
                continue;
            } 
#endif
            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, cam_list[index].mem, COPYNO_ALL, TRUE));
        }
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_port_mapping_init(int unit)
{
    soc_info_t *si;
    soc_mem_t mem;
    uint32 rval;
    ing_physical_to_logical_port_number_mapping_table_entry_t entry;
    int port, phy_port;
    int num_port, num_phy_port;

    si = &SOC_INFO(unit);

    /* Ingress physical to logical port mapping */
    mem = ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm;
    num_phy_port = soc_mem_index_count(unit, mem);
    sal_memset(&entry, 0, sizeof(entry));
    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        port = si->port_p2l_mapping[phy_port];
        soc_mem_field32_set(unit, mem, &entry, LOGICAL_PORT_NUMBERf,
                            port == -1 ? 0x7f : port);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, phy_port, &entry));
    }

    /* Ingress logical to physical port mapping */
    num_port = soc_mem_index_count(unit, PORT_TABm) - 1;
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        if (phy_port != -1) {
            soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr, &rval,
                              VALIDf, 1);
            if (SOC_PBMP_MEMBER(si->ypipe_pbm, port)) { /* Y pipe */
                soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr,
                                  &rval, Y_PIPEf, 1);
            }
            /* IFP_GM_LOGICAL_TO_PHYSICAL_MAPP?ING.PHYSICAL_PORT_NUM is
             * merely a unique stream ID, it's not physical port number */
            soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr, &rval,
                              PHYSICAL_PORT_NUMf,
                              si->port_p2m_mapping[phy_port] & 0x3f);
        }
        SOC_IF_ERROR_RETURN
            (WRITE_IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr(unit, port, rval));
    }

    /* Egress logical to physical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        soc_reg_field_set(unit, EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr,
                          &rval, PHYSICAL_PORT_NUMBERf,
                          phy_port == -1 ? 0xff : phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(unit, port,
                                                                rval));
    }

    /* MMU to physical port mapping and MMU to logical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) {
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_PHY_PORT_MAPPINGr, &rval,
                          PHY_PORTf, phy_port);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, MMU_PORT_TO_PHY_PORT_MAPPINGr, port, 0,
                           rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_LOGIC_PORT_MAPPINGr, &rval,
                          LOGIC_PORTf, port);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, MMU_PORT_TO_LOGIC_PORT_MAPPINGr, port, 0,
                           rval));
    }

    return SOC_E_NONE;
}

STATIC void
_soc_trident2_quad_bandwidth_calculate(int unit, int quad,
                                       int *max_quad_core_bandwidth,
                                       int *quad_linerate_bandwidth,
                                       int *quad_oversub_bandwidth)
{
    soc_info_t *si;
    int port, phy_port, index;
    int bandwidth;

    si = &SOC_INFO(unit);

    if (si->bandwidth == 720000) {
        *max_quad_core_bandwidth = quad == 0 || quad == 3 ? 160000 : 200000;
    } else {
        *max_quad_core_bandwidth = si->bandwidth / 4;
    }
    *quad_linerate_bandwidth = 0;
    *quad_oversub_bandwidth = 0;
    for (index = 0; index < _TD2_PORTS_PER_QUAD; index++) {
        phy_port = 1 + quad * _TD2_PORTS_PER_QUAD + index;
        port = si->port_p2l_mapping[phy_port];
        if (port == -1) {
            continue;
        }
        if (si->port_speed_max[port] > 20000) {
            bandwidth = 40000;
        } else if (si->port_speed_max[port] > 10000) {
            bandwidth = 20000;
        } else {
            bandwidth = 10000;
        }
        if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
            *quad_oversub_bandwidth += bandwidth;
        } else {
            *quad_linerate_bandwidth += bandwidth;
        }
    }
}

#define MGM_TOKEN (NUM_EXT_PORTS+3)

#define PORT_STATE_UNUSED              0
#define PORT_STATE_LINERATE            1
#define PORT_STATE_OVERSUB             2
#define PORT_STATE_SUBPORT             3 /* part of other port */

typedef struct _soc_trident2_tdm_s {
    int speed[NUM_EXT_PORTS];
    int tdm_bw;
    int port_state[NUM_EXT_PORTS]; /* 0-unused, 1-line rate, 2-oversub,
                                    * 3-part of other port */
    int pipe_ovs_state[2];
    int manage_port_type; /* 0-none, 1-4x1g, 2-4x2.5g, 3-1x10g */

    int pgw_tdm[_PGW_MASTER_COUNT][MAX_PGW_TDM_LENGTH];
    int pgw_ovs_tdm[_PGW_MASTER_COUNT][_PGW_TDM_OVS_SIZE];
    int pgw_ovs_spacing[_PGW_MASTER_COUNT][_PGW_TDM_OVS_SIZE];
    int mmu_tdm[2][_MMU_TDM_LENGTH + 1];
    int mmu_ovs_group_tdm[2][MAX_MMU_OVS_GROUP_COUNT][_MMU_OVS_GROUP_TDM_LENGTH];
    int iarb_tdm_wrap_ptr[2];
    int iarb_tdm[2][_IARB_TDM_LENGTH];
#ifdef BCM_TRIDENT2PLUS_SUPPORT
	int encap_type[_TD2P_NUM_PORT_MODULES];
#endif
} _soc_trident2_tdm_t;
_soc_trident2_tdm_t _soc_td2_tdm;

STATIC int
_soc_trident2_get_prio_map(int unit, int port, uint16 *pri_mask)
{
    char name[80];
    int  pri_to_prigroup[16];
    int  prio;

    if (NULL == pri_mask) {
        return SOC_E_PARAM;
    }

    /* internal priority to priority group mapping */
    sal_sprintf(name, "%s.%s.%s.%s", spn_BUF, spn_MAP, spn_PRI, spn_PRIGROUP);

    sal_memset(pri_to_prigroup, 0, sizeof(pri_to_prigroup));

    /* OBM Priority Map configuration needs to be in sync with MMU
     * configuration. If the config property is set use the prigroup map.
     * else use the default lossless setting.
     */
    if (soc_property_port_get_csv(unit, port, name,
                                  (_SOC_TD2_MAX_INTERNAL_PRIORITY + 1),
                                  pri_to_prigroup)) {
        *pri_mask = 0;
        for (prio=0; prio <= _SOC_TD2_MAX_INTERNAL_PRIORITY; prio++) {
            /*  PG7 (_SOC_TD2_MAX_PRIORITY) is mapped to Lossless priority, 
             *  If the config priority is lossless priority, Then Flow control
             *  is enabled.
             */
            if (pri_to_prigroup[prio] == _SOC_TD2_MAX_PRIORITY) {
                *pri_mask |= 1 << prio;
            }
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_tdm_init(int unit)
{
    soc_info_t *si;
    soc_pbmp_t pbmp;
    int port, phy_port, mmu_port, block, obm_inst;
    int pipe, pgw, xlp, tsc, group, slot, length, base, index, count, id;
    int wt_group = 0;
	int rv;
#ifdef BCM_56850_A0
	enum tdm_td2_port_speed td2_spd[TDM_TD2_NUM_EXT_PORTS];
#endif
#ifdef BCM_56860_A0
    tdm_soc_t _chip_pkg;
    tdm_mod_t *_tdm_pkg;
#endif
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int wt_group_select;
#endif
    int pgw_master, pgw_slave;
    int lossless;
    int speed_max, weight;
    int mtu_cells, res_cells, port_cells;
    uint32 xlport_map;
    soc_reg_t reg;
    soc_mem_t mem;
    uint64 rval64, ctrl_rval64;
    uint32 rval;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_field_t fields[4];
    uint32 values[4];
    int max_quad_core_bandwidth, quad_oversub_core_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    uint16 dev_id;
    uint8 rev_id;
    int obm_setting_idx, oversub_ratio_idx;
    int min_threshold, xoff_threshold, xon_threshold, xon_threshold_offset;
    uint16 pri_mask;

    static const struct _obm_setting_s {
        int max_threshold;
        int xoff_threshold[3]; /* for oversub ratio 1.27, 1.43, and above */
    } obm_settings[] = {
        { _TD2_TD2_CELLS_PER_OBM / 4, { 79, 26, 37 } },      /* 10G */
        { _TD2_TD2_CELLS_PER_OBM / 2, { 315, 242, 86 } },    /* 20G */
        { _TD2_TD2_CELLS_PER_OBM, { 707, 584, 339 } }        /* 40G */
    };
    static const struct _obm_setting_a1_s {
        int xoff_threshold[3]; /* for oversub ratio 1.33, 1.5, and above */
        int mtu_cells[3];      /* for oversub ratio 1.33, 1.5, and above */
    } obm_settings_a1[] = {
        { /* 10G */
            { 56, 40, 23 },
            { 5 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              3 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              2 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        },
        { /* 20G */
            { 215, 115, 60 },
            { 9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              6 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        },
        { /* 40G */
            { 661, 543, 306 },
            { 9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        }
    };
    static const soc_reg_t pgw_ovs_spacing_regs[] = {
        PGW_OS_PORT_SPACING_REG_0r, PGW_OS_PORT_SPACING_REG_1r,
        PGW_OS_PORT_SPACING_REG_2r, PGW_OS_PORT_SPACING_REG_3r,
        PGW_OS_PORT_SPACING_REG_4r, PGW_OS_PORT_SPACING_REG_5r,
        PGW_OS_PORT_SPACING_REG_6r, PGW_OS_PORT_SPACING_REG_7r
    };
    static const soc_reg_t pgw_obm_ctrl_regs[] = {
        PGW_OBM0_CONTROLr, PGW_OBM1_CONTROLr,
        PGW_OBM2_CONTROLr, PGW_OBM3_CONTROLr
    };
    static const soc_reg_t pgw_obm_priority_map_regs[] = {
        PGW_OBM0_PRIORITY_MAPr, PGW_OBM1_PRIORITY_MAPr,
        PGW_OBM2_PRIORITY_MAPr, PGW_OBM3_PRIORITY_MAPr
    };
    static const soc_reg_t pgw_obm_shared_config_regs[] = {
        PGW_OBM0_SHARED_CONFIGr, PGW_OBM1_SHARED_CONFIGr,
        PGW_OBM2_SHARED_CONFIGr, PGW_OBM3_SHARED_CONFIGr
    };
    static const soc_reg_t pgw_obm_threshold_regs[] = {
        PGW_OBM0_THRESHOLDr, PGW_OBM1_THRESHOLDr,
        PGW_OBM2_THRESHOLDr, PGW_OBM3_THRESHOLDr
    };
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    static const soc_reg_t pgw_obm_threshold2_regs[] = {
        PGW_OBM0_THRESHOLD2r, PGW_OBM1_THRESHOLD2r,
        PGW_OBM2_THRESHOLD2r, PGW_OBM3_THRESHOLD2r
    };
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    static const soc_reg_t pgw_obm_fc_config_regs[] = {
        PGW_OBM_PORT0_FC_CONFIGr, PGW_OBM_PORT1_FC_CONFIGr,
        PGW_OBM_PORT2_FC_CONFIGr, PGW_OBM_PORT3_FC_CONFIGr,
        PGW_OBM_PORT4_FC_CONFIGr, PGW_OBM_PORT5_FC_CONFIGr,
        PGW_OBM_PORT6_FC_CONFIGr, PGW_OBM_PORT7_FC_CONFIGr,
        PGW_OBM_PORT8_FC_CONFIGr, PGW_OBM_PORT9_FC_CONFIGr,
        PGW_OBM_PORT10_FC_CONFIGr, PGW_OBM_PORT11_FC_CONFIGr,
        PGW_OBM_PORT12_FC_CONFIGr, PGW_OBM_PORT13_FC_CONFIGr,
        PGW_OBM_PORT14_FC_CONFIGr, PGW_OBM_PORT15_FC_CONFIGr
    };
    static const soc_field_t pgw_spacing_fields[] = {
        SLOT0f, SLOT1f, SLOT2f, SLOT3f, SLOT4f, SLOT5f, SLOT6f, SLOT7f,
        SLOT8f, SLOT9f, SLOT10f, SLOT11f, SLOT12f, SLOT13f, SLOT14f, SLOT15f,
        SLOT16f, SLOT17f, SLOT18f, SLOT19f, SLOT20f, SLOT21f, SLOT22f, SLOT23f,
        SLOT24f, SLOT25f, SLOT26f, SLOT27f, SLOT28f, SLOT29f, SLOT30f, SLOT31f
    };
    static const soc_field_t pgw_obm_bypass_fields[] = {
        PORT0_BYPASS_ENABLEf, PORT1_BYPASS_ENABLEf,
        PORT2_BYPASS_ENABLEf, PORT3_BYPASS_ENABLEf
    };
    static const soc_field_t pgw_obm_oversub_fields[] = {
        PORT0_OVERSUB_ENABLEf, PORT1_OVERSUB_ENABLEf,
        PORT2_OVERSUB_ENABLEf, PORT3_OVERSUB_ENABLEf
    };
    static const soc_mem_t mmu_tdm_regs[2] ={
        ES_PIPE0_TDM_CONFIGr, ES_PIPE1_TDM_CONFIGr
    };
    static const soc_mem_t mmu_tdm_mems[2] ={
        ES_PIPE0_TDM_TABLE_0m, ES_PIPE1_TDM_TABLE_0m
    };
    static const soc_reg_t mmu_ovs_group_cfg_regs[] = {
        ES_PIPE0_OVR_SUB_GRP_CFGr, ES_PIPE1_OVR_SUB_GRP_CFGr
    };
    /* Trident2+ has different registers so pointer will be changed later */
    mmu_ovs_group_wt_regs_t mmu_ovs_group_wt_regs = mmu_ovs_group_wt_regs_local;


    static const soc_field_t xlp_cell_asf_thresh_fields[] = {
        XLP0_CELL_ASM_CUT_THRU_THRESHOLDf, XLP1_CELL_ASM_CUT_THRU_THRESHOLDf,
        XLP2_CELL_ASM_CUT_THRU_THRESHOLDf, XLP3_CELL_ASM_CUT_THRU_THRESHOLDf
    };
    static const soc_mem_t iarb_tdm_mems[2] ={
        IARB_MAIN_TDM_Xm, IARB_MAIN_TDM_Ym
    };

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    mmu_ovs_group_wt_regs = 
        get_mmu_ovs_group_wt_regs ( unit, mmu_ovs_group_wt_regs );
#endif

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    sal_memset(&_soc_td2_tdm, 0, sizeof(_soc_td2_tdm));

    si = &SOC_INFO(unit);

    PBMP_PORT_ITER(unit, port) {
        if (SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
            continue;
        }
        phy_port = si->port_l2p_mapping[port];
        _soc_td2_tdm.speed[phy_port] = si->port_speed_max[port];
        _soc_td2_tdm.port_state[phy_port] =
            SOC_PBMP_MEMBER(si->oversub_pbm, port) ?
            PORT_STATE_OVERSUB : PORT_STATE_LINERATE;

        if (SOC_IS_TRIDENT2PLUS(unit) && 
            (_soc_td2_tdm.speed[phy_port] >= 100000)) {
           _soc_td2_tdm.port_state[phy_port + 1] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 2] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 3] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 4] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 5] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 6] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 7] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 8] = PORT_STATE_SUBPORT;
           _soc_td2_tdm.port_state[phy_port + 9] = PORT_STATE_SUBPORT;
        } else if (_soc_td2_tdm.speed[phy_port] >= 40000) {
            _soc_td2_tdm.port_state[phy_port + 1] = PORT_STATE_SUBPORT;
            _soc_td2_tdm.port_state[phy_port + 2] = PORT_STATE_SUBPORT;
            _soc_td2_tdm.port_state[phy_port + 3] = PORT_STATE_SUBPORT;
        } else if (_soc_td2_tdm.speed[phy_port] >= 20000) {
            _soc_td2_tdm.port_state[phy_port + 1] = PORT_STATE_SUBPORT;
        }
    }

    _soc_td2_tdm.speed[0] = 1000;
    _soc_td2_tdm.speed[129] = 1000;
    _soc_td2_tdm.tdm_bw = si->bandwidth / 1000;

    SOC_PBMP_ASSIGN(pbmp, si->oversub_pbm);
    SOC_PBMP_AND(pbmp, si->xpipe_pbm);
    if (_soc_td2_tdm.tdm_bw == 720) { /* 720g special handling */
        /* tell tdm code the pipe is oversub only if all ports are oversub */
        SOC_PBMP_PORT_ADD(pbmp, 0); /* cpu port */
        _soc_td2_tdm.pipe_ovs_state[0] = SOC_PBMP_EQ(pbmp, si->xpipe_pbm);
    } else {
        /* tell tdm code the pipe is oversub if any ports is oversub */
        _soc_td2_tdm.pipe_ovs_state[0] = SOC_PBMP_NOT_NULL(pbmp);
    }
    SOC_PBMP_ASSIGN(pbmp, si->oversub_pbm);
    SOC_PBMP_AND(pbmp, si->ypipe_pbm);
    if (_soc_td2_tdm.tdm_bw == 720) { /* 720g special handling */
        /* tell tdm code the pipe is oversub only if all ports are oversub */
        SOC_PBMP_PORT_ADD(pbmp, 105); /* loopback port */
        _soc_td2_tdm.pipe_ovs_state[1] = SOC_PBMP_EQ(pbmp, si->ypipe_pbm);
    } else {
        /* tell tdm code the pipe is oversub if any ports is oversub */
        _soc_td2_tdm.pipe_ovs_state[1] = SOC_PBMP_NOT_NULL(pbmp);
    }
    _soc_td2_tdm.manage_port_type = 0;
    if (SOC_PBMP_NOT_NULL(si->management_pbm)) {
        speed_max = 0;
        for (phy_port = 13; phy_port <= 16; phy_port++) {
            port = si->port_p2l_mapping[phy_port];
            if (port == -1) {
                continue;
            }
            if (speed_max < si->port_speed_max[port]) {
                speed_max = si->port_speed_max[port];
            }
        }
        if (speed_max <= 1000) {
            _soc_td2_tdm.manage_port_type = 1; /* 4 x 1g */
        } else if (speed_max <= 2500) {
            _soc_td2_tdm.manage_port_type = 2; /* 4 * 2.5g */
        } else {
            _soc_td2_tdm.manage_port_type = 3; /* 1 x 10g */
        }
        if (_soc_td2_tdm.manage_port_type > 0) {
            _soc_td2_tdm.pgw_tdm[0][0] = 1234; /* magic number used by
                                                * tdm code */
        }
    }

    for (slot = 0; slot <= _MMU_TDM_LENGTH; slot++) {
        _soc_td2_tdm.mmu_tdm[0][slot] = NUM_EXT_PORTS;
        _soc_td2_tdm.mmu_tdm[1][slot] = NUM_EXT_PORTS;
    }

    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        LOG_CLI((BSL_META_U(unit,
                            "tdm_bw: %dG\n"), _soc_td2_tdm.tdm_bw));
        LOG_CLI((BSL_META_U(unit,
                            "port speed:")));
        for (index = 0; index < NUM_EXT_PORTS; index++) {
            if (index % 8 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            LOG_CLI((BSL_META_U(unit,
                                " %6d"), _soc_td2_tdm.speed[index]));
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
        LOG_CLI((BSL_META_U(unit,
                            "port state map:")));
        for (index = 0; index < NUM_EXT_PORTS; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            if (index == 0 || index == (NUM_EXT_PORTS - 1)) {
                LOG_CLI((BSL_META_U(unit,
                                    " ---")));
            } else {
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         _soc_td2_tdm.port_state[index]));
            }
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
#ifdef BCM_56860_A0
        _chip_pkg.unit = unit;
        _chip_pkg.num_ext_ports = TD2P_NUM_EXT_PORTS;
        _chip_pkg.state=sal_alloc((_chip_pkg.num_ext_ports)*sizeof(int *), "port state list");
        _chip_pkg.speed=sal_alloc((_chip_pkg.num_ext_ports)*sizeof(int *), "port speed list");
        for (index=1; index<(_chip_pkg.num_ext_ports); index++) {
            _chip_pkg.state[index] = _soc_td2_tdm.port_state[index];
        }
        _chip_pkg.state[0]=1; /* enable cpu port */
        _chip_pkg.state[_chip_pkg.num_ext_ports-1]=1; /* enable loopback port */
        for (index=0; index<(_chip_pkg.num_ext_ports); index++) {
            _chip_pkg.speed[index] = _soc_td2_tdm.speed[index];
        }

        /*
         * Map detected core clk frequency to TDM algorithm internal code
         * value.
         */
        switch (si->frequency) {
            case 790:
            case 760:
                _chip_pkg.clk_freq = 760;
                break;
            case 635:
                _chip_pkg.clk_freq = 608;
                break;
            case 537:
                _chip_pkg.clk_freq = 518;
                break;
            case 421:
                _chip_pkg.clk_freq = 415;
                break;
            default:
                _chip_pkg.clk_freq = (si->frequency > 760) ? (760)
                                        : si->frequency;
        }

        _tdm_pkg = _soc_set_tdm_tbl(SOC_SEL_TDM(&_chip_pkg));
        if (!_tdm_pkg) {
            LOG_CLI((BSL_META_U(unit,
                "Unable to configure TDM, please contact your "
                "Field Applications Engineer or Sales Manager for "
                "additional assistance.\n")));
            return SOC_E_FAIL;
        }
        sal_memcpy(_soc_td2_tdm.pgw_tdm[0], _tdm_pkg->_chip_data.cal_0.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_tdm[0], _tdm_pkg->_chip_data.cal_0.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_spacing[0], _tdm_pkg->_chip_data.cal_0.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.pgw_tdm[1], _tdm_pkg->_chip_data.cal_1.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_tdm[1], _tdm_pkg->_chip_data.cal_1.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_spacing[1], _tdm_pkg->_chip_data.cal_1.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.pgw_tdm[2], _tdm_pkg->_chip_data.cal_2.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_tdm[2], _tdm_pkg->_chip_data.cal_2.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_spacing[2], _tdm_pkg->_chip_data.cal_2.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.pgw_tdm[3], _tdm_pkg->_chip_data.cal_3.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_tdm[3], _tdm_pkg->_chip_data.cal_3.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.pgw_ovs_spacing[3], _tdm_pkg->_chip_data.cal_3.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(_soc_td2_tdm.mmu_tdm[0], _tdm_pkg->_chip_data.cal_4.cal_main, sizeof(int)*_MMU_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][0], _tdm_pkg->_chip_data.cal_4.cal_grp[0], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][1], _tdm_pkg->_chip_data.cal_4.cal_grp[1], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][2], _tdm_pkg->_chip_data.cal_4.cal_grp[2], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][3], _tdm_pkg->_chip_data.cal_4.cal_grp[3], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][4], _tdm_pkg->_chip_data.cal_4.cal_grp[4], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][5], _tdm_pkg->_chip_data.cal_4.cal_grp[5], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][6], _tdm_pkg->_chip_data.cal_4.cal_grp[6], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[0][7], _tdm_pkg->_chip_data.cal_4.cal_grp[7], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_tdm[1], _tdm_pkg->_chip_data.cal_5.cal_main, sizeof(int)*_MMU_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][0], _tdm_pkg->_chip_data.cal_5.cal_grp[0], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][1], _tdm_pkg->_chip_data.cal_5.cal_grp[1], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][2], _tdm_pkg->_chip_data.cal_5.cal_grp[2], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][3], _tdm_pkg->_chip_data.cal_5.cal_grp[3], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][4], _tdm_pkg->_chip_data.cal_5.cal_grp[4], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][5], _tdm_pkg->_chip_data.cal_5.cal_grp[5], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][6], _tdm_pkg->_chip_data.cal_5.cal_grp[6], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(_soc_td2_tdm.mmu_ovs_group_tdm[1][7], _tdm_pkg->_chip_data.cal_5.cal_grp[7], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_free(_chip_pkg.state);
        sal_free(_chip_pkg.speed);
        _tdm_pkg->_chip_exec[TDM_CHIP_EXEC__FREE](_tdm_pkg);
#endif
    } else {
#ifdef BCM_56850_A0
        for (index=0; index<130; index++) {
            td2_spd[index] = _soc_td2_tdm.speed[index];
        }
        rv = _soc_td2_set_tdm_tbl(td2_spd, _soc_td2_tdm.tdm_bw,
                         _soc_td2_tdm.pgw_tdm[0],
                         _soc_td2_tdm.pgw_ovs_tdm[0],
                         _soc_td2_tdm.pgw_ovs_spacing[0],
                         _soc_td2_tdm.pgw_tdm[1],
                         _soc_td2_tdm.pgw_ovs_tdm[1],
                         _soc_td2_tdm.pgw_ovs_spacing[1],
                         _soc_td2_tdm.pgw_tdm[2],
                         _soc_td2_tdm.pgw_ovs_tdm[2],
                         _soc_td2_tdm.pgw_ovs_spacing[2],
                         _soc_td2_tdm.pgw_tdm[3],
                         _soc_td2_tdm.pgw_ovs_tdm[3],
                         _soc_td2_tdm.pgw_ovs_spacing[3],
                         _soc_td2_tdm.mmu_tdm[0],
                         _soc_td2_tdm.mmu_ovs_group_tdm[0][0],
                         _soc_td2_tdm.mmu_ovs_group_tdm[0][1],
                         _soc_td2_tdm.mmu_ovs_group_tdm[0][2],
                         _soc_td2_tdm.mmu_ovs_group_tdm[0][3],
                         _soc_td2_tdm.mmu_tdm[1],
                         _soc_td2_tdm.mmu_ovs_group_tdm[1][0],
                         _soc_td2_tdm.mmu_ovs_group_tdm[1][1],
                         _soc_td2_tdm.mmu_ovs_group_tdm[1][2],
                         _soc_td2_tdm.mmu_ovs_group_tdm[1][3],
                         &_soc_td2_tdm.port_state[1], /* skip cpu port */
                         _soc_td2_tdm.iarb_tdm[0],
                         _soc_td2_tdm.iarb_tdm[1]);
		if (rv == 0) {
			LOG_CLI((BSL_META_U(unit,
								"Unable to configure TDM, please contact your "
								"Field Applications Engineer or Sales Manager for "
								"additional assistance.\n")));
			return SOC_E_FAIL;
		}
#endif
	}

    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw += _TD2_PGWS_PER_QUAD) {
            LOG_CLI((BSL_META_U(unit,
                                "PGW_CL%d pgw_tdm:"), pgw));
            for (index = 0; index < GET_PGW_TDM_LENGTH(unit); index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         _soc_td2_tdm.pgw_tdm[pgw / 2][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            LOG_CLI((BSL_META_U(unit,
                                "PGW_CL%d pgw_ovs_tdm:"), pgw));
            for (index = 0; index < _PGW_TDM_OVS_SIZE; index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                                    _soc_td2_tdm.pgw_ovs_tdm[pgw / 2][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            LOG_CLI((BSL_META_U(unit,
                                "PGW_CL%d pgw_ovs_spacing:"), pgw));
            for (index = 0; index < _PGW_TDM_OVS_SIZE; index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         _soc_td2_tdm.pgw_ovs_spacing[pgw / 2][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
        }
        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
            LOG_CLI((BSL_META_U(unit,
                                "Pipe %c mmu_tdm:"), pipe ? 'y' : 'x'));
            for (index = 0; index < _MMU_TDM_LENGTH; index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         _soc_td2_tdm.mmu_tdm[pipe][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            for (group = 0; group < GET_MMU_OVS_GCOUNT(unit); group++) {
                LOG_CLI((BSL_META_U(unit,
                                    "Pipe %c group %d ovs_group_tdm"),
                         pipe ? 'y' : 'x', group));
                for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH;
                     index++) {
                    if (index % 16 == 0) {
                        LOG_CLI((BSL_META_U(unit,
                                            "\n    ")));
                    }
                    LOG_CLI((BSL_META_U(unit,
                                        " %3d"),
                             _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][index]));
                }
                LOG_CLI((BSL_META_U(unit,
                                    "\n")));
            }
        }
    }

    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        LOG_CLI((BSL_META_U(unit,
                            "tdm_bw: %dG\n"), _soc_td2_tdm.tdm_bw));
        LOG_CLI((BSL_META_U(unit,
                            "x pipe ovs state: %d\n"),
                 _soc_td2_tdm.pipe_ovs_state[0]));
        LOG_CLI((BSL_META_U(unit,
                            "y pipe ovs state: %d\n"),
                 _soc_td2_tdm.pipe_ovs_state[1]));
        LOG_CLI((BSL_META_U(unit,
                            "manage port type: %d\n"),
                 _soc_td2_tdm.manage_port_type));
    }
	
    if (SOC_IS_TRIDENT2PLUS(unit)) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        rv = tdm_td2p_set_iarb_tdm_table(_soc_td2_tdm.tdm_bw,
                                _soc_td2_tdm.pipe_ovs_state[0],
                                _soc_td2_tdm.pipe_ovs_state[1],
                                _soc_td2_tdm.manage_port_type == 1,
                                _soc_td2_tdm.manage_port_type == 2,
                                _soc_td2_tdm.manage_port_type == 3,
                                &_soc_td2_tdm.iarb_tdm_wrap_ptr[0],
                                &_soc_td2_tdm.iarb_tdm_wrap_ptr[1],
                                _soc_td2_tdm.iarb_tdm[0],
                                _soc_td2_tdm.iarb_tdm[1]);
#endif
    } else {
        rv = tdm_td2_set_iarb_tdm_table(_soc_td2_tdm.tdm_bw,
                                _soc_td2_tdm.pipe_ovs_state[0],
                                _soc_td2_tdm.pipe_ovs_state[1],
                                _soc_td2_tdm.manage_port_type == 1,
                                _soc_td2_tdm.manage_port_type == 2,
                                _soc_td2_tdm.manage_port_type == 3,
                                &_soc_td2_tdm.iarb_tdm_wrap_ptr[0],
                                &_soc_td2_tdm.iarb_tdm_wrap_ptr[1],
                                _soc_td2_tdm.iarb_tdm[0],
                                _soc_td2_tdm.iarb_tdm[1]);
    }
    if (rv == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "Unable to configure IARB TDM, please contact your "
                            "Field Applications Engineer or Sales Manager for "
                            "additional assistance.\n")));
        return SOC_E_FAIL;
    }
	
    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
            LOG_CLI((BSL_META_U(unit,
                                "Pipe %c iarb_tdm: (wrap_ptr %d)"),
                     pipe ? 'y' : 'x',
                     _soc_td2_tdm.iarb_tdm_wrap_ptr[pipe]));
            for (index = 0; index < _IARB_TDM_LENGTH; index++) {
                if (index > _soc_td2_tdm.iarb_tdm_wrap_ptr[pipe]) {
                    break;
                }
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         _soc_td2_tdm.iarb_tdm[pipe][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
        }
    }

    /* Configure PGW TDM for TD2,  only need to program master PGWs (PGW_CL0/2/4/6) */
    /* Configure PGW TDM for TD2+, only need to program master PGWs (PGW_CL0/3/4/7) */
    for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw += _TD2_PGWS_PER_QUAD) {
        pgw_master = pgw;
        pgw_slave  = pgw + 1;

        if (SOC_IS_TRIDENT2PLUS(unit)) {
            if (( pgw == 2 ) || ( pgw == 6 )) {
                pgw_master = pgw + 1;
                pgw_slave  = pgw;
            }
        }

        /* coverity[negative_returns : FALSE] */
        if (!si->block_valid[PGW_CL_BLOCK(unit, pgw_master)] &&
            !si->block_valid[PGW_CL_BLOCK(unit, pgw_slave)]) {
            /* Both master and slave are not in use */
            continue;
        }

        obm_inst = pgw_master | SOC_REG_ADDR_INSTANCE_MASK;

        SOC_IF_ERROR_RETURN(soc_reg_get(unit, PGW_TDM_CONTROLr, obm_inst, 0,
                                        &ctrl_rval64));

        /* Configure PGW line rate ports TDM */
        count = 0;
        for (base = 0; base < GET_PGW_TDM_LENGTH(unit);
            base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_tdm_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = _soc_td2_tdm.pgw_tdm[pgw_master / 2][slot];
                if (phy_port == NUM_EXT_PORTS) {
                    break;
                }
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      phy_port);
                count++;
            }
            if (index != 0) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, obm_inst, 0, rval64));
            }
            if (index != _PGW_TDM_SLOTS_PER_REG) {
                break;
            }
        }
        if (count > 0) {
            soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                                  LR_TDM_WRAP_PTRf, count - 1);
        }
        soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                              LR_TDM_ENABLEf, count ? 1 : 0);

        /* Configure PGW oversubscription ports TDM */
        count = 0;
        for (base = 0; base < _PGW_TDM_OVS_SIZE;
             base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_ovs_tdm_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = _soc_td2_tdm.pgw_ovs_tdm[pgw_master / 2][slot];
                if (phy_port == NUM_EXT_PORTS) {
                    phy_port = 0xff;
                } else {
                    count++;
                }
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      phy_port);
            }
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, obm_inst, 0, rval64));
        }
        /* OS_TDM_WRAP_PTR is always 31 (reset value) */
        soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                              OS_TDM_ENABLEf, count ? 1 : 0);

        /* Configure PGW oversubscription port spacing */
        for (base = 0; base < _PGW_TDM_OVS_SIZE;
             base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_ovs_spacing_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = _soc_td2_tdm.pgw_ovs_spacing[pgw_master / 2][slot];
                soc_reg64_field32_set(unit, reg, &rval64,
                                      pgw_spacing_fields[slot], phy_port);
            }
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, obm_inst, 0, rval64));
        }

        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, PGW_TDM_CONTROLr, obm_inst, 0, ctrl_rval64));
    }

    /* Configure PGW TDM oversubscription buffer manager (OBM) */
    xlport_map = 0;
    SOC_BLOCK_ITER(unit, block, SOC_BLK_XLPORT) {
        xlport_map |= 1 << SOC_BLOCK_NUMBER(unit, block);
    }
    quad_oversub_bandwidth = 0; /* to eliminate false compiler warning */
    quad_oversub_core_bandwidth = 0; /* to eliminate false compiler warning */

    for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw++) {
        if (!(pgw & 1)) {
            /* coverity[negative_returns : FALSE] */
            if (!si->block_valid[PGW_CL_BLOCK(unit, pgw)] &&
                !si->block_valid[PGW_CL_BLOCK(unit, pgw + 1)]) {
                /* Both master and slave are not in use */
                pgw++;
                continue;
            }
            /* Calculate per quadrant line rate and oversub bandwidth */
            _soc_trident2_quad_bandwidth_calculate
                (unit, pgw / _TD2_PGWS_PER_QUAD, &max_quad_core_bandwidth,
                 &quad_linerate_bandwidth, &quad_oversub_bandwidth);
            quad_oversub_core_bandwidth =
                max_quad_core_bandwidth - quad_linerate_bandwidth;
        }

        block = PGW_CL_BLOCK(unit, pgw);
        if (SOC_BLOCK_PORT(unit, block) < 0) { /* PGW is not in use */
            continue;
        }

        obm_inst = pgw | SOC_REG_ADDR_INSTANCE_MASK;

        COMPILER_64_ZERO(rval64);
        for (xlp = 0; xlp < _TD2_XLPS_PER_PGW; xlp++){
            if (!(xlport_map & (1 << (pgw * _TD2_XLPS_PER_PGW + xlp)))) {
                continue;
            }
            index = pgw & 1 ? _TD2_XLPS_PER_PGW - 1 - xlp : xlp;
            soc_reg64_field32_set(unit, CELL_ASM_CUT_THRU_THRESHOLDr, &rval64,
                                  xlp_cell_asf_thresh_fields[index], 6);
        }
        SOC_IF_ERROR_RETURN(soc_reg_set(unit, CELL_ASM_CUT_THRU_THRESHOLDr,
                                        obm_inst, 0, rval64));

        for (xlp = 0; xlp < _TD2_XLPS_PER_PGW; xlp++) {
            if (!(xlport_map & (1 << (pgw * _TD2_XLPS_PER_PGW + xlp)))) {
                continue;
            }
            /* XLP number is reversed (mirrored) in odd number PGW block */
            tsc = pgw * _TD2_XLPS_PER_PGW +
                ((pgw & 1) ? (_TD2_XLPS_PER_PGW - 1 - xlp) : xlp);

            /* Count number of oversub ports in the OBM (XLPORT) */
            count = 0;
            for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                if (_soc_td2_tdm.port_state[phy_port] == PORT_STATE_OVERSUB) {
                    count++;
                }
            }
            if (count == 0) { /* the XLPORT is not in oversub mode */
                continue;
            }

            reg = pgw_obm_ctrl_regs[xlp];
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, reg, obm_inst, 0, &ctrl_rval64));
            for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                if (si->port_p2l_mapping[phy_port] == -1) {
                    continue;
                }
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      pgw_obm_oversub_fields[index], 1);
                if ((! SOC_IS_TRIDENT2PLUS(unit)) && (count > 1)) {
                    /* Do not allow OBM bypass if the oversubscribed
                     * XLPORT block has more than 1 port configured */
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          pgw_obm_bypass_fields[index], 0);
                }
            }
            if (SOC_IS_TRIDENT2PLUS(unit) || (rev_id > BCM56850_A1_REV_ID)) {
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      OVERSUB_HEADROOM_ENABLEf, 0);
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));

            if (!SOC_IS_TRIDENT2PLUS(unit) && (rev_id <= BCM56850_A1_REV_ID)) {
                /* Do not map to low priority on A0/A1 */
                reg = pgw_obm_priority_map_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          PCP_MAPf, 0xffff);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }

                reg = pgw_obm_shared_config_regs[xlp];
                SOC_IF_ERROR_RETURN
                    (soc_reg_get(unit, reg, obm_inst, 0, &ctrl_rval64));
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      SHARED_POOL_SIZEf, 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));

                reg = pgw_obm_threshold_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    port = si->port_p2l_mapping[phy_port];
                    if (port == -1) {
                        continue;
                    }

                    if (si->port_speed_max[port] > 20000) {
                        obm_setting_idx = 2; /* entry 2 in the lookup table */
                        xon_threshold_offset = 24; /* xon = xoff - 24 */
                    } else if (si->port_speed_max[port] > 10000) {
                        obm_setting_idx = 1; /* entry 1 in the lookup table */
                        xon_threshold_offset = 12; /* xon = xoff - 12 */
                    } else {
                        obm_setting_idx = 0; /* entry 0 in the lookup table */
                        xon_threshold_offset = 6; /* xon = xoff - 6 */
                    }
                    if (quad_oversub_bandwidth * 2 >
                        quad_oversub_core_bandwidth * 3) {
                        /* oversub ratio greater than 1.5 (3/2) */
                        oversub_ratio_idx = 1;
                    } else if (quad_oversub_bandwidth * 3 >
                        quad_oversub_core_bandwidth * 4) {
                        /* oversub ratio greater than 1.33 (4/3) */
                        oversub_ratio_idx = 1;
                    } else {
                        oversub_ratio_idx = 0;
                    }

                    if (lossless) {
                        xoff_threshold = obm_settings_a1[obm_setting_idx].
                            xoff_threshold[oversub_ratio_idx];
                        xon_threshold = xoff_threshold - xon_threshold_offset;
                        mtu_cells = obm_settings_a1[obm_setting_idx].
                            mtu_cells[oversub_ratio_idx];
                    } else {
                        xoff_threshold = 1020;
                        xon_threshold = 1020;
                        mtu_cells = 9 * 1024 / _TD2_BYTES_PER_OBM_CELL;
                    }
                    if (count > 1 &&
                        quad_oversub_bandwidth > quad_oversub_core_bandwidth) {
                        /*
                         * packet_completion_reserved cells =
                         *  (num_ports - 1) * mtu * (1 - 1 / oversub_ratio) + 4
                         */
                        res_cells = (count - 1) * mtu_cells *
                            (quad_oversub_bandwidth -
                             quad_oversub_core_bandwidth) /
                            quad_oversub_bandwidth  + 4;
                    } else {
                        res_cells = 4;
                    }
                    /*
                     * port_cells =
                     *  (1020 - packet_completion_reserved_cells) / num_ports
                     */
                    port_cells = (_TD2_TD2_CELLS_PER_OBM - res_cells) / count;

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          MIN_THRESHOLDf, port_cells);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          LOW_PRI_THRESHOLDf, 0);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          MAX_THRESHOLDf, port_cells);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XONf, xon_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XOFFf, xoff_threshold);
                    if (!SOC_IS_TRIDENT2PLUS(unit)) {
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          CUT_THROUGH_OKf, 2);
                    }
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }
            } else {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                if (SOC_IS_TRIDENT2PLUS(unit)) {
                    /* Cut through is allowed if usage is less than or equal to
                     * CUT_THROUGH_OKf threshold.  Granularity is 16B cell.
                     */
                    reg = pgw_obm_threshold2_regs[xlp];
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                        port = si->port_p2l_mapping[phy_port];
                        if (port == -1) {
                            continue;
                        }
                        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg,
                                                        obm_inst, index,
                                                        &ctrl_rval64));
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              CUT_THROUGH_OKf, 2);
                        SOC_IF_ERROR_RETURN
                            (soc_reg_set(unit, reg, obm_inst, index,
                                                        ctrl_rval64));
                    }
                }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
                /* Maintaining of Priority to Priority_group mapping requires
                 * sufficient Memory for OAM, Hence calling the
                 * soc_property_port_get_csv function where necessary.
                 */
                reg = pgw_obm_priority_map_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    pri_mask = 0xffff;
                    if (lossless && 
                        soc_feature(unit, soc_feature_prigrp_to_obm_prio_map)) {
                        SOC_IF_ERROR_RETURN
                            (_soc_trident2_get_prio_map(
                                              unit, 
                                              si->port_p2l_mapping[phy_port],
                                              &pri_mask));
                    }
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      PCP_MAPf, lossless ? pri_mask : 0);
                   
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }

                reg = pgw_obm_shared_config_regs[xlp];
                SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                &ctrl_rval64));
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      SHARED_POOL_SIZEf, GET_NUM_CELLS_PER_OBM(unit));
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));

                reg = pgw_obm_threshold_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    port = si->port_p2l_mapping[phy_port];
                    if (port == -1) {
                        continue;
                    }

                    if (SOC_IS_TRIDENT2PLUS(unit)) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                        soc_td2p_set_obm_registers (unit, reg, si->port_speed_max[port], index, 
                                obm_inst, lossless);

                        SOC_IF_ERROR_RETURN
                            (soc_td2p_obm_prob_drop_default_set (unit, xlp, 
                                                         index, obm_inst));
#endif
                    } else {
                        if (si->port_speed_max[port] > 20000) {
                            obm_setting_idx = 2; /* entry 2 in the lookup table */
                            xon_threshold_offset = 24; /* xon = xoff - 24 */
                        } else if (si->port_speed_max[port] > 10000) {
                            obm_setting_idx = 1; /* entry 1 in the lookup table */
                            xon_threshold_offset = 12; /* xon = xoff - 12 */
                        } else {
                            obm_setting_idx = 0; /* entry 0 in the lookup table */
                            xon_threshold_offset = 6; /* xon = xoff - 6 */
                        }
                        if (lossless) {
                            if (quad_oversub_bandwidth * 2 >
                                quad_oversub_core_bandwidth * 3) {
                                /* oversub ratio greater than 1.5 (3/2) */
                                oversub_ratio_idx = 2;
                            } else if (quad_oversub_bandwidth * 3 >
                                quad_oversub_core_bandwidth * 4) {
                                /* oversub ratio greater than 1.33 (4/3) */
                                oversub_ratio_idx = 1;
                            } else {
                                oversub_ratio_idx = 0;
                            }

                            xoff_threshold = obm_settings[obm_setting_idx].
                                xoff_threshold[oversub_ratio_idx];
                            xon_threshold = xoff_threshold - xon_threshold_offset;
                            min_threshold = xon_threshold + 3;
                        } else {
                            xoff_threshold = 1023;
                            xon_threshold = 1023;
                            min_threshold = obm_settings[obm_setting_idx].
                                max_threshold;
                        }

                        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                        &ctrl_rval64));
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              MIN_THRESHOLDf, min_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              LOW_PRI_THRESHOLDf, 0);
                        soc_reg64_field32_set
                            (unit, reg, &ctrl_rval64, MAX_THRESHOLDf,
                             obm_settings[obm_setting_idx].max_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              FLOW_CTRL_XONf, xon_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              FLOW_CTRL_XOFFf, xoff_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              CUT_THROUGH_OKf, 2);
                        SOC_IF_ERROR_RETURN
                            (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                    }
                }

                if (!lossless) {
                    continue;
                }
                /* The configuration of OBM is configured in sync with the MMU.
                 * if spn_MMU_LOSSLESS is NOT configured, then all the priority
                 * groups are Lossy (Flow Control is disabled).
                 * if spn_MMU_LOSSLESS is SET (1), then the priorities which are
                 * mapped to Priority Group - 7 will have flow control enabled.
                 */

                COMPILER_64_ZERO(ctrl_rval64);
                reg = pgw_obm_fc_config_regs[0];
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      PORT_FC_ENABLEf, 1);
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }
                    pri_mask = 0xffff;
                    if (soc_feature(unit, soc_feature_prigrp_to_obm_prio_map)) {
                        SOC_IF_ERROR_RETURN
                            (_soc_trident2_get_prio_map(
                                              unit,
                                              si->port_p2l_mapping[phy_port],
                                              &pri_mask));
                    }
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      PRIORITY_PROFILE_FCf, pri_mask);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                    /* This field controls the frequence of XOFF status sent to
                     * the xlmac is refreshed. units=250ns.
                     */
                    if (SOC_IS_TRIDENT2PLUS(unit)) {
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          XOFF_REFRESH_TIMERf, 0x100);
                    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

                    reg = pgw_obm_fc_config_regs[xlp * _TD2_PORTS_PER_XLP +
                                                 index];
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));
                }
            }
        }
    }

    /* Configure MMU TDM */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        reg = mmu_tdm_regs[pipe];
        mem = mmu_tdm_mems[pipe];
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        wt_group_select = 0;
#endif

        length = _MMU_TDM_LENGTH;
        for (slot = _MMU_TDM_LENGTH - 1; slot >= 0; slot--) {
            if (_soc_td2_tdm.mmu_tdm[pipe][slot] != NUM_EXT_PORTS) {
                length = slot + 1;
                break;
            }
        }
        
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        sal_memset(entry, 0, soc_mem_entry_words(unit, mem) * sizeof(uint32));
        for (slot = 0; slot < length; slot += 2) {
            phy_port = _soc_td2_tdm.mmu_tdm[pipe][slot];
            if (phy_port == GET_OVS_TOKEN(unit)) {
                mmu_port = 57; /* oppurtunist port */
            } else if (phy_port == GET_IDL_TOKEN(unit)) {
                mmu_port = 58; /* scheduler will not pick anything */
            } else if (phy_port >= NUM_EXT_PORTS) {
                mmu_port = 0x3f;
            } else {
                mmu_port = si->port_p2m_mapping[phy_port];
            }
            soc_mem_field32_set(unit, mem, entry, PORT_NUM_EVENf,
                                mmu_port & 0x3f);

            phy_port = _soc_td2_tdm.mmu_tdm[pipe][slot + 1];
            if (phy_port == GET_OVS_TOKEN(unit)) {
                mmu_port = 57; /* oppurtunist port */
            } else if (phy_port == GET_IDL_TOKEN(unit)) {
                mmu_port = 58; /* scheduler will not pick anything */
            } else if (phy_port >= NUM_EXT_PORTS) {
                mmu_port = 0x3f;
            } else {
                mmu_port = si->port_p2m_mapping[phy_port];
            }
            soc_mem_field32_set(unit, mem, entry, PORT_NUM_ODDf,
                                mmu_port & 0x3f);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        }

        soc_reg_field_set(unit, reg, &rval, CAL0_ENDf, slot / 2);
        if (length & 1) {
            soc_reg_field_set(unit, reg, &rval, CAL0_END_SINGLEf, 1);
        }

        if (SOC_IS_TRIDENT2PLUS(unit)) {
            /* 
             *  Control strict priority scheduling between CPU/Loopback port
             *  and Oversub port. 
             *  Setting - Oversub has highest priority
             */
            soc_reg_field_set(unit, reg, &rval, OPP_STRICT_PRIf, 1);
            soc_reg_field_set(unit, reg, &rval, OPP_PORT_ENf, 1);
        }
        soc_reg_field_set(unit, reg, &rval, OPP_CPULB_ENf, 1);
        soc_reg_field_set(unit, reg, &rval, ENABLEf, 1);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));

        if (si->frequency < 760) {
            reg = mmu_ovs_group_cfg_regs[pipe];
            for (group = 0; group < GET_MMU_OVS_GCOUNT(unit); group++) {
                phy_port = _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][0];
                if (phy_port >= NUM_EXT_PORTS) {
                    continue;
                }
                port = si->port_p2l_mapping[phy_port];
                if (si->port_speed_max[port] < 30000) {
                    continue;
                }
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, REG_PORT_ANY, group, &rval));
                soc_reg_field_set(unit, reg, &rval, SAME_SPACINGf,
                                  si->frequency < 500 ? 6 : 8);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, group, rval));
            }
        }

        /* There are 8 oversub groups in TD2+ but we support 4 speeds only
         * there is ES_PIPE0_GRP_WT_SELECT register that will select
         * which queue belong to which group. By default 
         */

        for (group = 0; group < GET_MMU_OVS_GCOUNT(unit); group++) {
            reg = mmu_ovs_group_regs[pipe][group];
            rval = 0;
            for (slot = 0; slot < _MMU_OVS_GROUP_TDM_LENGTH; slot++) {
                phy_port = _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][slot];
                if (phy_port >= NUM_EXT_PORTS) {
                    mmu_port = 0x3f;
                    id = 0;
                } else {
                    mmu_port = si->port_p2m_mapping[phy_port];
                    id = si->port_serdes[si->port_p2l_mapping[phy_port]];
                }
                if (!SOC_IS_TRIDENT2PLUS(unit)) {
                    soc_reg_field_set(unit, reg, &rval, PHY_PORT_IDf, id & 0xf);
                }
                soc_reg_field_set(unit, reg, &rval, MMU_PORTf,
                                  mmu_port & 0x3f);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, slot, rval));
            }
            rval = 0;
            phy_port = _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][0];
            if (phy_port >= NUM_EXT_PORTS) {
                weight = 0;
                wt_group = td2p_ovs_wt_group_speed_NA; /* "not" valid group */
            } else {
                port = si->port_p2l_mapping[phy_port];
                speed_max = si->port_speed_max[port];
                if (SOC_IS_TRIDENT2PLUS(unit)) {
                    if ( speed_max <= 10000 ) {
                        wt_group = td2p_ovs_wt_group_speed_10G;
                    } else if ( speed_max <= 20000 ) {
                        wt_group = td2p_ovs_wt_group_speed_20G;
                    } else if ( speed_max <= 40000 ) {
                        wt_group = td2p_ovs_wt_group_speed_40G;
                    } else {
                        wt_group = td2p_ovs_wt_group_speed_NA; /* "not" valid group */
                    }
                }
                /* use 2500M as weight unit */
                weight = (speed_max > 2500 ? speed_max : 2500) / 2500;
            }

            /* TD2P supports 4 oversub speeds only 10/20 and 40*/
            if (SOC_IS_TRIDENT2PLUS(unit)) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                wt_group_select |= (wt_group << (group * 2));
#endif
            } else {
                wt_group = group;
            }

            reg = mmu_ovs_group_wt_regs[pipe][wt_group];

            for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH; index++) {
                soc_reg_field_set(unit, reg, &rval, WEIGHTf,
                                  weight * (index + 1));
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, index, rval));
            }
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, mmu_ovs_group_wt_select_regs [pipe], 
                               REG_PORT_ANY, 0, wt_group_select));
        }
#endif
    }

    /* Configure IARB TDM */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        mem = iarb_tdm_mems[pipe];
        sal_memset(entry, 0, soc_mem_entry_words(unit, mem) * sizeof(uint32));
        for (slot = 0; slot < _IARB_TDM_LENGTH; slot++) {
            if (slot > _soc_td2_tdm.iarb_tdm_wrap_ptr[pipe]) {
                break;
            }
            soc_mem_field32_set(unit, mem, entry, TDM_SLOTf,
                                _soc_td2_tdm.iarb_tdm[pipe][slot]);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot, entry));
        }
    }
    /* Both pipe are expected to have same IARB TDM table length */
    fields[0] = TDM_WRAP_PTRf;
    values[0] = _soc_td2_tdm.iarb_tdm_wrap_ptr[0];
    fields[1] = DISABLEf;
    values[1] = 0;
    fields[2] = AUX_CMICM_SLOT_ENf;
    values[2] = 1;
    fields[3] = AUX_EP_LB_SLOT_ENf;
    values[3] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, IARB_TDM_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    /* Configure oversubscription port with WAIT_FOR_2ND_MOP */
    sal_memset(entry, 0, sizeof(egr_edb_xmit_ctrl_entry_t));
    soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, WAIT_FOR_2ND_MOPf, 1);
    soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, START_CNTf,
            _TD2_MMU_XMIT_START_CNT_OVERSUB);
    SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
    SOC_PBMP_AND(pbmp, si->oversub_pbm);
    SOC_PBMP_ITER(pbmp, port) {
        phy_port = si->port_l2p_mapping[port];
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                          MEM_BLOCK_ALL, phy_port, &entry));
    }

    /* Configure linerate port with WAIT_FOR_MOP */
    sal_memset(entry, 0, sizeof(egr_edb_xmit_ctrl_entry_t));
    soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, WAIT_FOR_MOPf, 1);
    SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
    SOC_PBMP_XOR(pbmp, si->oversub_pbm);
    SOC_PBMP_ITER(pbmp, port) {
        phy_port = si->port_l2p_mapping[port];
        soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, START_CNTf,
                _TD2_MMU_XMIT_START_CNT_LINERATE(si->port_speed_max[port]));
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                          MEM_BLOCK_ALL, phy_port, &entry));
    }

    rval = 0;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        soc_reg_field_set(unit, ENQ_CONFIGr, &rval,
                      ASF_ENABLE_HS_PORT_EP_CREDIT_CHKf, 1);
    }
#endif
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_CFAP_FULL_DROP_ENf, 1);
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_FIFO_THRESHOLDf, _TD2_MMU_ASF_FIFO_THRESHOLD);
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_HS_FIFO_THRESHOLDf, _TD2_MMU_ASF_HS_FIFO_THRESHOLD);
    SOC_IF_ERROR_RETURN(WRITE_ENQ_CONFIGr(unit, rval));

    /*
     * bcmsim: C model cannot support cell based flow
     */
    if (SAL_BOOT_BCMSIM) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, IARB_TDM_CONTROLr, REG_PORT_ANY, 
                                    DISABLEf, 1));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_hash_init(int unit)
{
    soc_field_t fields[4];
    uint32 values[4];

    /* L2 dedicated banks */
    fields[0] = BANK0_HASH_OFFSETf;
    values[0] = 0;  /* CRC32_LOWER */
    fields[1] = BANK1_HASH_OFFSETf;
    values[1] = 16; /* CRC32_UPPER */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L2_TABLE_HASH_CONTROLr, REG_PORT_ANY, 2,
                                 fields, values));

    /* L3 dedicated banks */
    fields[0] = BANK6_HASH_OFFSETf;
    values[0] = 0;  /* CRC32_LOWER */
    fields[1] = BANK7_HASH_OFFSETf;
    values[1] = 12; /* CRC32 >> 12 */
    fields[2] = BANK8_HASH_OFFSETf;
    values[2] = 24; /* CRC16_LOWER << 8 | CRC32 >> 24 */
    fields[3] = BANK9_HASH_OFFSETf;
    values[3] = 36; /* CRC16 >> 4 */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L3_TABLE_HASH_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    /* L2/L3/ALPM shared banks */
    fields[0] = BANK2_HASH_OFFSETf;
    values[0] = 4;  /* CRC32 >> 4 */
    fields[1] = BANK3_HASH_OFFSETf;
    values[1] = 12; /* CRC32 >> 12 */
    fields[2] = BANK4_HASH_OFFSETf;
    values[2] = 20; /* CRC32 >> 20 */
    fields[3] = BANK5_HASH_OFFSETf;
    values[3] = 24; /* CRC32 >> 24 */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, SHARED_TABLE_HASH_CONTROLr,
                                 REG_PORT_ANY, 4, fields, values));
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    /* Robust Hash initialization */
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        uint32 value, seed = 0;

        if (NULL == ROBUSTHASH(unit)) {
            ROBUSTHASH(unit) = sal_alloc(sizeof(soc_robust_hash_db_t),
                                         "soc_robust_hash");
            if (ROBUSTHASH(unit) == NULL) {
                return SOC_E_MEMORY;
            }
            sal_memset(ROBUSTHASH(unit), 0, sizeof(soc_robust_hash_db_t));
        }
 
        /* Enable Robust hashing for ING_VP_VLAN_MEMBERSHIP table and configure 
         * corresponding remap and action tables.
         */
          
        if ((soc_property_get(unit, "robust_hash_disable_ing_vp_vlan", 0)) == 1)
        {
            /* Disable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr, 
                              &value, ROBUST_HASH_ENABLEf, 0x0);
            SOC_IF_ERROR_RETURN
                (WRITE_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));

            ROBUSTHASH(unit)->ing_vp_vlan_member.enable = 0;
        } else {
            /* Enable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr,
                              &value, ROBUST_HASH_ENABLEf, 0x1);
            SOC_IF_ERROR_RETURN
                (WRITE_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));
            ROBUSTHASH(unit)->ing_vp_vlan_member.enable = 1;

            /* Fill action and remap tables with random data */
            ROBUSTHASH(unit)->ing_vp_vlan_member.remap_tab[0] = 
                                              ING_VP_VLAN_MEMBERSHIP_REMAP_Am;
            ROBUSTHASH(unit)->ing_vp_vlan_member.remap_tab[1] = 
                                              ING_VP_VLAN_MEMBERSHIP_REMAP_Bm;
            ROBUSTHASH(unit)->ing_vp_vlan_member.action_tab[0] = 
                                              ING_VP_VLAN_MEMBERSHIP_ACTION_Am;
            ROBUSTHASH(unit)->ing_vp_vlan_member.action_tab[1] = 
                                              ING_VP_VLAN_MEMBERSHIP_ACTION_Bm;

            seed = soc_property_get(unit, 
                                    spn_ROBUST_HASH_SEED_INGRESS_VP_VLAN, 
                                    16777213);

            SOC_IF_ERROR_RETURN
                (soc_robust_hash_table_set(unit,
                                        &(ROBUSTHASH(unit)->ing_vp_vlan_member),
                                        seed));
        }
 
        /* Enable Robust hashing for EGR_VP_VLAN_MEMBERSHIP table and configure 
         * corresponding remap and action tables.
         */
          
        if ((soc_property_get(unit, "robust_hash_disable_egr_vp_vlan", 0)) == 1)
        {
            /* Disable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr, 
                              &value, ROBUST_HASH_ENABLEf, 0x0);
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));

            ROBUSTHASH(unit)->egr_vp_vlan_member.enable = 0;
        } else {
            /* Enable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr,
                              &value, ROBUST_HASH_ENABLEf, 0x1);
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));
            ROBUSTHASH(unit)->egr_vp_vlan_member.enable = 1;

            /* Fill action and remap tables with random data */
            ROBUSTHASH(unit)->egr_vp_vlan_member.remap_tab[0] = 
                                              EGR_VP_VLAN_MEMBERSHIP_REMAP_Am;
            ROBUSTHASH(unit)->egr_vp_vlan_member.remap_tab[1] = 
                                              EGR_VP_VLAN_MEMBERSHIP_REMAP_Bm;
            ROBUSTHASH(unit)->egr_vp_vlan_member.action_tab[0] = 
                                              EGR_VP_VLAN_MEMBERSHIP_ACTION_Am;
            ROBUSTHASH(unit)->egr_vp_vlan_member.action_tab[1] = 
                                              EGR_VP_VLAN_MEMBERSHIP_ACTION_Bm;

            seed = soc_property_get(unit, 
                                    spn_ROBUST_HASH_SEED_EGRESS_VP_VLAN, 
                                    16777213);

            SOC_IF_ERROR_RETURN
                (soc_robust_hash_table_set(unit,
                                        &(ROBUSTHASH(unit)->egr_vp_vlan_member),
                                        seed));
        }
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    return SOC_E_NONE;
}

STATIC int
_soc_td2_ledup_init(int unit)
{
    uint32 rval = 0, ix, skip_count = 0;
    int uP1_off;
    soc_info_t *si;
    uint8 skip_slot[SOC_MAX_NUM_PORTS];
    int port, blk;

    si = &SOC_INFO(unit);
    /* configure the LED scan delay cycles */
    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP0_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP0_CTRLr, &rval, LEDUP_SCAN_START_DELAYf, 14);
    soc_reg_field_set(unit, CMIC_LEDUP0_CTRLr, &rval, LEDUP_SCAN_INTRA_PORT_DELAYf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_CTRLr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP1_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP1_CTRLr, &rval, LEDUP_SCAN_START_DELAYf, 24);
    soc_reg_field_set(unit, CMIC_LEDUP1_CTRLr, &rval, LEDUP_SCAN_INTRA_PORT_DELAYf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_CTRLr(unit, rval));

    rval =0;
    /* Initialize LED Port remap registers */

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r(unit, rval));

    for (ix=1; ix <129; ix++) {
        if (si->port_p2l_mapping[ix] == -1)
            skip_count++;
        if (ix == 65)
            skip_count = 0;
        skip_slot[ix] = skip_count;
    }
    #define P2L_VALUE(i,x) ((si->port_p2l_mapping[i] == -1)? 0 : \
                            (i - uP1_off - skip_slot[i]))

    /* Configure LED Port remap registers */
    ix = 1;
    rval = 0;
    uP1_off = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_63f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_62f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_61f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_60f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_59f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_58f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_57f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_56f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_55f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_54f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_53f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_52f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_51f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_50f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_49f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_48f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_35f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_34f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_33f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_32f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_39f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_38f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_37f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_36f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_43f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_42f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_41f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_40f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_47f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_46f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_45f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_44f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_31f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_30f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_29f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_28f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_27f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_26f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_25f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_24f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_23f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_22f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_21f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_20f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_19f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_18f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_17f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_16f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_3f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_2f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_1f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_0f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_7f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_6f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_5f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_4f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_11f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_10f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_9f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_8f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_15f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_14f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_13f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_12f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r(unit, rval));


    /* Configure LED Port remap registers - LED uP1*/

    uP1_off = 64;
    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_63f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_62f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_61f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_60f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_59f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_58f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_57f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_56f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_55f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_54f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_53f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_52f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_51f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_50f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_49f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_48f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_35f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_34f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_33f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_32f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_39f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_38f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_37f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_36f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_43f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_42f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_41f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_40f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_47f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_46f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_45f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_44f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_31f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_30f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_29f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_28f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_27f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_26f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_25f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_24f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_23f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_22f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_21f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_20f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_19f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_18f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_17f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_16f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_3f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_2f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_1f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_0f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_7f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_6f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_5f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_4f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_11f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_10f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_9f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_8f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_15f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_14f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_13f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_12f, P2L_VALUE(ix,uP1_off));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r(unit, rval));

    #undef P2L_VALUE

    if ( SAL_BOOT_QUICKTURN ) {
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            port = SOC_BLOCK_PORT(unit, blk);
            if (port == -1) {
                continue;
            }
            
            #if 0
            if (SOC_USE_PORTCTRL(unit)) {
                SOC_IF_ERROR_RETURN
                    (soc_portctrl_led_chain_config(unit, port, 0x00000002));
            } else
            #endif
            {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, XLPORT_LED_CHAIN_CONFIGr,
                                   port, 0, 0x00000002));
            }
        }
    } else {
        /* Raw SCHAN ops due to missing blocks */
        _soc_reg32_set(unit, 15, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 16, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 17, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 18, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 20, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 21, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 22, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 23, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 25, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 26, 0, (0x2021700), (0x00000002));

        _soc_reg32_set(unit, 27, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 28, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 30, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 31, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 32, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 33, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 35, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 36, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 37, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 38, 0, (0x2021700), (0x00000002));

        _soc_reg32_set(unit, 40, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 41, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 42, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 43, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 45, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 46, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 47, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 48, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 50, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 51, 0, (0x2021700), (0x00000002));

        _soc_reg32_set(unit, 52, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 53, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 55, 0, (0x2021700), (0x00000002));
    }

    /* initialize the UP0, UP1 data ram */
    rval = 0;
    for (ix = 0; ix < 256; ix++) {
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit,ix, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_DATA_RAMr(unit,ix, rval));
    }

    return SOC_E_NONE;
}


extern int (*_phy_tscmod_firmware_set_helper[SOC_MAX_NUM_DEVICES])
            (int, int, uint8 *, int);
STATIC int
_soc_trident2_tsc_firmware_set(int unit, int port, uint8 *array, int datalen)
{
    /* TSC firmware set is handled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_INTERNAL;
    }

    return soc_warpcore_firmware_set(unit, port, array, datalen, 0,
                                     XLPORT_WC_UCMEM_DATAm,
                                     XLPORT_WC_UCMEM_CTRLr);
}

#if defined(SER_TR_TEST_SUPPORT)
soc_ser_test_functions_t ser_trident2_test_fun;
#endif

STATIC int
_soc_trident2_egr_buf_reset(int unit, int port, int reset)
{
    uint32 entry[SOC_MAX_MEM_WORDS];

    SOC_IF_ERROR_RETURN(
        READ_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                                            port, entry));
    soc_mem_field32_set(unit, EGR_PER_PORT_BUFFER_SFT_RESETm,
                        entry, ENABLEf, reset);
    SOC_IF_ERROR_RETURN(
        WRITE_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                                             port, entry));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_cport_reset(int unit, int port, int reset)
{
    uint32 rval = 0;

    if (reset == 1) {
        SOC_IF_ERROR_RETURN(READ_CPORT_SOFT_RESETr(unit, port, &rval));
        soc_reg_field_set(unit, CPORT_SOFT_RESETr, &rval,
                          CPORT_COREf, 1);
        SOC_IF_ERROR_RETURN(WRITE_CPORT_SOFT_RESETr(unit, port, rval));

        SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 1));
    } else {
        SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 0));

        SOC_IF_ERROR_RETURN(READ_CPORT_SOFT_RESETr(unit, port, &rval));
        soc_reg_field_set(unit, CPORT_SOFT_RESETr, &rval,
                          CPORT_COREf, 0);
        SOC_IF_ERROR_RETURN(WRITE_CPORT_SOFT_RESETr(unit, port, rval));
    }

    return SOC_E_NONE;
}


STATIC int
_soc_portctrl_trident2_port_init(int unit)
{
    soc_info_t *si;
    int port;
    int blk;

    si = &SOC_INFO(unit);

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1) {
            continue;
        }

        /* If this is a 100G port, reset egress port buffer */
        if (si->port_speed_max[port] >= 100000) {
            SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 1));

            soc_trident2_port_speed_update(unit, port, si->port_speed_max[port]);

            SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 0));
        }
    }

    return SOC_E_NONE;
}


STATIC int
_soc_trident2_port_init(int unit)
{
    static const soc_field_t port_field[] = {
        PORT0f, PORT1f, PORT2f, PORT3f
    };
    soc_info_t *si;
    uint32 rval = 0;
    int port;
    int subport0, subport2, phy_port_base;
    int blk, bindex, mode;

    si = &SOC_INFO(unit);

    if (SOC_USE_PORTCTRL(unit)) {
        return _soc_portctrl_trident2_port_init(unit);
    }

    PBMP_PORT_ITER(unit, port) {
        if ( IS_C_PORT(unit, port) &&
             (SOC_REG_IS_VALID(unit, CPORT_CONFIGr))) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, CPORT_SPARE0_REGr, port, RSVDf, 0));

            if (!IS_HG_PORT(unit, port)) {
                continue;
            }
            SOC_IF_ERROR_RETURN(READ_CPORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, CPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_CPORT_CONFIGr(unit, port, rval));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, XLPORT_SPARE0_REGr, port, RSVDf, 0));

            if (!IS_HG_PORT(unit, port)) {
                continue;
            }
            SOC_IF_ERROR_RETURN(READ_XLPORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, XLPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_XLPORT_CONFIGr(unit, port, rval));
        }
    }

    /* Enable 100G /Cports */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1) {
            continue;
        }
        /* If this is a 100G port, enable the CPORT */
        if (si->port_speed_max[port] >= 100000) {
            SOC_IF_ERROR_RETURN(_soc_trident2_cport_reset(unit, port, 1));

            SOC_IF_ERROR_RETURN(READ_CPORT_ENABLE_REGr(unit, port, &rval));
            soc_reg_field_set(unit, CPORT_ENABLE_REGr, &rval, PORT0f, 1);
            SOC_IF_ERROR_RETURN(WRITE_CPORT_ENABLE_REGr(unit, port, rval));

            soc_trident2_port_speed_update(unit, port, si->port_speed_max[port]);

            /* take cport out of reset after enable */
            SOC_IF_ERROR_RETURN(_soc_trident2_cport_reset(unit, port, 0));
        }

    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1) {
            continue;
        }
        phy_port_base = ((si->port_l2p_mapping[port] - 1) & ~0x3) + 1;

        /* Assert XLPORT soft reset */
        rval = 0;
        for (bindex = 0; bindex < _TD2_PORTS_PER_XLP; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_SOFT_RESETr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, rval));

        if (si->port_speed_max[port] > 20000) {
            mode = SOC_TD2_PORT_MODE_SINGLE;
        } else {
            subport0 = si->port_p2l_mapping[phy_port_base];
            subport2 = si->port_p2l_mapping[phy_port_base + 2];
            if (subport0 >= 0 && si->port_speed_max[subport0] > 10000) {
                if (subport2 < 0 || si->port_speed_max[subport2] <= 10000) {
                    mode = SOC_TD2_PORT_MODE_TRI_023;
                } else {
                    mode = SOC_TD2_PORT_MODE_DUAL;
                }
            } else if (subport2 >= 0 && si->port_speed_max[subport2] > 10000) {
                if (subport0 < 0 || si->port_speed_max[subport0] <= 10000) {
                    mode = SOC_TD2_PORT_MODE_TRI_012;
                } else {
                    mode = SOC_TD2_PORT_MODE_DUAL;
                }
            } else {
                mode = SOC_TD2_PORT_MODE_QUAD;
            }
        }
        rval = 0;
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_CORE_PORT_MODEf, mode);
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_PHY_PORT_MODEf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MODE_REGr(unit, port, rval));

        /* De-assert XLPORT soft reset */
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, 0));

        /* Enable XLPORT */
        rval = 0;
        for (bindex = 0; bindex < _TD2_PORTS_PER_XLP; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_ENABLE_REGr(unit, port, rval));
    }

    return SOC_E_NONE;
}

/* Configure HSP port multicast T2OQ setting.
 * Note: Caller must check if the Port is part of HSP port bitmap
 * HSP Port check:  SOC_PBMP_MEMBER(si->eq_pbm, port)
 * */

STATIC int
_soc_trident2_mc_toq_cfg(int unit, int port, int enable)
{
    static soc_field_t t2oq_fields[] = {
        IS_MC_T2OQ_PORT0f, IS_MC_T2OQ_PORT1f
    };
    soc_field_t field;
    uint32 rval, fval;
    int pipe, mmu_port, phy_port;
    soc_reg_t reg = TOQ_MC_CFG1r;
    soc_info_t *si = &SOC_INFO(unit);;

    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port) ? 1 : 0;
    field = t2oq_fields[pipe & 0x01];
    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];

    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    fval = soc_reg_field_get(unit, reg, rval, field);

    if (enable) {
        fval |= 1 << (mmu_port & 0x0f);
    } else {
        fval &= ~(1 << (mmu_port & 0x0f));
    }
    soc_reg_field_set(unit, reg, &rval, field, fval);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_misc_init(int unit)
{
    static int rtag7_field_width[] = { 16, 16, 4, 16, 8, 8, 16, 16 };
    soc_info_t *si;
    uint32 rval = 0;
    uint64 rval64;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_pbmp_t pbmp;
    int port;
    int index, count, sub_sel, offset;
    int freq, target_freq, divisor, dividend, delay;
    int parity_enable, cache_fpgm;
    soc_field_t fields[2];
    uint32 values[2];
    uint16 dev_id;
    uint8 rev_id;
    int l2_banks, l3_banks, l2_mode, l3_mode;
    int shared_l2_banks, shared_l3_banks;
    uint32 uft_bank_enable_bitmap;    
    int cam_enable;
    
    si = &SOC_INFO(unit);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    _mmu_16_mode = get_mmu_mode (unit);
#endif

    /* Stop the mem scan task before all of the parity init takes place */
    SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_stop(unit));

    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);
    if (parity_enable) {
        if ((!SAL_BOOT_SIMULATION || SAL_BOOT_QUICKTURN) &&
            !SOC_WARM_BOOT(unit)) {
            /* Certain mems/regs need to be cleared before enabling SER */
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_mmu_memory(unit, INVALIDm));
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_all_port_data(unit));
        }
        SOC_IF_ERROR_RETURN(_soc_trident2_tcam_ser_init(unit));
        SOC_IF_ERROR_RETURN(_soc_trident2_ser_enable_all(unit, TRUE));
#ifdef INCLUDE_MEM_SCAN
        soc_mem_scan_ser_list_register(unit, TRUE,
                                       _soc_td2_tcam_ser_info[unit]);
#endif
        memset(&_td2_ser_functions, 0, sizeof(soc_ser_functions_t));
        _td2_ser_functions._soc_ser_fail_f = &soc_trident2_ser_fail;
        _td2_ser_functions._soc_ser_parity_error_cmicm_intr_f = 
            &soc_trident2_ser_error;
        soc_ser_function_register(unit, &_td2_ser_functions);
#if defined(SER_TR_TEST_SUPPORT)
        /*Initialize chip-specific functions for SER testing*/
        memset(&ser_trident2_test_fun, 0, sizeof(soc_ser_test_functions_t));
        ser_trident2_test_fun.inject_error_f = &soc_td2_ser_inject_error;
        ser_trident2_test_fun.test_mem = &soc_td2_ser_test_mem;
        ser_trident2_test_fun.test = &soc_td2_ser_test;
        ser_trident2_test_fun.parity_control = &_ser_test_parity_control_reg_set;
        ser_trident2_test_fun.injection_support = &soc_td2_ser_error_injection_support;
        soc_ser_test_functions_register(unit, &ser_trident2_test_fun);
#endif /*defined(SER_TR_TEST_SUPPORT*/
    }
    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        if (!SAL_BOOT_SIMULATION || SAL_BOOT_QUICKTURN ||
                            soc_property_get(unit, "sim_clear_all_mem", 0)) {
            SOC_IF_ERROR_RETURN
                (_soc_trident2_clear_all_memory(unit, (parity_enable ? 0 : 1)));
        }
        if (!parity_enable) {
            /* Clear enabled port's regs if not done above */
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_enabled_port_data(unit));
        }
    }

    _soc_trident2_port_mapping_init(unit);
    _soc_trident2_tdm_init(unit);

    sal_memset(entry, 0, sizeof(cpu_pbm_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBMm, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBMm, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(cpu_pbm_2_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBM_2m, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBM_2m, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(multipass_loopback_bitmap_entry_t));
    soc_mem_pbmp_field_set(unit, MULTIPASS_LOOPBACK_BITMAPm, entry, BITMAPf,
                           &PBMP_LB(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, MULTIPASS_LOOPBACK_BITMAPm, MEM_BLOCK_ALL, 0,
                       entry));

    sal_memset(entry, 0, sizeof(isbs_port_to_pipe_mapping_entry_t));
    soc_mem_pbmp_field_set(unit, ISBS_PORT_TO_PIPE_MAPPINGm, entry, BITMAPf,
                           &PBMP_YPIPE(unit));
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ISBS_PORT_TO_PIPE_MAPPINGm,
                                      MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(esbs_port_to_pipe_mapping_entry_t));
    soc_mem_pbmp_field_set(unit, ESBS_PORT_TO_PIPE_MAPPINGm, entry, BITMAPf,
                           &PBMP_YPIPE(unit));
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ESBS_PORT_TO_PIPE_MAPPINGm,
                                      MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(egr_ing_port_entry_t));
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 1);
    PBMP_HG_ITER(unit, port) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, port, entry));
    }
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, si->cpu_hg_index,
                       entry));
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 2);
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, LB_PORT(unit),
                       entry));

    /* For FP_GLOBAL_MASK_TCAM, we don't have the pbmp's necessary to
     * initialize the cache until now.  This is the time to check for
     * the cache permission of this table.
     */
    cache_fpgm = soc_feature(unit, soc_feature_mem_cache) && 
            soc_property_get(unit, spn_MEM_CACHE_ENABLE, 
                             (SAL_BOOT_RTLSIM || SAL_BOOT_XGSSIM) ? 0 : 1);
    if (soc_property_get(unit, spn_MEM_CHECK_NOCACHE_OVERRIDE, 0)) {
        char mem_name[100];
        char *mptr;

        sal_memset(mem_name, 0, sizeof(mem_name));
        sal_strncpy(mem_name, "mem_nocache_", sal_strlen("mem_nocache_"));
        mptr = &mem_name[sal_strlen(mem_name)];
        sal_strncpy(mptr, SOC_MEM_NAME(unit, FP_GLOBAL_MASK_TCAMm),
                    sizeof(mem_name) - sal_strlen(mem_name) - 1);
        if (soc_property_get(unit, mem_name, 0)) {
            cache_fpgm = 0;
        }
    }

    if (cache_fpgm && (SOC_SWITCH_BYPASS_MODE(unit) != SOC_SWITCH_BYPASS_MODE_L3_AND_FP)) {
        SOC_MEM_INFO(unit, FP_GLOBAL_MASK_TCAMm).flags |=
            SOC_MEM_FLAG_CACHABLE;
        SOC_IF_ERROR_RETURN
            (soc_mem_cache_set(unit, FP_GLOBAL_MASK_TCAMm,
                               MEM_BLOCK_ALL, TRUE));
    }

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Must clear FP_GLOBAL_MASK_TCAM after port to pipe mappings
         * are initialized. */
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, FP_GLOBAL_MASK_TCAMm, COPYNO_ALL, TRUE));
    }

    SOC_IF_ERROR_RETURN(_soc_trident2_port_init(unit));

    /* Enable QGPORT in XLPORT3 block (if present) */
    SOC_PBMP_ITER(si->management_pbm, port) {
        COMPILER_64_ZERO(rval64);
        soc_reg64_field32_set(unit, CELL_ASM_0_CONTROLr, &rval64,
                              QGPORT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, CELL_ASM_0_CONTROLr, port, 0, rval64));
        break;
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    /* Enable dual hash tables */
    SOC_IF_ERROR_RETURN(_soc_trident2_hash_init(unit));
    if (! soc_feature(unit, soc_feature_enable_lp)) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, L2_ENTRY_CONTROL_6r, REG_PORT_ANY,
                                    DISABLE_L2_ENTRY_LPf, 3));
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L3_ENTRY_CONTROL_10r, 
                            REG_PORT_ANY, DISABLE_L3_ENTRY_LPf, 0xf));
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, ISS_MEMORY_CONTROL_84r, 
                            REG_PORT_ANY, DISABLE_ISS_MEMORY_LPf, 0xf));
    }
    if (soc_mem_index_count(unit, L3_DEFIP_ALPM_RAWm) > 0) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ISS_MEMORY_CONTROL_84r, REG_PORT_ANY,
                                    BYPASS_ISS_MEMORY_LPf, 0xf));
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        soc_cm_get_id_otp(unit, &dev_id, &rev_id);
        switch (dev_id) { 
            case BCM56867_DEVICE_ID :
                cam_enable = 0x0F;
                break;
            case BCM56760_DEVICE_ID :
                cam_enable = 0x00;
                break;
            default:
                cam_enable = 0xFF;
                break;
        }
        soc_reg32_set(unit, L3_DEFIP_CAM_ENABLEr, REG_PORT_ANY, 0, cam_enable);
    }

    SOC_IF_ERROR_RETURN
        (soc_trident2_hash_bank_count_get(unit, L2Xm, &l2_banks));
    SOC_IF_ERROR_RETURN
        (soc_trident2_hash_bank_count_get(unit, L3_ENTRY_ONLYm, &l3_banks));
    switch (l2_banks) {
    case 2: l2_mode = 4;
        break;
    case 3: l2_mode = 3;
        break;
    case 4: l2_mode = 2;
        break;
    case 5: l2_mode = 1;
        break;
    case 6: l2_mode = 0;
        break;
    default:
        return SOC_E_INTERNAL;
    }
    switch (l3_banks) {
    case 4: l3_mode = 4;
        break;
    case 5: l3_mode = 1;
        break;
    case 6: l3_mode = 2;
        break;
    case 7: l3_mode = 3;
        break;
    default:
        return SOC_E_INTERNAL;
    }
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L2_TABLE_HASH_CONTROLr,
                                               REG_PORT_ANY, MODEf, l2_mode));
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L3_TABLE_HASH_CONTROLr,
                                               REG_PORT_ANY, MODEf, l3_mode));

    if (soc_property_get(unit, spn_LOW_POWER, 0) && 
        soc_mem_index_max(unit, L3_DEFIP_ALPM_RAWm) == -1 ) {
        shared_l2_banks = l2_banks - 2;
        shared_l3_banks = l3_banks - 4;
        uft_bank_enable_bitmap = ((0x70 >> shared_l3_banks)&0xf) | ((1 << shared_l2_banks) - 1);
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, SHARED_TABLE_HASH_CONTROLr, 
                                                   REG_PORT_ANY, UFT_BANK_ENABLEf, 
                                                   uft_bank_enable_bitmap));
    }

    rval = 0;
    soc_reg_field_set(unit, L2_AGE_DEBUGr, &rval, AGE_COUNTf,
                      soc_mem_index_max(unit, L2Xm));
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_DEBUGr(unit, rval));

    rval = 0;
    soc_reg32_get(unit, TOQ_MC_CFG2r, REG_PORT_ANY, 0, &rval);
    soc_reg_field_set(unit, TOQ_MC_CFG2r, &rval, EPRG_KILL_TIMEOUTf, 500);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, TOQ_MC_CFG2r,
                REG_PORT_ANY, 0, rval));

    /*
     * Egress Enable
     */
    if (!SOC_IS_TRIDENT2PLUS(unit)) {
        int phy_port = 0;
        sal_memset(entry, 0, sizeof(egr_enable_entry_t));
        soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
        PBMP_ALL_ITER(unit, port) {
            phy_port = si->port_l2p_mapping[port];
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port, entry));
        }
    } else {
        /* TD2+ EGR_ENABLE should be setup during port up/down sequence
         * Only CPU port EGR_ENABLE should be set here
         */
        const int cpu_port = 0;
        const int loopback_port = si->port_l2p_mapping[LB_PORT(unit)];
        sal_memset(entry, 0, sizeof(egr_enable_entry_t));
        soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, cpu_port, entry));
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, loopback_port, entry));
    }
    sal_memset(entry, 0, sizeof(epc_link_bmap_entry_t));
    soc_mem_pbmp_field_set(unit, EPC_LINK_BMAPm, entry, PORT_BITMAPf,
                           &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0, entry));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {

        /* Bypass control settings */
        if (SOC_SWITCH_BYPASS_MODE(unit) != SOC_SWITCH_BYPASS_MODE_NONE) {
            rval = 0;

            /* TD2+ does not support IRSEL1 and IVP bypass stage */
            /*soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                   IRSEL1_STAGE_BYPASS_ENABLEf, 1); 
            soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                   IVP_STAGE_BYPASS_ENABLEf, 1);*/

            soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                   IVXLT_STAGE_BYPASS_ENABLEf, 1);

            if (SOC_SWITCH_BYPASS_MODE(unit) == SOC_SWITCH_BYPASS_MODE_L3_AND_FP) {
                soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                      IFP_STAGE_BYPASS_ENABLEf, 1);
            }

            SOC_IF_ERROR_RETURN(WRITE_ING_BYPASS_CTRLr(unit, rval));

            soc_reg_field_set(unit, EGR_BYPASS_CTRLr, &rval,
                                   EFP_STAGE_BYPASS_ENABLEf, 1);

            SOC_IF_ERROR_RETURN(WRITE_EGR_BYPASS_CTRLr(unit, rval));
        }
    }
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        /* enable all ports */
        ing_dest_port_enable_entry_t ingr_entry;
        modport_map_subport_entry_t map_entry;

        sal_memset(&ingr_entry, 0, sizeof(ingr_entry));
        soc_mem_pbmp_field_set(unit, ING_DEST_PORT_ENABLEm, &ingr_entry, PORT_BITMAPf,
                               &PBMP_ALL(unit));

        SOC_IF_ERROR_RETURN(WRITE_ING_DEST_PORT_ENABLEm(unit, MEM_BLOCK_ALL, 0,
                                                 &ingr_entry));

        sal_memset(&map_entry, 0, sizeof(map_entry));
        soc_mem_field32_set(unit, MODPORT_MAP_SUBPORTm, &map_entry, ENABLEf, 1);

        /* my_modid and other modid related initialization */
        PBMP_ALL_ITER(unit, port) {
            /* by default port is not trunk */
            /* value already 0
            soc_mem_field32_set(unit, MODPORT_MAP_SUBPORTm, &map_entry, ISTRUNKf, 0);
            */
            /* configure logical port numbers */
            soc_mem_field32_set(unit, MODPORT_MAP_SUBPORTm, &map_entry, DESTf, port);
            SOC_IF_ERROR_RETURN
                (WRITE_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ALL, port, &map_entry));
        }
        /* setting up my_modid */
        SOC_IF_ERROR_RETURN(READ_MY_MODID_SET_2_64r(unit, &rval64));

        soc_reg64_field32_set(unit, MY_MODID_SET_2_64r, &rval64,
                              MODID_0_VALIDf, 1);
        soc_reg64_field32_set(unit, MY_MODID_SET_2_64r, &rval64,
                              MODID_0f, SOC_BASE_MODID(unit));

        SOC_IF_ERROR_RETURN(WRITE_MY_MODID_SET_2_64r(unit, rval64));

    }
#endif

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &rval64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          ARP_VALIDATION_ENf, 1);
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    /*
     * If riot is enabled,
     *     MY_STATION1 will be used for tunnels.
     *     MY_STATION2 will be used for routing.
     * Else,
     *     MY_STATION1 should be used for both tunnels and routing.
     *     For this, USE_MY_STATION1_FOR_NON_TUNNELS should be set to TRUE.
     *
     * To avoid executing this code on non-td2plus devices, this code needs to
     * be checked with soc_feature_my_station_2 as well.
     */
    if (soc_feature(unit, soc_feature_my_station_2) &&
        (!soc_feature(unit, soc_feature_riot))) {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                USE_MY_STATION1_FOR_NON_TUNNELSf, 1);
    }
#endif
    if (soc_feature(unit, soc_feature_port_lag_failover)) {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                IGNORE_HG_HDR_LAG_FAILOVERf, 0);
    } else {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    }
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, rval64));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EGR_CONFIG_1r, REG_PORT_ANY, RING_MODEf,
                                1));

    PBMP_ALL_ITER(unit, port) {
        if (SOC_PBMP_MEMBER(si->eq_pbm, port)) {
            SOC_IF_ERROR_RETURN(_soc_trident2_mc_toq_cfg(unit, port, TRUE));
        }
    }

    /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
     * causes the outer tag to be removed from packets that don't have
     * a hit in the egress vlan tranlation table. Set to 0 to disable this.
     */
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
        egr_vlan_control_1_entry_t entry;
        sal_memset(&entry, 0, sizeof(entry));

        soc_mem_field32_set(unit, EGR_VLAN_CONTROL_1m, &entry, VT_MISS_UNTAGf, 0);

        /* Enable pri/cfi remarking on egress ports. */
        soc_mem_field32_set(unit, EGR_VLAN_CONTROL_1m, &entry, REMARK_OUTER_DOT1Pf,
                      1);
        PBMP_ALL_ITER(unit, port) {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1m(unit, MEM_BLOCK_ALL, port, &entry));
        }
    } else
#endif
    {
        rval = 0;
        soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);

        /* Enable pri/cfi remarking on egress ports. */
        soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
                      1);
        PBMP_ALL_ITER(unit, port) {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
        }
    }

    SOC_PBMP_ASSIGN(pbmp, PBMP_ALL(unit));
    SOC_PBMP_REMOVE(pbmp, PBMP_LB(unit));
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, ING_EN_EFILTER_BITMAPm,
                                     MEM_BLOCK_ANY, 0, &entry));
    soc_mem_pbmp_field_set(unit, ING_EN_EFILTER_BITMAPm, &entry, BITMAPf,
                           &pbmp);
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_EN_EFILTER_BITMAPm,
                                      MEM_BLOCK_ANY, 0, &entry));

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
        (soc_hbx_higig2_mcast_sizes_set(unit,
             soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                              soc_mem_index_count(unit, L2MCm) / 2),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                              soc_mem_index_count(unit, L2MCm) / 2)));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_ipmc_to_l2mc_table_size_2_to_3)) {
        /*
         * Trident2+ supports 8K L2MC groups and 16K IPMC groups.
         * When the device is configured as a fabric,
         * L2MC table support both L2MC and IPMC groups.
         * Hence the L2MC table is 24K
         */
        int l2mc_size = (soc_mem_index_count(unit, L2MCm) / 3);
        int ipmc_size = ((soc_mem_index_count(unit, L2MCm) / 3) * 2);
        SOC_IF_ERROR_RETURN
            (soc_hbx_mcast_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L2_RANGE, l2mc_size)));
        SOC_IF_ERROR_RETURN
            (soc_hbx_ipmc_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L3_RANGE, ipmc_size)));
    } else
#endif
    {
        SOC_IF_ERROR_RETURN
            (soc_hbx_mcast_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L2_RANGE, soc_mem_index_count(unit, L2MCm) / 2)));
        SOC_IF_ERROR_RETURN
            (soc_hbx_ipmc_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L3_RANGE, soc_mem_index_count(unit, L2MCm) / 2)));
    }

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    values[0] = 1;
    fields[1] = LAG_RES_ENf;
    values[1] = 1;
    SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit,
                SW2_FP_DST_ACTION_CONTROLr, REG_PORT_ANY, 2, fields, values));

    /* Populate and enable RTAG7 Macro flow offset table */
    if (soc_mem_is_valid(unit, RTAG7_FLOW_BASED_HASHm)) {
        count = soc_mem_index_max(unit, RTAG7_FLOW_BASED_HASHm);
        sal_memset(entry, 0, sizeof(rtag7_flow_based_hash_entry_t));
        for (index = 0; index < count; ) {
            for (sub_sel = 0; sub_sel < 8 && index < count; sub_sel++) {
                for (offset = 0;
                     offset < rtag7_field_width[sub_sel] && index < count;
                     offset++) {
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        SUB_SEL_ECMPf, sub_sel);
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        OFFSET_ECMPf, offset);
#ifdef BCM_RIOT_SUPPORT
                    if(soc_feature(unit, soc_feature_riot)) {
                        soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                            SUB_SEL_ECMP_LEVEL1f, sub_sel);
                        soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                            OFFSET_ECMP_LEVEL1f, offset);
                    }
#endif
                    SOC_IF_ERROR_RETURN
                        (soc_mem_write(unit, RTAG7_FLOW_BASED_HASHm,
                                       MEM_BLOCK_ANY, index, &entry));
                    index++;
                }
            }
        }
        rval = 0;
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, USE_FLOW_SEL_ECMPf, 1);
#ifdef BCM_RIOT_SUPPORT
        if(soc_feature(unit, soc_feature_riot)) {
            soc_reg_field_set(unit, RTAG7_HASH_SELr,
                &rval, USE_FLOW_SEL_ECMP1f, 1);
        }
#endif
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, 
                                                USE_FLOW_SEL_TRILL_ECMPf, 1);
        SOC_IF_ERROR_RETURN(WRITE_RTAG7_HASH_SELr(unit, rval));
    }

    freq = si->frequency;

    /*
     * Set external MDIO freq to around 6MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     */
    target_freq = 6;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVIDENDf, dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));

    /*
     * Set internal MDIO freq to around 12MHz
     * Valid range is from 2.5MHz to 20MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     * or
     * DIVISOR = core_clock_freq * DIVIDENT / (target_freq * 2)
     */
    target_freq = 12;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_INT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_INT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVISORf,
                       divisor);
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVIDENDf,
                       dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_INT_MDIOr(unit, rval));

    delay = soc_property_get(unit, spn_MDIO_OUTPUT_DELAY, -1);
    if (delay >= 1  && delay <= 15) {
        SOC_IF_ERROR_RETURN(READ_CMIC_MIIM_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_MIIM_CONFIGr, &rval, MDIO_OUT_DELAYf,
                          delay);
        SOC_IF_ERROR_RETURN(WRITE_CMIC_MIIM_CONFIGr(unit, rval));
    }

    SOC_IF_ERROR_RETURN(_soc_td2_ledup_init(unit));

    if (soc_mspi_init(unit) != SOC_E_NONE) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d : MSPI Init Failed\n"), unit));
    }

    _phy_tscmod_firmware_set_helper[unit] = _soc_trident2_tsc_firmware_set;

    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));
    }

    soc_ser_log_init(unit, NULL, 0);

    return SOC_E_NONE;
}


soc_mem_t
_soc_trident2_pmem(int unit, int port, soc_mem_t memx, soc_mem_t memy)
{
    soc_info_t *si = &SOC_INFO(unit);
    return (SOC_PBMP_MEMBER(si->xpipe_pbm, port)) ? memx : memy;
}

soc_reg_t
_soc_trident2_preg(int unit, int port, soc_reg_t regx, soc_reg_t regy)
{
    soc_info_t *si = &SOC_INFO(unit);
    return (SOC_PBMP_MEMBER(si->xpipe_pbm, port)) ? regx : regy;
}

uint32 _soc_trident2_mmu_port(int unit, int port)
{
    soc_info_t *si = &SOC_INFO(unit);
    return si->port_p2m_mapping[si->port_l2p_mapping[port]];
}

uint32 _soc_trident2_piped_mem_index(int unit, soc_port_t port,
                                     soc_mem_t mem, int arr_off)
{
    int     mmu_port;

    mmu_port = SOC_TD2_MMU_PORT(unit, port);

    switch (mem) {
    case MMU_THDM_DB_PORTSP_CONFIG_0m:
    case MMU_THDM_DB_PORTSP_CONFIG_1m:
    case MMU_THDM_MCQE_PORTSP_CONFIG_0m:
    case MMU_THDM_MCQE_PORTSP_CONFIG_1m:
        return (mmu_port & 0x3f) + _TD2_MMU_PORTS_PER_PIPE * arr_off;
    case THDI_PORT_SP_CONFIG_Xm:
    case THDI_PORT_SP_CONFIG_Ym:
    case THDI_PORT_SP_CNTRS_RT_Xm:
    case THDI_PORT_SP_CNTRS_RT_Ym:
    case THDI_PORT_SP_CNTRS_SH_Xm:
    case THDI_PORT_SP_CNTRS_SH_Ym:        
    case MMU_THDU_XPIPE_CONFIG_PORTm:
    case MMU_THDU_YPIPE_CONFIG_PORTm:
    case MMU_THDU_XPIPE_RESUME_PORTm:
    case MMU_THDU_YPIPE_RESUME_PORTm:
        return (mmu_port & 0x3f) * _TD2_MMU_NUM_POOL + arr_off;
    case THDI_PORT_PG_CONFIG_Xm:
    case THDI_PORT_PG_CONFIG_Ym: 
    case THDI_PORT_PG_CNTRS_RT1_Xm:
    case THDI_PORT_PG_CNTRS_RT1_Ym:
    case THDI_PORT_PG_CNTRS_RT2_Xm:
    case THDI_PORT_PG_CNTRS_RT2_Ym:
    case THDI_PORT_PG_CNTRS_SH1_Xm:
    case THDI_PORT_PG_CNTRS_SH1_Ym:
    case THDI_PORT_PG_CNTRS_SH2_Xm:
    case THDI_PORT_PG_CNTRS_SH2_Ym:        
        return (mmu_port & 0x3f) * _TD2_MMU_NUM_PG + arr_off;
   default:
        return 0xffffffff;
    }
}

#define _TD2_MMU_BYTES_TO_CELLS(_byte_)  \
    (((_byte_) + _TD2_MMU_BYTES_PER_CELL - 1) / _TD2_MMU_BYTES_PER_CELL)
    
STATIC void
_soc_td2_mmu_init_dev_config(int unit, _soc_mmu_device_info_t *devcfg,
                             int lossless)
{
    soc_info_t *si;
    int fifo_entry_count;
    soc_pbmp_t pbmp;
    int port;
    uint16 dev_id;
    uint8 rev_id;
    uint32* dev_mmu_params_arr = NULL;
    
    si = &SOC_INFO(unit);
    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    sal_memset(devcfg, 0, sizeof(_soc_mmu_device_info_t));

    dev_mmu_params_arr = SOC_TD2_GET_MMU_PARAMS_ARR(unit, dev_id, rev_id);
    if (!dev_mmu_params_arr) {
        return;
    }

    devcfg->max_pkt_byte = dev_mmu_params_arr[_MMU_MAX_PACKET_BYTES];
    devcfg->mmu_hdr_byte = _TD2_MMU_PACKET_HEADER_BYTES;
    devcfg->jumbo_pkt_size = _TD2_MMU_JUMBO_FRAME_BYTES;
    devcfg->default_mtu_size = _TD2_MMU_DEFAULT_MTU_BYTES;
    devcfg->mmu_cell_size = _TD2_MMU_BYTES_PER_CELL;
    /*
     * Reserve 1 cell for each cut-through fifo entry
     * Assume each port use 1 QCN queue, reserve 1 cell for each QCN queue
     * Reserve 10 cells for ingress pool overshoot for lossless setting
     */
    fifo_entry_count = 0;
    SOC_PBMP_ASSIGN(pbmp, si->port.bitmap);
    SOC_PBMP_REMOVE(pbmp, si->all.disabled_bitmap);
    SOC_PBMP_ITER(pbmp, port) {
        fifo_entry_count += si->port_speed_max[port] <= 11000 ? 4 : 16;
    }
    devcfg->mmu_total_cell = dev_mmu_params_arr[_MMU_TOTAL_CELLS] - fifo_entry_count -
        NUM_PORT(unit) - (lossless ? 10 : 0);
    devcfg->num_pg = _TD2_MMU_NUM_PG;
    devcfg->num_service_pool = _TD2_MMU_NUM_POOL;
    devcfg->flags = SOC_MMU_CFG_F_PORT_MIN | SOC_MMU_CFG_F_PORT_POOL_MIN |
                    SOC_MMU_CFG_F_RQE | SOC_MMU_CFG_F_EGR_MCQ_ENTRY;
    devcfg->total_mcq_entry = _TD2_MMU_TOTAL_MCQ_ENTRY(unit);
    devcfg->rqe_queue_num = 11;
}

STATIC int
_soc_td2_default_lossless_pg_headroom(int unit, soc_port_t port)
{
    soc_info_t *si;

    if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
        return 0;
    }

    si = &SOC_INFO(unit);
    if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
        if (si->port_speed_max[port] >= 40000) {
            return 461;
        } else if (si->port_speed_max[port] >= 20000) {
            return 262;
        } else {
            return 182;
        }
    } else {
        if (si->port_speed_max[port] >= 100000) {
            return 558;
        } else if (si->port_speed_max[port] >= 40000) {
            return 284;
        } else if (si->port_speed_max[port] >= 20000) {
            return 183;
        } else {
            return 162;
        }
    }

    return 0;
}

STATIC int
_soc_td2_min_cell_rsvd_per_mcq(int unit, int port, int default_val)
{
    int freq, speed, osub;
    soc_info_t *si;
    uint8 rev_id;

    soc_cm_get_id_otp(unit, NULL, &rev_id);

    if (rev_id == BCM56850_A1_REV_ID) {
        si = &SOC_INFO(unit);
        speed = si->port_speed_max[port];
        osub = (SOC_PBMP_MEMBER(si->oversub_pbm, port)) ? 1 : 0;

        if (speed <= 10000) {
            return (osub) ? 10 : 5;
        } else if (speed <= 40000) {
            freq = si->frequency;
            return ((freq >= 760) && !osub) ? 9 : 16;
        }
    }

    return default_val;
}

STATIC void
_soc_td2_mmu_config_buf_default(int unit, _soc_mmu_cfg_buf_t *buf,
                                _soc_mmu_device_info_t *devcfg, int lossless)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe_queue;
    int max_packet_cells, jumbo_frame_cells, default_mtu_cells;
    int port, idx, per_q_guarentee;
    int total_pool_size = 0, egr_shared_total = 0;
    int q_reserved = 0, in_reserved = 0;
    int mcq_entry_reserved = 0, per_q_mcq_entry_guarantee = 0;
    /*
    int mcq_entry_shared_total;
    */
    int rqe_entry_shared_total, min_cell_per_mcq;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;

    si = &SOC_INFO(unit);

    min_cell_per_mcq = soc_feature(unit, soc_feature_min_cell_per_queue) ? 1 : 0;
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Initializing default MMU config (u=%d)\n"), unit));
    max_packet_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->max_pkt_byte +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    jumbo_frame_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->jumbo_pkt_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    total_pool_size = devcfg->mmu_total_cell;

    buf->headroom = _TD2_PIPES_PER_DEV * max_packet_cells;

    in_reserved += buf->headroom;

    per_q_guarentee = (lossless) ? 0 : default_mtu_cells;
    per_q_mcq_entry_guarantee = default_mtu_cells;

    PBMP_ALL_ITER(unit, port) {
        mcq_entry_reserved += si->port_num_cosq[port] *
            per_q_mcq_entry_guarantee;
        q_reserved += (si->port_num_cosq[port] + si->port_num_uc_cosq[port]) *
            per_q_guarentee;
    }
    
    egr_shared_total = total_pool_size - q_reserved;
    
    /*
    mcq_entry_shared_total = _TD2_MMU_TOTAL_MCQ_ENTRY(unit) - mcq_entry_reserved;
    */

    rqe_entry_shared_total = _TD2_MMU_TOTAL_RQE_ENTRY(unit) -
                             SOC_TD2_MMU_RQE_TOTAL_RSVD_ENTRY;

    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];

        if (idx == 0) {  /* 100% scale up by 100 */
            buf_pool->size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->yellow_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->red_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->total_mcq_entry = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->total_rqe_entry = rqe_entry_shared_total;
        } else {
            buf_pool->size = 0;
            buf_pool->yellow_size = 0;
            buf_pool->red_size = 0;
            buf_pool->total_mcq_entry = 0;
            buf_pool->total_rqe_entry = 0;
        }
    }

    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
        queue_grp->guarantee = 8;
        queue_grp->pool_limit = total_pool_size;
        queue_grp->discard_enable = (lossless) ? 0 : 1;
        queue_grp->pool_scale = -1;
        queue_grp->pool_resume = default_mtu_cells * 2;
        queue_grp->yellow_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->red_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->yellow_resume = default_mtu_cells * 2;
        queue_grp->red_resume = default_mtu_cells * 2;
    }

    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        /* internal priority to priority group mapping */
        for (idx = 0; idx < 16; idx++) {
            buf_port->pri_to_prigroup[idx] = 7;
        }

        /* priority group to pool mapping */
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            buf_port->prigroups[idx].pool_idx = 0;
        }

        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_port_pool = &buf_port->pools[idx];
            buf_port_pool->guarantee = 0;
            buf_port_pool->pool_limit = 0;
            buf_port_pool->pool_resume = 0;
            if (idx == 0) {
                buf_port_pool->pool_limit = total_pool_size;
                buf_port_pool->pool_resume = 
                            total_pool_size - (default_mtu_cells * 2);
            }
            in_reserved += buf_port_pool->guarantee;
        }

        buf_port->pkt_size = max_packet_cells;
        
        /* priority group */
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            buf_prigroup = &buf_port->prigroups[idx];
            buf_prigroup->guarantee = 0;
            buf_prigroup->user_delay = -1;
            buf_prigroup->switch_delay = -1;
            buf_prigroup->pkt_size = max_packet_cells;
            buf_prigroup->device_headroom_enable = 0;
            buf_prigroup->pool_limit = 0;
            buf_prigroup->pool_floor = 0;
            buf_prigroup->pool_scale = -1;
            buf_prigroup->headroom = 0;
            buf_prigroup->pool_resume = 0;
            buf_prigroup->flow_control_enable = 0;
            if (idx == 7) {
                buf_prigroup->device_headroom_enable = 1;
                buf_prigroup->flow_control_enable = lossless;
                if (lossless) {
                    buf_prigroup->guarantee = jumbo_frame_cells;
                    buf_prigroup->headroom = 
                        _soc_td2_default_lossless_pg_headroom(unit, port);
                    buf_prigroup->pool_scale = 8;
                    buf_prigroup->pool_resume = default_mtu_cells * 2;
                }
            }
            in_reserved += buf_prigroup->guarantee + buf_prigroup->headroom;
        }

        /* multicast queue */
        for (idx = 0; idx < si->port_num_cosq[port]; idx++) {
            buf_queue = &buf_port->queues[idx];
            buf_queue->qgroup_id = -1;
            buf_queue->mcq_entry_guarantee = default_mtu_cells;
            if (lossless) {
                buf_queue->guarantee = min_cell_per_mcq ?
                    _soc_td2_min_cell_rsvd_per_mcq(unit, port, 0) : 0;
                buf_queue->discard_enable = 0;
                buf_queue->pool_scale = -1;
                buf_queue->pool_limit = egr_shared_total;
                buf_queue->yellow_limit = egr_shared_total;
                buf_queue->red_limit = egr_shared_total;
                buf_queue->color_discard_enable = 0;
                buf_queue->pool_resume = 16;
            } else {
                buf_queue->guarantee = min_cell_per_mcq ?  _soc_td2_min_cell_rsvd_per_mcq(unit, port, default_mtu_cells) : default_mtu_cells;
                buf_queue->discard_enable = 1;
                buf_queue->pool_scale = 8;
                buf_queue->pool_limit = 0;
                buf_queue->yellow_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->red_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->color_discard_enable = 1;
                buf_queue->pool_resume = 16;
            }
        }

        /* unicast queue */
        for (idx = 0; idx < si->port_num_uc_cosq[port]; idx++) {
            buf_queue = &buf_port->queues[si->port_num_cosq[port] + idx];
            buf_queue->qgroup_id = -1;
            if (lossless) {
                buf_queue->guarantee = 0;
                buf_queue->discard_enable = 0;
                buf_queue->pool_scale = -1;
                buf_queue->pool_limit = egr_shared_total;
                buf_queue->yellow_limit = egr_shared_total;
                buf_queue->red_limit = egr_shared_total;
                buf_queue->color_discard_enable = 0;
                buf_queue->pool_resume = default_mtu_cells * 2;
                buf_queue->yellow_resume = default_mtu_cells * 2;
                buf_queue->red_resume = default_mtu_cells * 2;
            } else {
                buf_queue->guarantee = default_mtu_cells;
                buf_queue->discard_enable = 1;
                buf_queue->pool_scale = 8;
                buf_queue->pool_limit = 0;
                buf_queue->yellow_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->red_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->color_discard_enable = 1;
                buf_queue->pool_resume = default_mtu_cells * 2;
                buf_queue->yellow_resume = default_mtu_cells * 2;
                buf_queue->red_resume = default_mtu_cells * 2;
            }
        }

        /* queue to pool mapping */
        for (idx = 0; 
             idx < si->port_num_cosq[port] + si->port_num_uc_cosq[port]; idx++) {
            buf_port->queues[idx].pool_idx = 0;
        }
    }

    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];
        buf_prigroup = &buf_port->prigroups[7];
        if (!lossless) {
            buf_prigroup->pool_limit = total_pool_size - in_reserved;
        }
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        buf_rqe_queue = &buf->rqe_queues[idx];
        buf_rqe_queue->pool_idx = 0;
        buf_rqe_queue->yellow_limit = egr_shared_total;
        buf_rqe_queue->red_limit = egr_shared_total;
        if (lossless) {
            buf_rqe_queue->guarantee = 0;
            buf_rqe_queue->discard_enable = 0;
            buf_rqe_queue->pool_scale = -1;
            buf_rqe_queue->pool_limit = egr_shared_total;
        } else {
            buf_rqe_queue->guarantee = default_mtu_cells;
            buf_rqe_queue->discard_enable = 1;
            buf_rqe_queue->pool_scale = 8;
            buf_rqe_queue->pool_limit = 0;
        }
    }

}

STATIC int
_soc_td2_pool_scale_to_limit(int size, int scale)
{
    int factor = 1000;

    switch (scale) {
        case 7: factor = 875; break;
        case 6: factor = 750; break;
        case 5: factor = 625; break;
        case 4: factor = 500; break;
        case 3: factor = 375; break;
        case 2: factor = 250; break;
        case 1: factor = 125; break;
        case 0:
        default:
            factor = 1000; break;
    }
    return (size * factor)/1000;
}

STATIC int
_soc_td2_mmu_config_buf_set_hw(int unit, _soc_mmu_cfg_buf_t *buf,
                               _soc_mmu_device_info_t *devcfg, int lossless)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe_queue;
    soc_reg_t reg = INVALIDr;
    soc_mem_t mem, mem1, mem2, mem3;
    uint32 rval, fval, rval2, rval3;
    uint32 entry0[SOC_MAX_MEM_WORDS], entry1[SOC_MAX_MEM_WORDS];
    thdi_port_pg_config_entry_t pg_config_mem;
    thdi_port_sp_config_entry_t thdi_sp_config;
    mmu_thdo_config_qgroup_entry_t cfg_qgrp;
    int default_mtu_cells, limit, midx, pri, rlimit, min_resume_limit;
    int port, base, numq, idx;
    int jumbo_frame_cells, pval, rqlen, qbase;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;
    static const soc_field_t prigroup_reg[] = {
        THDI_PORT_PRI_GRP0r, THDI_PORT_PRI_GRP1r
    };
    static const soc_field_t prigroup_field[] = {
        PRI0_GRPf, PRI1_GRPf, PRI2_GRPf, PRI3_GRPf,
        PRI4_GRPf, PRI5_GRPf, PRI6_GRPf, PRI7_GRPf,
        PRI8_GRPf, PRI9_GRPf, PRI10_GRPf, PRI11_GRPf,
        PRI12_GRPf, PRI13_GRPf, PRI14_GRPf, PRI15_GRPf
    };
    static const soc_field_t prigroup_spid_field[] = {
        PG0_SPIDf, PG1_SPIDf, PG2_SPIDf, PG3_SPIDf,
        PG4_SPIDf, PG5_SPIDf, PG6_SPIDf, PG7_SPIDf
    };
    int index1;
    int pool_resume = 0;
    uint16      dev_id;
    uint8       rev_id;
    uint32* dev_mmu_params_arr = NULL;
    
    soc_cm_get_id_otp(unit, &dev_id, &rev_id);
    dev_mmu_params_arr = SOC_TD2_GET_MMU_PARAMS_ARR(unit, dev_id, rev_id);
    if (!dev_mmu_params_arr) {
        return SOC_E_NOT_FOUND;
    }

    min_resume_limit = soc_feature(unit, soc_feature_min_resume_limit_1) ? 8 : 0;

    PBMP_ALL_ITER(unit, port) {
        pool_resume += 4;
    }

    si = &SOC_INFO(unit);

    jumbo_frame_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->jumbo_pkt_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    rval = 0;
    fval = dev_mmu_params_arr[_MMU_PHYSICAL_CELLS] - dev_mmu_params_arr[_MMU_RSVD_CELLS_CFAP];
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDSETr, &rval, CFAPFULLSETPOINTf,
                      fval);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDSETr(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDRESETr, &rval,
                      CFAPFULLRESETPOINTf, fval - 2 * jumbo_frame_cells);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDRESETr(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, CFAPBANKFULLr, &rval, LIMITf, 2046);
    for (idx = 0; idx < 16; idx++) {
        SOC_IF_ERROR_RETURN(WRITE_CFAPBANKFULLr(unit, idx, rval));
    }

    if (rev_id == BCM56850_A0_REV_ID || rev_id == BCM56850_A1_REV_ID) {
        rval = 0;
        soc_reg_field_set(unit, CFAP_ARBITER_MASKr, &rval, MASKf, 0xA);
        SOC_IF_ERROR_RETURN(WRITE_CFAP_ARBITER_MASKr(unit, rval));
    }

    /* internal priority to priority group mapping */
    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        for (idx = 0; idx < 16; idx++) {
            if (idx % 8 == 0) { /* 8 fields per register */
                reg = prigroup_reg[idx / 8];
                rval = 0;
            }
            soc_reg_field_set(unit, reg, &rval, prigroup_field[idx],
                              buf_port->pri_to_prigroup[idx]);
            if (idx % 8 == 7) { /* 8 fields per register */
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
            }
        }
    }

    /* Input thresholds */
    rval = 0;
    soc_reg_field_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEXr, 
                      &rval, GLOBAL_HDRM_LIMITf, buf->headroom/2);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEXr, 
                                        REG_PORT_ANY, 0, rval));
    
    soc_reg_field_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEYr, 
                      &rval, GLOBAL_HDRM_LIMITf, buf->headroom/2);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEYr, 
                                        REG_PORT_ANY, 0, rval));
    
    fval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        if ((buf->pools[idx].size & ~_MMU_CFG_BUF_PERCENT_FLAG) != 0) {
            fval |= 1 << idx;
        }
    }

    rval = 0;
    fval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        if (buf_pool->yellow_size & _MMU_CFG_BUF_PERCENT_FLAG) {
            if ((buf_pool->yellow_size & ~_MMU_CFG_BUF_PERCENT_FLAG) < 10000) {
                fval |= 1 << idx;
            }
        } else {
            if (buf->pools[idx].size != buf->pools[idx].yellow_size) {
                fval |= 1 << idx;
            }
        }
    }
    soc_reg_field_set(unit, THDI_POOL_CONFIGr, &rval, COLOR_AWAREf, fval);
    soc_reg_field_set(unit, THDI_POOL_CONFIGr, &rval, PUBLIC_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDI_POOL_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, THDI_BYPASSr, &rval, INPUT_THRESHOLD_BYPASSf, 0);
    SOC_IF_ERROR_RETURN(WRITE_THDI_BYPASSr(unit, rval));

    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        limit = buf_pool->total - (buf_pool->prigroup_headroom +
                                   buf_pool->prigroup_guarantee + 
                                   buf->headroom);

        rval = 0;
        soc_reg_field_set(unit, THDI_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf, limit);
        SOC_IF_ERROR_RETURN(WRITE_THDI_BUFFER_CELL_LIMIT_SPr(unit, idx, rval));
        
        rval = 0;
        soc_reg_field_set(unit, THDI_CELL_RESET_LIMIT_OFFSET_SPr, &rval, 
                            OFFSETf, pool_resume);
        SOC_IF_ERROR_RETURN(WRITE_THDI_CELL_RESET_LIMIT_OFFSET_SPr(unit, idx, rval));
    }

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_THDI_BUFFER_CELL_LIMIT_PUBLIC_POOLr(unit, rval));

    /* output thresholds */
    SOC_IF_ERROR_RETURN(READ_OP_THDU_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, ENABLE_QUEUE_AND_GROUP_TICKETf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, ENABLE_UPDATE_COLOR_RESUMEf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, MOP_POLICY_1Bf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, MOP_POLICY_1Af, 0);
    SOC_IF_ERROR_RETURN(WRITE_OP_THDU_CONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, MMU_THDM_DB_DEVICE_THR_CONFIGr, &rval, MOP_POLICYf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, rval));

    /* per service pool settings */
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        limit = buf_pool->total - buf_pool->queue_guarantee +
            (lossless ? 10 : 0);

        if (limit <= 0) {
            limit = 0;
        }

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_SHARED_LIMITr, &rval, 
                                                SHARED_LIMITf, limit);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr, 
                                    &rval, YELLOW_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RED_SHARED_LIMITr, 
                            &rval, RED_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RED_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RESUME_LIMITr, 
                            &rval, RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RESUME_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr, 
                            &rval, YELLOW_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RED_RESUME_LIMITr, 
                            &rval, RED_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RED_RESUME_LIMITr(unit, idx, rval));

        /* mcq entries */
        limit = buf_pool->total_mcq_entry - buf_pool->mcq_entry_reserved;

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_SHARED_LIMITr, 
                            &rval, SHARED_LIMITf, limit/4);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr, 
                            &rval, YELLOW_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr, 
                            &rval, RED_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RESUME_LIMITr, 
                                                &rval, RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RESUME_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_YELLOW_RESUME_LIMITr, 
                                       &rval, YELLOW_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_YELLOW_RESUME_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RED_RESUME_LIMITr, 
                                       &rval, RED_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RED_RESUME_LIMITr(unit, 
                                                                   idx, rval));
    }

    rval = 0;
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, 
                                    CLEAR_DROP_STATE_ON_CONFIG_UPDATEf, 1);
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, MOP_POLICY_1Bf, 1);
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, MOP_POLICY_1Af, 0);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, MMU_THDR_QE_CONFIGr, &rval, 
                                    CLEAR_DROP_STATE_ON_CONFIG_UPDATEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIGr(unit, rval));

    /* configure Q-groups */
    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
    
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QGROUPm, 
                                       MMU_THDU_YPIPE_CONFIG_QGROUPm);
        sal_memset(&cfg_qgrp, 0, sizeof(cfg_qgrp));

        soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                            Q_MIN_LIMIT_CELLf, queue_grp->guarantee);

        if (queue_grp->pool_scale != -1) {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                               Q_SHARED_ALPHA_CELLf, queue_grp->pool_scale);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    Q_LIMIT_DYNAMIC_CELLf, 1);
        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                Q_SHARED_LIMIT_CELLf, queue_grp->pool_limit);
        }
        
        if ((queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
            (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
        }

        if (queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_td2_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, queue_grp->red_limit);
        }

        if (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_td2_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, queue_grp->yellow_limit);
        }

        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));
    }

    /* Input port per port settings */
    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        rval = 0;
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            soc_reg_field_set(unit, THDI_PORT_PG_SPIDr, &rval,
                              prigroup_spid_field[idx],
                              buf_port->prigroups[idx].pool_idx);
        }
        SOC_IF_ERROR_RETURN(WRITE_THDI_PORT_PG_SPIDr(unit, port, rval));

        mem = SOC_TD2_PMEM(unit, port, THDI_PORT_SP_CONFIG_Xm, 
                                       THDI_PORT_SP_CONFIG_Ym);
        /* Per port per pool settings */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_port_pool = &buf_port->pools[idx];
            midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(&thdi_sp_config, 0, sizeof(thdi_sp_config));
            soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                                PORT_SP_MIN_LIMITf, buf_port_pool->guarantee);
            soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                           PORT_SP_RESUME_LIMITf, buf_port_pool->pool_resume);
            soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                               PORT_SP_MAX_LIMITf, buf_port_pool->pool_limit);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, midx, &thdi_sp_config));
        }

        fval = 0;
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            if (buf_port->prigroups[idx].flow_control_enable != 0) {
                for (pri=0; pri < 16; pri++) {
                    if (buf_port->pri_to_prigroup[pri] == idx) {
                        fval |= 1 << pri;
                    }
                }
            }
        }

        rval = 0;
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                                          INPUT_PORT_RX_ENABLEf, 1);
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                          PORT_PRI_XON_ENABLEf, fval);
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                          PORT_PAUSE_ENABLEf, fval ? 1 : 0);
        SOC_IF_ERROR_RETURN(WRITE_THDI_INPUT_PORT_XON_ENABLESr(unit, port, rval));

        rval = 0;
        soc_reg_field_set(unit, THDI_PORT_MAX_PKT_SIZEr, &rval, 
                            PORT_MAX_PKT_SIZEf, buf_port->pkt_size);
        SOC_IF_ERROR_RETURN(WRITE_THDI_PORT_MAX_PKT_SIZEr(unit, rval));

        /* Input port per port per priority group settings */
        mem = SOC_TD2_PMEM(unit, port, THDI_PORT_PG_CONFIG_Xm, 
                                       THDI_PORT_PG_CONFIG_Ym);
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            buf_prigroup = &buf->ports[port].prigroups[idx];

            midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(&pg_config_mem, 0, sizeof(pg_config_mem));
            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                PG_MIN_LIMITf, buf_prigroup->guarantee);

            if (buf_prigroup->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, &pg_config_mem, PG_SHARED_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                    PG_SHARED_LIMITf, buf_prigroup->pool_scale);
            } else {
                soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                   PG_SHARED_LIMITf, buf_prigroup->pool_limit);
            }

            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                         PG_GBL_HDRM_ENf, buf_prigroup->device_headroom_enable);
            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                       PG_HDRM_LIMITf, buf_prigroup->headroom);

            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                 PG_RESET_OFFSETf, buf_prigroup->pool_resume);

            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                  PG_RESET_FLOORf, buf_prigroup->pool_floor);
                                        
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, 
                                           MEM_BLOCK_ALL, midx, &pg_config_mem));
        }
    }

    /***********************************
     * THDO 
     ***********************************/
    /* Output port per port per queue setting for regular multicast queue */
    PBMP_ALL_ITER(unit, port) {
        numq = si->port_num_cosq[port];
        qbase = si->port_cosq_base[port];
        if (numq == 0) {
            continue;
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_CONFIG_0m, 
                                       MMU_THDM_DB_QUEUE_CONFIG_1m);
        base = soc_td2_l2_hw_index(unit, qbase, 0) - 1480;

        mem1 = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_OFFSET_0m, 
                                        MMU_THDM_DB_QUEUE_OFFSET_1m);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[idx];

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_config_0_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_MIN_LIMITf, buf_queue->guarantee);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_COLOR_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                           Q_SHARED_ALPHAf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                               Q_SHARED_LIMITf, buf_queue->pool_limit);
            }
            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                                    Q_COLOR_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit / 8);
            }

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_SPIDf, buf_queue->pool_idx);

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_offset_0_entry_t));

            soc_mem_field32_set(unit, mem1, entry0, 
                                RESUME_OFFSETf, (default_mtu_cells * 2)/8);
            soc_mem_field32_set(unit, mem1, entry0, 
                                YELLOW_RESUME_OFFSET_PROFILE_SELf, 0);
            soc_mem_field32_set(unit, mem1, entry0, 
                                RED_RESUME_OFFSET_PROFILE_SELf, 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx,
                               entry0));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_DB_QUEUE_RESUME_OFFSET_PROFILE_YELLOWr(unit, 0,
                        (buf_queue->yellow_limit - buf_queue->yellow_resume) / 8));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_DB_QUEUE_RESUME_OFFSET_PROFILE_REDr(unit, 0,
                        (buf_queue->red_limit - buf_queue->red_resume) / 8));
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_QUEUE_CONFIG_0m, 
                                           MMU_THDM_MCQE_QUEUE_CONFIG_1m);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[idx];

            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_queue_config_0_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_MIN_LIMITf, buf_queue->guarantee/4);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_COLOR_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                           Q_SHARED_ALPHAf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                               Q_SHARED_LIMITf, buf_queue->pool_limit/4);
            }
            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                                    Q_COLOR_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit / 8);
            }

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_SPIDf, buf_queue->pool_idx);

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_offset_0_entry_t));

            soc_mem_field32_set(unit, mem1, entry0, 
                                RESUME_OFFSETf, (default_mtu_cells * 2)/8);
            soc_mem_field32_set(unit, mem1, entry0, 
                                YELLOW_RESUME_OFFSET_PROFILE_SELf, 0);
            soc_mem_field32_set(unit, mem1, entry0, 
                                RED_RESUME_OFFSET_PROFILE_SELf, 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx,
                               entry0));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                WRITE_MMU_THDM_MCQE_QUEUE_RESUME_OFFSET_PROFILE_YELLOWr(unit, 0,
                    (buf_queue->yellow_limit - buf_queue->yellow_resume) / 8));
            
            rval = 0;
            SOC_IF_ERROR_RETURN(
                WRITE_MMU_THDM_MCQE_QUEUE_RESUME_OFFSET_PROFILE_REDr(unit, 0,
                    (buf_queue->red_limit - buf_queue->red_resume) / 8));
        }

        /* Per  port per pool */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_pool = &buf->pools[idx];
            if (buf_pool->total == 0) {
                continue;
            }

            limit = buf_pool->total - buf_pool->queue_guarantee;
            rlimit = (limit < min_resume_limit) ? min_resume_limit : limit;
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_PORTSP_CONFIG_0m, 
                                            MMU_THDM_DB_PORTSP_CONFIG_1m);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem2, idx);
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_portsp_config_0_entry_t));

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit);
            soc_mem_field32_set(unit, mem2, entry0, RED_SHARED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_SHARED_LIMITf, limit/8);

            soc_mem_field32_set(unit, mem2, entry0, 
                                            SHARED_LIMIT_ENABLEf, !lossless);

            soc_mem_field32_set(unit, mem2, entry0, SHARED_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, RED_RESUME_LIMITf, rlimit/8);
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));

            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_PORTSP_CONFIG_0m, 
                                            MMU_THDM_MCQE_PORTSP_CONFIG_1m);
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_portsp_config_0_entry_t));

            limit = buf_pool->total_mcq_entry - buf_pool->mcq_entry_reserved;
            rlimit = (limit < min_resume_limit) ? min_resume_limit : limit;

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit/4);
            soc_mem_field32_set(unit, mem2, entry0, SHARED_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMIT_ENABLEf, !lossless);
            soc_mem_field32_set(unit, mem2, entry0, RED_SHARED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem2, entry0, RED_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_SHARED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_RESUME_LIMITf, rlimit/8);

            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));
        }
    }

    /* Output port per port per queue setting for regular unicast queue */
    PBMP_PORT_ITER(unit, port) {
        /* per port regular unicast queue */
        numq = si->port_num_uc_cosq[port];
        qbase = si->port_uc_cosq_base[port];
        if (numq == 0) {
            continue;
        }
        base = soc_td2_l2_hw_index(unit, qbase, 1);
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QUEUEm, 
                                       MMU_THDU_YPIPE_CONFIG_QUEUEm);
        mem1 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_OFFSET_QUEUEm, 
                                        MMU_THDU_YPIPE_OFFSET_QUEUEm);
        mem2 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_Q_TO_QGRP_MAPm, 
                                           MMU_THDU_YPIPE_Q_TO_QGRP_MAPm);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[si->port_num_cosq[port] + idx];

            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_queue_entry_t));
            sal_memset(entry1, 0, sizeof(mmu_thdu_xpipe_offset_queue_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_MIN_LIMIT_CELLf, buf_queue->guarantee);
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                           Q_SHARED_ALPHA_CELLf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                               Q_SHARED_LIMIT_CELLf, buf_queue->pool_limit);
            }
            soc_mem_field32_set(unit, mem1, 
                entry1, RESET_OFFSET_CELLf, buf_queue->pool_resume / 8);

            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                                    Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_YELLOW_CELLf,
                     buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_RED_CELLf,
                     buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, LIMIT_YELLOW_CELLf,
                                         buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_RED_CELLf,
                                         buf_queue->red_limit / 8);
            }
            soc_mem_field32_set(unit, mem1, entry1, RESET_OFFSET_YELLOW_CELLf,
                                buf_queue->yellow_resume / 8);
            soc_mem_field32_set(unit, mem1, entry1, RESET_OFFSET_RED_CELLf,
                                buf_queue->red_resume / 8);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx, entry1));

            sal_memset(entry0, 0, sizeof(mmu_thdo_q_to_qgrp_map_entry_t));
            soc_mem_field32_set(unit, mem2,
                    entry0, Q_SPIDf, buf_queue->pool_idx);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem2, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem2, entry0, Q_COLOR_ENABLE_CELLf, 1);
            }


            if (buf_queue->qgroup_id >= 0) {
                soc_mem_field32_set(unit, mem2, entry0, QGROUP_VALIDf, 1);
                soc_mem_field32_set(unit, mem2, entry0, QGROUPf, buf_queue->qgroup_id);
                if (buf_queue->qgroup_min_enable) {
                    soc_mem_field32_set(unit, mem2, entry0, USE_QGROUP_MINf, 1);
                }
            }
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                base + idx, entry0));
        }
        
        /* Per  port per pool unicast */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_pool = &buf->pools[idx];

            if (buf_pool->total == 0) {
                continue;
            }

            limit = buf_pool->total - buf_pool->queue_guarantee;
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_PORTm, 
                                           MMU_THDU_YPIPE_CONFIG_PORTm);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem2, idx);
            mem3 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_RESUME_PORTm, 
                                            MMU_THDU_YPIPE_RESUME_PORTm);
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_port_entry_t));
            sal_memset(entry1, 0, sizeof(mmu_thdu_xpipe_resume_port_entry_t));

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit);
            soc_mem_field32_set(unit, mem3, entry1,
                         SHARED_RESUMEf, (limit - (default_mtu_cells * 2))/8);

            soc_mem_field32_set(unit, mem2, entry0, YELLOW_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem3, entry1,
                            YELLOW_RESUMEf, (limit - (default_mtu_cells*2))/8);

            soc_mem_field32_set(unit, mem2, entry0, RED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem3, entry1,
                              RED_RESUMEf, (limit - (default_mtu_cells * 2))/8);
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem3, MEM_BLOCK_ALL, 
                                index1, entry1));
        }
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        buf_rqe_queue = &buf->rqe_queues[idx];

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_MIN_PRIQr, 
                            &rval, MIN_LIMITf, buf_rqe_queue->guarantee);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_LIMIT_MIN_PRIQr(unit, idx, rval));

        rval = 0;
        rval2 = 0;
        rval3 = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                            &rval, SPIDf, buf_rqe_queue->pool_idx);

        if ((buf_rqe_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
            (buf_rqe_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                                        &rval, COLOR_LIMIT_DYNAMICf, 1);
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_RED_LIMITf, buf_rqe_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_YELLOW_LIMITf, buf_rqe_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
        } else {
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_RED_LIMITf, buf_rqe_queue->red_limit / 8);

            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_YELLOW_LIMITf, buf_rqe_queue->yellow_limit / 8);
        }

        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, &rval, LIMIT_ENABLEf, 
                            (buf_rqe_queue->discard_enable ? 1 : 0));

        if (buf_rqe_queue->pool_scale != -1) {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                                            &rval, DYNAMIC_ENABLEf, 1);
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, 
                           SHARED_ALPHAf, buf_rqe_queue->pool_scale);
        } else {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, 
                           SHARED_LIMITf, buf_rqe_queue->pool_limit);
        }
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, RESET_OFFSETf, 2);
    
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG1_PRIQr(unit, idx, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG_PRIQr(unit, idx, rval2));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_LIMIT_COLOR_PRIQr(unit, idx, rval3));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr, 
                          &rval, RESET_OFFSET_REDf, (default_mtu_cells * 2)/8);
        soc_reg_field_set(unit, MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr, 
                       &rval, RESET_OFFSET_YELLOWf, (default_mtu_cells * 2)/8);
        SOC_IF_ERROR_RETURN(
                  WRITE_MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr(unit, idx, rval));

        /* queue entry */
        buf_pool = &buf->pools[buf_rqe_queue->pool_idx];
        fval = (buf_pool->total_rqe_entry + 8 * 11 - 1) / (8 * 11);
        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_MIN_PRIQr, 
                            &rval, MIN_LIMITf, buf_rqe_queue->guarantee/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_LIMIT_MIN_PRIQr(unit, idx, rval));

        rval = 0;
        rval2 = 0;
        rval3 = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                            &rval, SPIDf, buf_rqe_queue->pool_idx);

        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                                        &rval, COLOR_LIMIT_DYNAMICf, 0);
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_COLOR_PRIQr, 
                          &rval3, SHARED_RED_LIMITf, fval);
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_COLOR_PRIQr, 
                          &rval3, SHARED_YELLOW_LIMITf, fval);
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, &rval, LIMIT_ENABLEf, 1);
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_PRIQr, &rval2, 
                          SHARED_LIMITf, fval);
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_PRIQr, &rval2, RESET_OFFSETf, 1);
    
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG1_PRIQr(unit, idx, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG_PRIQr(unit, idx, rval2));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_LIMIT_COLOR_PRIQr(unit, idx, rval3));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr, 
                          &rval, RESET_OFFSET_REDf, default_mtu_cells/8);
        soc_reg_field_set(unit, MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr, 
                       &rval, RESET_OFFSET_YELLOWf, default_mtu_cells/8);
        SOC_IF_ERROR_RETURN(
                  WRITE_MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr(unit, idx, rval));

    }

    /* per pool RQE settings */
    for (idx = 0; idx < 4; idx++) {
        buf_pool = &buf->pools[idx];
        if (((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) ||
            (buf_pool->total == 0)) {
            continue;
        }

        limit = buf_pool->total - buf_pool->queue_guarantee;
        
        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_SPr, 
                                &rval, SHARED_LIMITf, limit);
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_SPr, &rval, RESUME_LIMITf, 
                                    (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_SP_SHARED_LIMITr, &rval, 
                     SHARED_RED_LIMITf, (limit - (default_mtu_cells * 2))/8);
        soc_reg_field_set(unit, MMU_THDR_DB_SP_SHARED_LIMITr, &rval, 
                  SHARED_YELLOW_LIMITf, (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_SP_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr, &rval, 
                     RESUME_RED_LIMITf, (limit - (default_mtu_cells * 2))/8);
        soc_reg_field_set(unit, MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr, &rval, 
                  RESUME_YELLOW_LIMITf, (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr(unit, 
                                                                     idx, rval));

        rqlen = buf_pool->total_rqe_entry/8 - 1;
        if (rqlen == 0) {
            continue;
        }

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_SPr, &rval, SHARED_LIMITf, rqlen);
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_SPr, &rval, RESUME_LIMITf, rqlen - 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr, &rval, 
                                                    SHARED_RED_LIMITf, rqlen);
        soc_reg_field_set(unit, MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr, &rval, 
                                                    SHARED_YELLOW_LIMITf, rqlen);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr, &rval, 
                                                RESUME_RED_LIMITf, rqlen - 1);
        soc_reg_field_set(unit, MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr, &rval, 
                                                RESUME_YELLOW_LIMITf, rqlen - 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr(unit, 
                                                                     idx, rval));
    }

    /* Device level config setting */
    if (soc_property_get(unit, spn_PORT_UC_MC_ACCOUNTING_COMBINE, 0)) {
        SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, MMU_THDM_DB_DEVICE_THR_CONFIGr, &rval,
                          UC_MC_PORTSP_COMB_ACCT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, rval));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_td2_mmu_config_shared_update_check(int unit, int val1, int val2, int flags)
{
    int rv = 0;
    if (flags == 1) {
        if (val1 > val2) {
            rv = 1;
        }
    } else {
        if (val1 < val2) {
            rv = 1;
        }
    }
    return rv;
}

int
soc_td2_mmu_config_shared_buf_recalc(int unit, int shared_size, int flags)
{
    soc_info_t *si;
    soc_mem_t mem, mem2;
    soc_reg_t reg = INVALIDr;
    soc_field_t field = INVALIDf;
    uint32 rval, rval2;
    uint32 entry0[SOC_MAX_MEM_WORDS];
    thdi_port_pg_config_entry_t pg_config_mem;
    mmu_thdo_config_qgroup_entry_t cfg_qgrp;
    int port, base, qbase, numq, idx;
    int cur_limit, midx, index1;
    int granularity;
    uint16      dev_id;
    uint8       rev_id;
    
    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    si = &SOC_INFO(unit);

    /* per service pool settings */
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        rval = 0;
        reg = MMU_THDM_DB_POOL_SHARED_LIMITr;
        field = SHARED_LIMITf;
        granularity = 1;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;
        field = YELLOW_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;
        field = RED_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        /* mcq entries */
        rval = 0;
        reg = MMU_THDM_MCQE_POOL_SHARED_LIMITr;
        field = SHARED_LIMITf;
        granularity = 4;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr;
        field = YELLOW_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr;
        field = RED_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }
    }

    /* configure Q-groups */
    mem = MMU_THDU_XPIPE_CONFIG_QGROUPm;
    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        sal_memset(&cfg_qgrp, 0, sizeof(cfg_qgrp));

        SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));

        field = Q_SHARED_LIMIT_CELLf;
        granularity = 1;
        if (!soc_mem_field32_get(unit, mem, &cfg_qgrp, Q_LIMIT_DYNAMIC_CELLf)) {
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }
        }
        
        granularity = 8;
        if (!soc_mem_field32_get(unit, mem, &cfg_qgrp,
                                 Q_COLOR_LIMIT_DYNAMIC_CELLf)) {
            field = LIMIT_RED_CELLf;
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }

            field = LIMIT_YELLOW_CELLf;
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }
        }

        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));

        /* Y pipe */
        if ((mem == MMU_THDU_XPIPE_CONFIG_QGROUPm) &&
            (idx == (SOC_TD2_MMU_CFG_QGROUP_MAX -1))) {
            idx = 0;
            mem = MMU_THDU_YPIPE_CONFIG_QGROUPm;
        }
    }

    /* Input port per port settings */
    PBMP_ALL_ITER(unit, port) {
        rval = 0;
        /* Input port per port per priority group settings */
        mem = SOC_TD2_PMEM(unit, port, THDI_PORT_PG_CONFIG_Xm, 
                                       THDI_PORT_PG_CONFIG_Ym);
        field = PG_SHARED_LIMITf;
        granularity = 1;
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(&pg_config_mem, 0, sizeof(pg_config_mem));
            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, 
                                             MEM_BLOCK_ALL, midx, &pg_config_mem));
            if (!soc_mem_field32_get(unit, mem, &pg_config_mem, PG_SHARED_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, &pg_config_mem, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                        field, shared_size/granularity);
                }
            }
        
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, 
                                           MEM_BLOCK_ALL, midx, &pg_config_mem));
        }
    }

    /***********************************
     * THDO 
     ***********************************/
    /* Output port per port per queue setting for regular multicast queue */
    PBMP_PORT_ITER(unit, port) {
        numq = si->port_num_cosq[port];
        qbase = si->port_cosq_base[port];
        if (numq == 0) {
            continue;
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_CONFIG_0m, 
                                       MMU_THDM_DB_QUEUE_CONFIG_1m);
        base = soc_td2_l2_hw_index(unit, qbase, 0) - 1480;

        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_config_0_entry_t));

            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            field = Q_SHARED_LIMITf;
            granularity = 1;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMICf)) {
                field = YELLOW_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = RED_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_QUEUE_CONFIG_0m, 
                                           MMU_THDM_MCQE_QUEUE_CONFIG_1m);
        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_queue_config_0_entry_t));

            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            field = Q_SHARED_LIMITf;
            granularity = 4;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMICf)) {
                field = YELLOW_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = RED_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));
        }

        /* Per  port per pool */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_PORTSP_CONFIG_0m, 
                                            MMU_THDM_DB_PORTSP_CONFIG_1m);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_portsp_config_0_entry_t));

            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));

            field = SHARED_LIMITf;
            granularity = 1;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            field = RED_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            field = YELLOW_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));

            /* MCQE */
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_PORTSP_CONFIG_0m, 
                                            MMU_THDM_MCQE_PORTSP_CONFIG_1m);
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_portsp_config_0_entry_t));

            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));
            field = SHARED_LIMITf;
            granularity = 4;
            cur_limit = soc_mem_field32_get(unit, mem2, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem2, entry0, 
                                    field, shared_size/granularity);
            }

            field = RED_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem2, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem2, entry0, 
                                    field, shared_size/granularity);
            }

            field = YELLOW_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem2, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem2, entry0, 
                                    field, shared_size/granularity);
            }
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));

        }
    }

    /* Output port per port per queue setting for regular unicast queue */
    PBMP_PORT_ITER(unit, port) {
        /* per port regular unicast queue */
        numq = si->port_num_uc_cosq[port];
        qbase = si->port_uc_cosq_base[port];

        if (numq == 0) {
            continue;
        }
        base = soc_td2_l2_hw_index(unit, qbase, 1);
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QUEUEm, 
                                       MMU_THDU_YPIPE_CONFIG_QUEUEm);
        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_queue_entry_t));

            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            field = Q_SHARED_LIMIT_CELLf;
            granularity = 1;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMIC_CELLf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMIC_CELLf)) {
                field = LIMIT_YELLOW_CELLf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = LIMIT_RED_CELLf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));
        }
        
        /* Per  port per pool unicast */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_PORTm, 
                                           MMU_THDU_YPIPE_CONFIG_PORTm);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_port_entry_t));

            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));

            field = SHARED_LIMITf;
            granularity = 1;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            granularity = 8;
            field = YELLOW_LIMITf;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }
            field = RED_LIMITf;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));
        }
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        rval = 0;
        rval2 = 0;

        SOC_IF_ERROR_RETURN(READ_MMU_THDR_DB_CONFIG1_PRIQr(unit, idx, &rval));

        reg = MMU_THDR_DB_CONFIG_PRIQr;
        field = SHARED_LIMITf;
        granularity = 1;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
        if (!soc_reg_field_get(unit, MMU_THDR_DB_CONFIG1_PRIQr, rval,
                               DYNAMIC_ENABLEf)) {
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
            }
        }

        rval2 = 0;
        reg = MMU_THDR_DB_LIMIT_COLOR_PRIQr;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

        if (!soc_reg_field_get(unit, MMU_THDR_DB_CONFIG1_PRIQr, rval,
                               COLOR_LIMIT_DYNAMICf)) {
            field = SHARED_RED_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }

            field = SHARED_YELLOW_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
        }

    }

    /* per pool RQE settings */
    for (idx = 0; idx < 4; idx++) {
        reg = MMU_THDR_DB_CONFIG_SPr;
        field = SHARED_LIMITf;
        granularity = 1;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
        }

        reg = MMU_THDR_DB_SP_SHARED_LIMITr;
        granularity = 8;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

        field = SHARED_YELLOW_LIMITf;
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
        }

        field = SHARED_RED_LIMITf;
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
        }
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
    }

    return SOC_E_NONE;
}

STATIC int
soc_td2_mmu_config_init(int unit, int test_only)
{
    int rv;
    int lossless;
    _soc_mmu_cfg_buf_t *buf;
    _soc_mmu_device_info_t devcfg;

    buf = soc_mmu_cfg_alloc(unit);
    if (!buf) {
        return SOC_E_MEMORY;
    }

    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    _soc_td2_mmu_init_dev_config(unit, &devcfg, lossless);
    _soc_td2_mmu_config_buf_default(unit, buf, &devcfg, lossless);
    if (soc_property_get(unit, spn_MMU_CONFIG_OVERRIDE, 1) == 0) {
        _soc_mmu_cfg_buf_read(unit, buf, &devcfg);
    }
    rv = _soc_mmu_cfg_buf_check(unit, buf, &devcfg);
    if (!test_only) {
        if (SOC_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "MMU config: Use default setting\n")));
            _soc_td2_mmu_config_buf_default(unit, buf, &devcfg, lossless);
            _soc_mmu_cfg_buf_calculate(unit, buf, &devcfg);
        }
        rv = _soc_td2_mmu_config_buf_set_hw(unit, buf, &devcfg, lossless);
    }

    soc_mmu_cfg_free(unit, buf);

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "MMU THDI/THDO init done\n")));
    return rv;
}

/*Clear MMU_CBPDATA for TD2 mmu_init*/
STATIC int
_soc_trident2_mmu_cbpdata_clear(int unit)
{
    soc_mem_t mem;
    soc_mem_t cbpdata_start_m;
    soc_mem_t cbpdata_end_m;

    cbpdata_start_m = MMU_CBPDATA0m;
    cbpdata_end_m = MMU_CBPDATA63m;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        cbpdata_end_m = MMU_CBPDATA83m;
    }
#endif

    for (mem = cbpdata_start_m; mem <= cbpdata_end_m; mem++) {
        SOC_IF_ERROR_RETURN(
                soc_mem_clear(unit, mem, MEM_BLOCK_ALL, TRUE));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_mmu_init(int unit)
{
    uint32 rval;
    uint64 rval64;
    soc_info_t *si;
    soc_pbmp_t pbmp;
    int port, phy_port, mmu_port;    
    int alloc_size;

    SOC_IF_ERROR_RETURN(soc_td2_mmu_config_init(unit, FALSE));

    SOC_IF_ERROR_RETURN(soc_td2_lls_init(unit));

    rval = 0;
    soc_reg_field_set(unit, ES_PIPE0_LLS_CONFIG0r, &rval, ENQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, ES_PIPE0_LLS_CONFIG0r, &rval, DEQUEUE_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ES_PIPE0_LLS_CONFIG0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_ES_PIPE1_LLS_CONFIG0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_SC_FOR_MH_PRIf, 1);
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_QM_FOR_MH_PRIf, 1);
    SOC_IF_ERROR_RETURN(WRITE_PRIORITY_CONTROLr(unit, rval));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, OOBFC_CHANNEL_BASE_64r, REG_PORT_ANY,
                                ENG_ENf, 1));

    /* Enable IP to CMICM credit transfer */
    rval = 0;
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval,
                      TRANSFER_ENABLEf, 1);
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval,
                      NUM_OF_CREDITSf, 32);
    SOC_IF_ERROR_RETURN(WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(unit, rval));

    /*Clear MMU_CBPData*/
    if ( !SAL_BOOT_SIMULATION ) {
        SOC_IF_ERROR_RETURN(_soc_trident2_mmu_cbpdata_clear(unit));
    }

    /* Enable all ports */
    COMPILER_64_ZERO(rval64);

    COMPILER_64_SET(rval64, 0x1fffff, 0xffffffff);
    SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE0_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE1_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE0_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE1_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r(unit, rval64));

    if (soc_feature(unit, soc_feature_post)) {
        SOC_IF_ERROR_RETURN(soc_mmu_post_init(unit));
    }

    rval = 0;
    si = &SOC_INFO(unit);      
    pbmp = si->oversub_pbm;
    SOC_PBMP_ITER(pbmp, port) {
        if (si->port_speed_max[port] >= 30000) {
            phy_port = si->port_l2p_mapping[port];
            mmu_port = si->port_p2m_mapping[phy_port];        
            if (mmu_port < si->mmu_port_base[1]) {
                rval |= 1 << mmu_port;
            } else {
                rval |= 1 << (mmu_port - si->mmu_port_base[1] + 16);
            }
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_ENQ_ASF_HS_OVERSUB_ENr(unit, rval));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN(READ_ES_PIPE0_MMU_1DBG_Cr(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE0_MMU_1DBG_Cr, &rval, FIELD_Af, 1);
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE0_MMU_1DBG_Cr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_ES_PIPE1_MMU_1DBG_Cr(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE1_MMU_1DBG_Cr, &rval, FIELD_Af, 1);
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE1_MMU_1DBG_Cr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_ES_PIPE0_MMU_2DBG_C_0r(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE0_MMU_2DBG_C_0r, &rval, FIELD_Af, (200 * si->frequency));
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE0_MMU_2DBG_C_0r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_ES_PIPE1_MMU_2DBG_C_0r(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE1_MMU_2DBG_C_0r, &rval, FIELD_Af, (200 * si->frequency));
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE1_MMU_2DBG_C_0r(unit, rval));
    }
#endif

    PBMP_ALL_ITER(unit, port) {
        COMPILER_64_ZERO(rval64);
        soc_reg64_field32_set(unit, INTFO_CONGST_STr, &rval64, ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_INTFO_CONGST_STr(unit, port, rval64));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            SOC_IF_ERROR_RETURN(soc_td2p_mmu_delay_insertion_set (unit, 
                        port, si->port_speed_max [port])); 
        }
#endif

    }
    
    if (_fwd_ctrl_lock[unit] == NULL) {
        _fwd_ctrl_lock[unit] = sal_mutex_create("_fwd_ctrl_lock");
    }
    
    if (_fwd_ctrl_lock[unit] == NULL) {
        return SOC_E_MEMORY;
    }

    if (_soc_td2_mmu_traffic_ctrl[unit] == NULL) {
        alloc_size = sizeof(_soc_td2_mmu_traffic_ctrl_t);
        _soc_td2_mmu_traffic_ctrl[unit] = 
            sal_alloc(alloc_size,"_soc_td2_mmu_traffic_ctrl");
        if (_soc_td2_mmu_traffic_ctrl[unit] == NULL) {
            return SOC_E_MEMORY;
        }
        sal_memset(_soc_td2_mmu_traffic_ctrl[unit], 0, alloc_size);
    }

    /* Enabling the Congestion state enable ,
     *  so that dmvoq message is transmitted 
     *  when a congestion is present 
     */
    PBMP_ALL_ITER(unit, port) {
        COMPILER_64_ZERO(rval64);
        soc_reg64_field32_set(unit, INTFO_CONGST_STr, &rval64, ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_INTFO_CONGST_STr(unit, port, rval64));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    uint32 rval;

    if (!soc->l2x_sw_aging) {
        SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &rval));
        *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_ENAf);
        *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_VALf);
    } else {
        *enabled = soc->l2x_age_pid != SAL_THREAD_ERROR &&
                   soc->l2x_age_enable ?
                   1 : 0;
        *age_seconds = soc->l2x_age_pid != SAL_THREAD_ERROR &&
                       soc->l2x_age_enable ?
                       soc->l2x_age_interval : 0;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_max_get(int unit, int *max_seconds)
{
    soc_control_t *soc = SOC_CONTROL(unit);

    if (!soc->l2x_sw_aging) {
        *max_seconds =
            soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);
    } else {
        *max_seconds = 0x7fffffff;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_set(int unit, int age_seconds, int enable)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    sal_usecs_t interval = soc->l2x_age_interval;
    uint32 rval = 0;

    if (!soc->l2x_sw_aging) {
        soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_ENAf, enable);
        soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_VALf, age_seconds);
        SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, rval));
    } else if (soc->l2x_age_interval) {
        if (!enable) {
            soc->l2x_age_enable = 0;
        } else {
            if (age_seconds) {
                SOC_CONTROL_LOCK(unit);
                soc->l2x_age_interval = age_seconds;
                SOC_CONTROL_UNLOCK(unit);
            }
            soc->l2x_age_enable = 1;
            if (interval != age_seconds) {
                sal_sem_give(soc->l2x_age_notify);
            }
        }
    } else {
        if (enable) {
            SOC_IF_ERROR_RETURN
                (soc_td2_l2_bulk_age_start(unit, age_seconds));
        }
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_mdio_addr_to_port(uint32 phy_addr)
{
    int bus, offset;

    /* Must be internal MDIO address */
    if ((phy_addr & 0x80) == 0) {
        return 0;
    }

    /*
     * Internal phy address:
     * bus 0 phy 1 to 20 are mapped to Physical port 1 to 20
     * bus 1 phy 1 to 24 are mapped to Physical port 21 to 44
     * bus 2 phy 1 to 20 are mapped to Physical port 45 to 64
     * bus 3 phy 1 to 20 are mapped to Physical port 65 to 84
     * bus 4 phy 1 to 24 are mapped to Physical port 85 to 108
     * bus 5 phy 1 to 20 are mapped to Physical port 109 to 128
     */
    bus = 0;
    if (phy_addr & 0x20) {
        bus |= 0x1;
    }
    if (phy_addr & 0x40) {
        bus |= 0x2;
    }
    if (phy_addr & 0x100) {
        bus |= 0x4;
    }
    offset = 0;
    if (bus >= 5) {
        offset = 8;
    } else if (bus >= 2) {
        offset = 4;
    }
    return (20 * bus) + (phy_addr & 0x1f) + offset;
}

STATIC int
_soc_trident2_mdio_reg_read(int unit, uint32 phy_addr,
                            uint32 phy_reg, uint32 *phy_data)
{
    int port, phy_port, blk;

#if 0
    /* phy access is the same regardless if PortMod enabled */
    /* TSC reg read/write is handled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_INTERNAL;
    }
#endif

    /* Physical port based on MDIO address */
    phy_port = _soc_trident2_mdio_addr_to_port(phy_addr);

    /* THIS IS A TEMPORARY WORK AROUND FOR THE ACCESS */
    port = SOC_INFO(unit).port_p2l_mapping[phy_port&0xFFF1];
    LOG_INFO(BSL_LS_SOC_MII,
             (BSL_META_U(unit,
                         "soc_trident2_mdio_reg_read[%d]: %d/%d/%d\n"),
              unit, phy_addr, phy_port, port));
    blk = SOC_PORT_BLOCK(unit, phy_port);

    /* Call common S-bus MDIO read function */
    return soc_sbus_mdio_reg_read(unit, port, blk, 0,
                                  phy_addr, phy_reg, phy_data,
                                  XLPORT_WC_UCMEM_DATAm,
                                  XLPORT_WC_UCMEM_CTRLr);
}

STATIC int
_soc_trident2_mdio_reg_write(int unit, uint32 phy_addr,
                             uint32 phy_reg, uint32 phy_data)
{
    int port, phy_port, blk;

#if 0
    /* phy access is the same regardless if PortMod enabled */
    /* TSC reg read/write is handled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_INTERNAL;
    }
#endif

    /* Physical port based on MDIO address */
    phy_port = _soc_trident2_mdio_addr_to_port(phy_addr);
    /* THIS IS A TEMPORARY WORK AROUND FOR THE ACCESS */
    port = SOC_INFO(unit).port_p2l_mapping[phy_port & 0xFFF1];
    blk = SOC_PORT_BLOCK(unit, phy_port);

    /* Call common S-bus MDIO read function */
    return soc_sbus_mdio_reg_write(unit, port, blk, 0,
                                   phy_addr, phy_reg, phy_data,
                                   XLPORT_WC_UCMEM_DATAm,
                                   XLPORT_WC_UCMEM_CTRLr);
}

/*
 * Function:
 *      _soc_trident2_port_lanes_update_tdm
 * Description:
 *      Update PGW and MMU TDM programming for flex port
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 */
STATIC int
_soc_trident2_port_lanes_update_tdm(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg, *reg_list;
    soc_mem_t mem;
    soc_field_t field;
    int port_base, phy_port_base, mmu_port_base, pgw_inst;
    int block_info_idx, bindex;
    int cur_ids[4], cur_ids_len;
    int ids[4], ids_len;
    int pipe, base, index, slot, slot_len, seq, count, i;
    int base_end;
    uint64 rval64;
    uint32 entry[SOC_MAX_MEM_WORDS];
    uint32 rval, fval;
    static soc_reg_t pgw_obm_ctrl_regs[] = {
        PGW_OBM0_CONTROLr, PGW_OBM1_CONTROLr,
        PGW_OBM2_CONTROLr, PGW_OBM3_CONTROLr
    };
    static soc_field_t pgw_obm_bypass_fields[] = {
        PORT0_BYPASS_ENABLEf, PORT1_BYPASS_ENABLEf,
        PORT2_BYPASS_ENABLEf, PORT3_BYPASS_ENABLEf
    };
    static soc_field_t pgw_obm_oversub_fields[] = {
        PORT0_OVERSUB_ENABLEf, PORT1_OVERSUB_ENABLEf,
        PORT2_OVERSUB_ENABLEf, PORT3_OVERSUB_ENABLEf
    };
    static soc_mem_t mmu_tdm_regs[2] ={
        ES_PIPE0_TDM_CONFIGr, ES_PIPE1_TDM_CONFIGr
    };
    static soc_mem_t mmu_tdm_mems[2] ={
        ES_PIPE0_TDM_TABLE_0m, ES_PIPE1_TDM_TABLE_0m
    };
    /* Trident2+ has different registers so pointer will be changed later */
    mmu_ovs_group_wt_regs_t mmu_ovs_group_wt_regs = mmu_ovs_group_wt_regs_local;

    static soc_mem_t mmu_tdm_fields[2] ={
        PORT_NUM_EVENf, PORT_NUM_ODDf
    };

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    mmu_ovs_group_wt_regs = get_mmu_ovs_group_wt_regs ( unit, mmu_ovs_group_wt_regs );
#endif

    /* Construct new and old physical port list for calendar replacement */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    ids[0] = cur_ids[0] = phy_port_base;
    ids_len = cur_ids_len = 1;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            cur_ids[1 + i] = lanes_ctrl->phy_ports[i];
        }
        cur_ids_len += lanes_ctrl->phy_ports_len;
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            ids[1 + i] = lanes_ctrl->phy_ports[i];
        }
        ids_len += lanes_ctrl->phy_ports_len;
    }

    /* Update PGW line rate ports or oversubscription ports TDM */
    reg_list = lanes_ctrl->oversub ? pgw_ovs_tdm_regs : pgw_tdm_regs;
    pgw_inst = (si->port_group[port_base] & 0x6) | SOC_REG_ADDR_INSTANCE_MASK;
    seq = 0;
    /* if oversub then TDM have _TD2_PGW_TDM_LENGTH registers */
    base_end = lanes_ctrl->oversub ? _TD2_PGW_TDM_LENGTH : 
                                     GET_PGW_TDM_LENGTH(unit);
    for (base = 0; base < base_end; base += _PGW_TDM_SLOTS_PER_REG) {
        reg = reg_list[base / _PGW_TDM_SLOTS_PER_REG];
        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, pgw_inst, 0, &rval64));
        count = 0;
        for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
            slot = base + index;
            fval = soc_reg64_field32_get(unit, reg, rval64,
                                         pgw_tdm_fields[slot]);
            for (i = 0; i < cur_ids_len; i++) {
                if (fval == cur_ids[i]) {
                    break;
                }
            }
            if (i == cur_ids_len) { /* no match */
                continue;
            }
            if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
                LOG_CLI((BSL_META_U(unit,
                                    "set PGW_CL%d TDM slot %d from %d to %d\n"),
                         pgw_inst & ~SOC_REG_ADDR_INSTANCE_MASK, slot,
                         fval, ids[seq % ids_len]));
            }
            if (i != 0 || (seq % ids_len) != 0) {
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      ids[seq % ids_len]);
                count++;
            }
            seq++;
        }
        if (count > 0) {
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, pgw_inst, 0, rval64));
        }
    }

    /* Update oversubscription buffer manager (OBM) */
    bindex = -1;
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_PGW_CL) {
            bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
            break;
        }
    }
    reg = pgw_obm_ctrl_regs[bindex / _TD2_XLPS_PER_PGW];
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, port_base, 0, &rval64));
    if (soc_reg64_field32_get(unit, reg, rval64,
                              pgw_obm_oversub_fields[bindex & 3])) {
        /* The device does not support OBM bypass while operating in OS mode
         * on a 10GbE/20GbE */
        fval = (lanes_ctrl->lanes == 4) ? 1 : 0;
        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
            soc_reg64_field32_set(unit, reg, &rval64,
                                  pgw_obm_bypass_fields[index], fval);
        }
        SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, port_base, 0, rval64));
    }

    /* Construct new and old MMU port list for calendar replacement */
    mmu_port_base = si->port_p2m_mapping[phy_port_base];
    ids[0] = cur_ids[0] = mmu_port_base & 0x3f;
    ids_len = cur_ids_len = 1;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            cur_ids[1 + i] =
                si->port_p2m_mapping[lanes_ctrl->phy_ports[i]] & 0x3f;
        }
        cur_ids_len += lanes_ctrl->phy_ports_len;
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            ids[1 + i] = si->port_p2m_mapping[lanes_ctrl->phy_ports[i]] & 0x3f;
        }
        ids_len += lanes_ctrl->phy_ports_len;
    }

    /* Update MMU TDM */
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;
    reg = mmu_tdm_regs[pipe];
    mem = mmu_tdm_mems[pipe];
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    slot_len = (soc_reg_field_get(unit, reg, rval, CAL0_ENDf) + 1) * 2;
    slot_len -= soc_reg_field_get(unit, reg, rval, CAL0_END_SINGLEf);
    seq = 0;
    for (slot = 0; slot < slot_len; slot += 2) {
        count = 0;
        SOC_IF_ERROR_RETURN
            (soc_mem_read(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        for (index = 0; index < 2; index++) {
            if (slot + index >= slot_len){
                break;
            }
            field = mmu_tdm_fields[index];
            fval = soc_mem_field32_get(unit, mem, entry, field);
            for (i = 0; i < cur_ids_len; i++) {
                if (fval == cur_ids[i]) {
                    break;
                }
            }
            if (i == cur_ids_len) { /* no match found */
                continue;
            }
            if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
                LOG_CLI((BSL_META_U(unit,
                                    "set MMU pipe %d TDM slot %d from %d to %d\n"),
                         pipe, slot + index, fval, ids[seq % ids_len]));
            }
            if (i != 0 || (seq % ids_len) != 0) {
                soc_mem_field32_set(unit, mem, entry, field,
                                    ids[seq % ids_len]);
                count++;
            }
            seq++;
        }
        if (count > 0) {
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        }
    }

    if (lanes_ctrl->oversub) {
        if (lanes_ctrl->slot == -1) { /* new group */
            reg = mmu_ovs_group_wt_regs[pipe][lanes_ctrl->group];
            rval = 0;
            for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH; index++) {
                soc_reg_field_set(unit, reg, &rval, WEIGHTf,
                                  lanes_ctrl->weight * (index + 1));
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, index, rval));
            }
            lanes_ctrl->slot = 0;
        }
        if (lanes_ctrl->cur_empty) { /* last entry of the current group */
            reg = mmu_ovs_group_wt_regs[pipe][lanes_ctrl->cur_group];
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, 0));
        }
        /* Add into new group */
        reg = mmu_ovs_group_regs[pipe][lanes_ctrl->group];
        count = _MMU_OVS_GROUP_TDM_LENGTH /
            (_TD2_PORTS_PER_XLP / lanes_ctrl->lanes);
        rval = 0;
        if (!SOC_IS_TRIDENT2PLUS(unit)) {
            soc_reg_field_set(unit, reg, &rval, PHY_PORT_IDf,
                          si->port_serdes[port_base] & 0xf);
        }
        for (i = 0; i < ids_len; i++) {
            soc_reg_field_set(unit, reg, &rval, MMU_PORTf, ids[i]);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY,
                               lanes_ctrl->slot + i * count, rval));
        }
        /* Remove from current group */
        reg = mmu_ovs_group_regs[pipe][lanes_ctrl->cur_group];
        count = _MMU_OVS_GROUP_TDM_LENGTH /
            (_TD2_PORTS_PER_XLP / lanes_ctrl->cur_lanes);
        rval = 0;
        for (i = 0; i < cur_ids_len; i++) {
            soc_reg_field_set(unit, reg, &rval, MMU_PORTf, 0x3f);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY,
                               lanes_ctrl->cur_slot + i * count, rval));
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      _soc_trident2_port_mode_to_portmod
 * Description:
 *      Convert TD2/HW port mode value to Portmod port mode
 * Parameters:
 *      hw_mode - TD2 port mode. SOC_TD2_PORT_MODE_XXX
 *      portmod_mode - (OUT) Portmod port mode. portmodPortModeXXX
 */
STATIC int
_soc_trident2_port_mode_to_portmod(int hw_mode, int *portmod_mode)
{
#ifdef PORTMOD_SUPPORT
    switch (hw_mode) {
        case SOC_TD2_PORT_MODE_QUAD:
            *portmod_mode = portmodPortModeQuad;
            break;
        case SOC_TD2_PORT_MODE_TRI_012:
            *portmod_mode = portmodPortModeTri012;
            break;
        case SOC_TD2_PORT_MODE_TRI_023:
            *portmod_mode = portmodPortModeTri023;
            break;
        case SOC_TD2_PORT_MODE_DUAL:
            *portmod_mode = portmodPortModeDual;
            break;
        case SOC_TD2_PORT_MODE_SINGLE:
            *portmod_mode = portmodPortModeSingle;
            break;
        default:
            return SOC_E_FAIL;
    }

    return SOC_E_NONE;

#else  /* PORTMOD_SUPPORT */
    return SOC_E_UNAVAIL;
#endif /* PORTMOD_SUPPORT */
}

/*
 * Function:
 *      _soc_trident2_port_mode_from_portmod
 * Description:
 *      Convert Portmod port mode to TD2/HW port mode value
 * Parameters:
 *      portmod_mode - Portmod port mode. portmodPortModeXXX
 *      hw_mode - (OUT) TD2 port mode. SOC_TD2_PORT_MODE_XXX
 */
STATIC int
_soc_trident2_port_mode_from_portmod(int portmod_mode, int *hw_mode)
{
#ifdef PORTMOD_SUPPORT
    switch (portmod_mode) {
        case portmodPortModeQuad:
            *hw_mode = SOC_TD2_PORT_MODE_QUAD;
            break;
        case portmodPortModeTri012:
            *hw_mode = SOC_TD2_PORT_MODE_TRI_012;
            break;
        case portmodPortModeTri023:
            *hw_mode = SOC_TD2_PORT_MODE_TRI_023;
            break;
        case portmodPortModeDual:
            *hw_mode = SOC_TD2_PORT_MODE_DUAL;
            break;
        case portmodPortModeSingle:
            *hw_mode = SOC_TD2_PORT_MODE_SINGLE;
            break;
        default:
            return SOC_E_FAIL;
    }

    return SOC_E_NONE;

#else  /* PORTMOD_SUPPORT */
    return SOC_E_UNAVAIL;
#endif /* PORTMOD_SUPPORT */
}

/*
 * Function:
 *      soc_trident2_port_lanes_validate
 * Description:
 *      Validate if the specified number of lanes can be configured on a port,
 *      If the request can be done, fill in the control structure which will
 *      be used by the routines programming the hardware.
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 *
 * Each TSC can be configured into following 5 mode:
 *   Lane number    0    1    2    3
 *   ------------  ---  ---  ---  ---
 *    single port  40G   x    x    x
 *      dual port  20G   x   20G   x
 *   tri_023 port  20G   x   10G  10G
 *   tri_012 port  10G  10G  20G   x
 *      quad port  10G  10G  10G  10G
 *
 *          lanes                mode         valid lane index
 *       ------------      ----------------   ----------------
 *       new  current        new    current
 *       ---  -------      -------  -------
 * #1     4      1         single    quad            0
 * #2     4      1         single   tri_012          0
 * #3     4      2         single   tri_023          0
 * #4     4      2         single    dual            0
 * #5     2      1         tri_023   quad            0
 * #6     2      1         tri_012   quad            2
 * #7     2      1          dual    tri_023          2
 * #8     2      1          dual    tri_012          0
 * #9     2      4          dual    single           0
 * #10    1      2         tri_023   dual            2
 * #11    1      2         tri_012   dual            0
 * #12    1      2          quad    tri_023          0
 * #13    1      2          quad    tri_012          2
 * #14    1      4          quad    single           0
 * Following mode change requires 2 transition
 *   - from single to tri_023: #9 + #10
 *   - from single to tri_012: #9 + #11
 * Following mode change are the result of lane change on multiple ports
 *   - from quad to dual: #12 + #7 or #13 + #8
 *   - from dual to quad: #10 + #12 or #11 + # 13
 *   - from tri_023 to tri_012: #7 + #11 or #12 + #6
 *   - from tri_012 to tri_023: #8 + #10 or #13 + #5
 *
 * Logical port number will stay the same after conversion, for example
 *     converting single port to dual port, the logical port number of lane 0
 *     will be changed.
 */
int
soc_trident2_port_lanes_validate(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg;
    int port_base, phy_port_base, mmu_port_base, id, i;
    int block_info_idx;
    uint32 rval, fval;
    int subport0, phy_subport0;
    int pipe, group, slot, count;
    int speed_max, cur_speed_max;
    int wt_group = 0;
    int osg_bitmap;
    int port_mode;

    /* Trident2+ has different registers so pointer will be changed later */
    mmu_ovs_group_wt_regs_t mmu_ovs_group_wt_regs = mmu_ovs_group_wt_regs_local;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    mmu_ovs_group_wt_regs = get_mmu_ovs_group_wt_regs ( unit, mmu_ovs_group_wt_regs );
#endif

    /* Find physical and mmu port number for the specified port */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }
    lanes_ctrl->oversub = SOC_PBMP_MEMBER(si->oversub_pbm, port_base);

    if (lanes_ctrl->oversub && lanes_ctrl->lanes == 2) {
        if (!soc_property_get(unit, spn_20G_OVERSUB_PORT_FLEXPORT_ENABLE, 0)) {
            /* Does not allow doing flex port to 2 lanes on oversub */
            return SOC_E_PARAM;
        }
    }

    /* Find lane index for the specified port (base port) */
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (si->port_speed_max[port_base] >= 1000000) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_CPORT) {
                break;
            }
        } else {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_XLPORT) {
                break;
            }
        }
    }
    lanes_ctrl->bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);

    /* Get the current mode */
    if (SOC_USE_PORTCTRL(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_portctrl_port_mode_get(unit, port_base,
                                        &port_mode,
                                        &lanes_ctrl->cur_lanes));
        SOC_IF_ERROR_RETURN
            (_soc_trident2_port_mode_from_portmod(port_mode,
                                                  &lanes_ctrl->cur_mode));
    } else {
        SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port_base, &rval));
        lanes_ctrl->cur_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                                 XPORT0_CORE_PORT_MODEf);

        /* Figure out the current number of lanes */
        switch (lanes_ctrl->cur_mode) {
            case SOC_TD2_PORT_MODE_QUAD:
                lanes_ctrl->cur_lanes = 1;
                break;
            case SOC_TD2_PORT_MODE_TRI_012:
                lanes_ctrl->cur_lanes = lanes_ctrl->bindex == 0 ? 1 : 2;
                break;
            case SOC_TD2_PORT_MODE_TRI_023:
                lanes_ctrl->cur_lanes = lanes_ctrl->bindex == 0 ? 2 : 1;
                break;
            case SOC_TD2_PORT_MODE_DUAL:
                lanes_ctrl->cur_lanes = 2;
                break;
            case SOC_TD2_PORT_MODE_SINGLE:
                lanes_ctrl->cur_lanes = 4;
                break;
            default:
                return SOC_E_FAIL;
        }
    }

    /* Validate new number of lanes */
    if (lanes_ctrl->lanes == 4 || lanes_ctrl->cur_lanes == 4) {
        if (lanes_ctrl->bindex & 0x3) {
            return SOC_E_PARAM;
        }
    } else if (lanes_ctrl->lanes == 2 || lanes_ctrl->cur_lanes == 2) {
        if (lanes_ctrl->bindex & 0x1) {
            return SOC_E_PARAM;
        }
    } else if (lanes_ctrl->lanes != 1) {
        return SOC_E_PARAM;
    }

    /* No change to number of lanes */
    if (lanes_ctrl->lanes == lanes_ctrl->cur_lanes) {
        return SOC_E_NONE;
    }

    /* Get valid Oversub Speed Group bitmap */
    osg_bitmap = si->port_osg_bitmap[phy_port_base];

    if (lanes_ctrl->oversub) {
        mmu_port_base = si->port_p2m_mapping[phy_port_base];
        phy_subport0 = ((phy_port_base - 1) & ~0x3) + 1;
        subport0 = si->port_p2l_mapping[phy_subport0];
        pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;

        /* Figure out the new speed group */
        speed_max = si->port_speed_max[subport0] * lanes_ctrl->lanes /
            _TD2_PORTS_PER_XLP;
        lanes_ctrl->weight = (speed_max > 2500 ? speed_max : 2500) / 2500;

        /* Figure out the current speed group */
        cur_speed_max = si->port_speed_max[subport0] * lanes_ctrl->cur_lanes /
            _TD2_PORTS_PER_XLP;
        lanes_ctrl->cur_weight =
            (cur_speed_max > 2500 ? cur_speed_max : 2500) / 2500;

        lanes_ctrl->group = -1;
        lanes_ctrl->slot = -1;
        lanes_ctrl->cur_group = -1;
        lanes_ctrl->cur_slot = -1;

        for (group = 0; group < _TD2_MMU_OVS_GROUP_COUNT ; group++) {
            if (!(osg_bitmap & (0x1 << group))) {
                continue;
            }
            if (SOC_IS_TRIDENT2PLUS(unit)) {
                if ( speed_max <= 10000 ) {
                    wt_group = td2p_ovs_wt_group_speed_10G;
                } else if ( speed_max <= 20000 ) {
                    wt_group = td2p_ovs_wt_group_speed_20G;
                } else if ( speed_max <= 40000 ) {
                    wt_group = td2p_ovs_wt_group_speed_40G;
                } else {
                    wt_group = td2p_ovs_wt_group_speed_NA; /* "not" valid group */
                }
            } else {
                wt_group = group;
            }

            reg = mmu_ovs_group_wt_regs[pipe][wt_group];
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            fval = soc_reg_field_get(unit, reg, rval, WEIGHTf);
            if (fval == 0) { /* unused group */
                if (lanes_ctrl->group == -1) {
                    lanes_ctrl->group = wt_group;
                }
                continue;
            } else if (fval == lanes_ctrl->weight) {
                if (lanes_ctrl->slot == -1) {
                    /* Find a slot for new group */
                    reg = mmu_ovs_group_regs[pipe][group];
                    count = _MMU_OVS_GROUP_TDM_LENGTH /
                        (_TD2_PORTS_PER_XLP / lanes_ctrl->lanes);
                    for (slot = 0; slot < count; slot++) {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_get(unit, reg, REG_PORT_ANY, slot,
                                           &rval));
                        if (soc_reg_field_get(unit, reg, rval, MMU_PORTf) ==
                            0x3f) {
                            lanes_ctrl->group = wt_group;
                            lanes_ctrl->slot = slot;
                            break;
                        }
                    }
                }
            } else if (fval == lanes_ctrl->cur_weight) {
                if (lanes_ctrl->cur_slot == -1) {
                    /* Find the slot used by the currnet group */
                    reg = mmu_ovs_group_regs[pipe][group];
                    count = _MMU_OVS_GROUP_TDM_LENGTH /
                        (_TD2_PORTS_PER_XLP / lanes_ctrl->cur_lanes);
                    lanes_ctrl->cur_empty = TRUE;
                    for (slot = 0; slot < count; slot++) {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_get(unit, reg, REG_PORT_ANY, slot,
                                           &rval));
                        id = soc_reg_field_get(unit, reg, rval, MMU_PORTf);
                        if (id == (mmu_port_base & 0x3f)) {
                            lanes_ctrl->cur_group = group;
                            lanes_ctrl->cur_slot = slot;
                        } else if (id != 0x3f) {
                            lanes_ctrl->cur_empty = FALSE;
                        }
                        if (lanes_ctrl->cur_slot != -1 &&
                            !lanes_ctrl->cur_empty) {
                            break;
                        }
                    }
                }
            }
            if (lanes_ctrl->slot != -1 && lanes_ctrl->cur_slot != -1) {
                break;
            }
        }

        if (lanes_ctrl->cur_group == -1) {
            return SOC_E_CONFIG;
        }

        if (lanes_ctrl->group == -1) {
            return SOC_E_FULL;
        }
    }

    /* Figure out new mode */
    if (lanes_ctrl->lanes == 4) {
        lanes_ctrl->mode = SOC_TD2_PORT_MODE_SINGLE;
    } else if (lanes_ctrl->lanes == 2) {
        if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
            lanes_ctrl->mode = lanes_ctrl->bindex == 0 ?
                SOC_TD2_PORT_MODE_TRI_023 : SOC_TD2_PORT_MODE_TRI_012;
        } else {
            lanes_ctrl->mode = SOC_TD2_PORT_MODE_DUAL;
        }
    } else{
        if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_DUAL) {
            lanes_ctrl->mode = lanes_ctrl->bindex == 0 ?
                SOC_TD2_PORT_MODE_TRI_012 : SOC_TD2_PORT_MODE_TRI_023;
        } else {
            lanes_ctrl->mode = SOC_TD2_PORT_MODE_QUAD;
        }
    }

    lanes_ctrl->phy_ports_len = 0;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* Figure out which port(s) to be removed */
        if (lanes_ctrl->lanes == 4) {
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_TRI_012 ||
                lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
                if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 1;
                }
            }
            if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 2;
            }
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_TRI_023 ||
                lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
                if (si->port_p2l_mapping[phy_port_base + 3] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 3;
                }
            }
        } else {
            if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 1;
            }
        }
    } else { /* Figure out which port(s) to be added */
        if (lanes_ctrl->lanes == 2) {
            if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 2;
            }
        } else {
            if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                    phy_port_base + 1;
            }
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_SINGLE) {
                if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 2;
                }
                if (si->port_p2l_mapping[phy_port_base + 3] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 3;
                }
            }
        }
    }

    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
        static char *mode_name[] = {
            "QUAD", "TRI_012", "TRI_023", "DUAL", "SINGLE"
        };
        LOG_CLI((BSL_META_U(unit,
                            "port %d physical port %d bindex %d OSG 0x%x\n"),
                 port_base, phy_port_base, lanes_ctrl->bindex, osg_bitmap));
        LOG_CLI((BSL_META_U(unit,
                            "  mode (new:%s cur:%s) lanes (new:%d cur:%d)\n"),
                 mode_name[lanes_ctrl->mode],
                 mode_name[lanes_ctrl->cur_mode],
                 lanes_ctrl->lanes, lanes_ctrl->cur_lanes));
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            LOG_CLI((BSL_META_U(unit,
                                "  %s physical port %d (port %d)\n"),
                     lanes_ctrl->lanes > lanes_ctrl->cur_lanes ?
                     "del" : "add",
                     lanes_ctrl->phy_ports[i],
                     si->port_p2l_mapping[lanes_ctrl->phy_ports[i]]));
        }
        if (lanes_ctrl->group != -1) {
            LOG_CLI((BSL_META_U(unit,
                                "new group %d slot %d\n"),
                     lanes_ctrl->group, lanes_ctrl->slot));
        }
        LOG_CLI((BSL_META_U(unit,
                            "cur group %d slot %d\n"),
                 lanes_ctrl->cur_group, lanes_ctrl->cur_slot));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_port_icc_width_update(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    int num_lanes;
    int count_width = 0;
    int port;

    if (!soc_feature(unit, soc_feature_static_repl_head_alloc)) {
        if (SOC_REG_IS_VALID(unit, PORT_INITIAL_COPY_COUNT_WIDTHr)) {
            port = lanes_ctrl->port_base;
            if (!IS_CPU_PORT(unit, port) && !IS_LB_PORT(unit, port)) {
                num_lanes = lanes_ctrl->lanes;
                switch (num_lanes) {
                    case 1: count_width = 1;
                            break;
                    case 2: count_width = 2;
                            break;
                    case 4: count_width = 3;
                            break;
                    default: count_width = 0;
                             break;
                }
            }
            if (SOC_REG_FIELD_VALID(unit, PORT_INITIAL_COPY_COUNT_WIDTHr, 
                    BIT_WIDTHf)) {
                SOC_IF_ERROR_RETURN(
                    soc_reg_field32_modify(unit, PORT_INITIAL_COPY_COUNT_WIDTHr,
                        port, BIT_WIDTHf, count_width ? (count_width - 1) : 0));                    
            }
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_trident2_port_lanes_set
 * Description:
 *      Configure number of lanes used by a port
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 * Notes: Caller needs to call soc_trident2_port_lanes_validate to fill
 *        in the control structure.
 */
int
soc_trident2_port_lanes_set(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    int rv;
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg;
    soc_field_t fields[2];
    uint32 values[2];
    int pipe, port_base, phy_port_base, port, mmu_port, i;
    uint32 rval;
    int port_mode;
    egr_enable_entry_t entry;
    uint32 egress_per_port_buffer_entry[SOC_MAX_MEM_WORDS];
    static soc_reg_t mmu_port_credit_regs[] = {
        ES_PIPE0_MMU_PORT_CREDITr, ES_PIPE1_MMU_PORT_CREDITr
    };
    static soc_reg_t egr_reset_regs[] = {
        EGR_XLPORT_BUFFER_SFT_RESET_0_Xr, EGR_XLPORT_BUFFER_SFT_RESET_1_Xr,
        EGR_XLPORT_BUFFER_SFT_RESET_0_Yr, EGR_XLPORT_BUFFER_SFT_RESET_1_Yr
    };
    static soc_field_t egr_reset_fields[] = {
        XLP0_RESETf, XLP1_RESETf, XLP2_RESETf, XLP3_RESETf,
        XLP4_RESETf, XLP5_RESETf, XLP6_RESETf, XLP7_RESETf,
        XLP8_RESETf, XLP9_RESETf, XLP10_RESETf, XLP11_RESETf,
        XLP12_RESETf, XLP13_RESETf, XLP14_RESETf, XLP15_RESETf
    };

    /* Find physical port number and lane index of the specified port */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;

    /* Update soc_control information */
    SOC_CONTROL_LOCK(unit);
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port);
        }
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
            SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, port);
        }
    }

    /* Update num of lanes info which is used by SerDes driver */
    SOC_PORT_NUM_LANES_SET(unit, port_base, lanes_ctrl->lanes);
    for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
        port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
        si->port_num_lanes[port] =
            lanes_ctrl->lanes > lanes_ctrl->cur_lanes ? 0 : lanes_ctrl->lanes;
    }
    SOC_CONTROL_UNLOCK(unit);

    /* De-assert EGR_ENABLE */
    sal_memset(&entry, 0, sizeof(entry));
    SOC_IF_ERROR_RETURN
        (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port_base, &entry));
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL,
                                   lanes_ctrl->phy_ports[i], &entry));
        }
    }

    /* Change XLPROT mode */
    if (SOC_USE_PORTCTRL(unit)) {
        SOC_IF_ERROR_RETURN
            (_soc_trident2_port_mode_to_portmod(lanes_ctrl->mode, &port_mode));
        SOC_IF_ERROR_RETURN
            (soc_portctrl_port_mode_set(unit, port_base, port_mode));
    } else {
        fields[0] = XPORT0_CORE_PORT_MODEf;
        values[0] = lanes_ctrl->mode;
        fields[1] = XPORT0_PHY_PORT_MODEf;
        values[1] = lanes_ctrl->mode;
        SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit, XLPORT_MODE_REGr,
                                                    port_base, 2, fields, values));
    }

    if (lanes_ctrl->phy_ports_len > 0) {
        /* Update TDM */
        SOC_IF_ERROR_RETURN
            (_soc_trident2_port_lanes_update_tdm(unit, lanes_ctrl));
    }

    /* Clear MMU port credit before Resetting egress */
    reg = mmu_port_credit_regs[pipe];
    mmu_port = si->port_p2m_mapping[phy_port_base];
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, 0));
    if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            mmu_port = si->port_p2m_mapping[lanes_ctrl->phy_ports[i]];
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, 0));
        }
    }

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        sal_memset(egress_per_port_buffer_entry, 0, SOC_MAX_MEM_WORDS);
        SOC_IF_ERROR_RETURN(
                WRITE_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                    phy_port_base, egress_per_port_buffer_entry));
        if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
            for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
                SOC_IF_ERROR_RETURN(
                        WRITE_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                            lanes_ctrl->phy_ports[i], egress_per_port_buffer_entry));
            }
        }
    }
    else if (SOC_IS_TRIDENT2(unit)) {
        /* Reset egress hardware resource */
        reg = egr_reset_regs[si->port_serdes[port_base] / 8];
        fields[0] = egr_reset_fields[si->port_serdes[port_base] % 16];
        if (lanes_ctrl->lanes == 4 || lanes_ctrl->cur_lanes == 4) {
            /* reset all 4 lanes */
            values[0] = 4;
        } else if (lanes_ctrl->bindex == 0) { /* reset lanes 0 and 1 */
            values[0] = 1;
        } else { /* reset lanes 2 and 3 */
            values[0] = 2;
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        soc_reg_field_set(unit, reg, &rval, fields[0], values[0]);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
        soc_reg_field_set(unit, reg, &rval, fields[0], 0);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
    }

    /* Update PORT_INITIAL_COPY_COUNT_WIDTH registers */
    rv = _soc_trident2_port_icc_width_update(unit, lanes_ctrl);
    if (SOC_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                    "Update PORT_INITIAL_COPY_COUNT_WIDTH registers fail.")));
        return rv;
    }

    /* Assert EGR_ENABLE */
    soc_mem_field32_set(unit, EGR_ENABLEm, &entry, PRT_ENABLEf, 1);
    SOC_IF_ERROR_RETURN
        (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port_base, &entry));
    if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL,
                                   lanes_ctrl->phy_ports[i], &entry));
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_trident2_port_lanes_get
 * Description:
 *      Get number of lanes currently used by a port
 * Parameters:
 *      unit          - Device number
 *      port_base     - Port number
 *      cur_lanes     - (OUT) Number of lanes current configured on the port
 */
int
soc_trident2_port_lanes_get(int unit, soc_port_t port_base, int *cur_lanes)
{
    soc_info_t *si = &SOC_INFO(unit);
    int cur_mode;
    int phy_port_base, i;
    int block_info_idx, bindex;
    uint32 rval;

    /* Find physical port number and lane index of the specified port */
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }

    bindex = -1;
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (si->port_speed_max[port_base] >= 1000000) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_CPORT) {
                bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
                break;
            }
        } else {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_XLPORT) {
                bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
                break;
            }
        }
    }

    /* Get the current mode */
    if (SOC_USE_PORTCTRL(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_portctrl_port_mode_get(unit, port_base,
                                        &cur_mode, 
                                        cur_lanes));
    } else {
        SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port_base, &rval));
        cur_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                     XPORT0_CORE_PORT_MODEf);

        /* Figure out the current number of lane from current mode */
        switch (cur_mode) {
            case SOC_TD2_PORT_MODE_QUAD:
                *cur_lanes = 1;
                break;
            case SOC_TD2_PORT_MODE_TRI_012:
                *cur_lanes = bindex == 0 ? 1 : 2;
                break;
            case SOC_TD2_PORT_MODE_TRI_023:
                *cur_lanes = bindex == 0 ? 2 : 1;
                break;
            case SOC_TD2_PORT_MODE_DUAL:
                *cur_lanes = 2;
                break;
            case SOC_TD2_PORT_MODE_SINGLE:
                *cur_lanes = 4;
                break;
            default:
                return SOC_E_FAIL;
        }
    }

    return SOC_E_NONE;
}

static const soc_reg_t pvtmon_result_reg[] = {
    TOP_PVTMON_RESULT_0r, TOP_PVTMON_RESULT_1r,
    TOP_PVTMON_RESULT_2r, TOP_PVTMON_RESULT_3r,
    TOP_PVTMON_RESULT_4r, TOP_PVTMON_RESULT_5r,
    TOP_PVTMON_RESULT_6r, TOP_PVTMON_RESULT_7r,
    TOP_PVTMON_RESULT_8r
};

int
soc_trident2_temperature_monitor_get(int unit, 
            int temperature_max,
            soc_switch_temperature_monitor_t *temperature_array,
            int *temperature_count)
{
    soc_reg_t reg;
    int index;
    uint32 rval;
    int fval, cur, peak;
    int num_entries_out;
    soc_field_t pvtmon_field_data = TEMP_DATAf;
    soc_field_t pvtmon_field_peak = PEAK_TEMP_DATAf;
    soc_field_t top_soft_rst_field = TOP_TEMP_MON_PEAK_RST_Lf;
    int max_value = 4100000;
    int mult = 5424;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        pvtmon_field_data = PVT_DATAf;
        pvtmon_field_peak = MIN_PVT_DATAf;
        top_soft_rst_field = TOP_PVT_MON_MIN_RST_Lf;

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, AVS_REG_HW_MNTR_SW_CONTROLSr,
                REG_PORT_ANY, SW_TAKEOVERf, 1));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                AVS_REG_PVT_MNTR_CONFIG_PVT_MNTR_TP_MODE_ENABLEr,
                REG_PORT_ANY, TP_MODE_ENf, 1));
        max_value = 4100400;
        mult = 4870;
    }
#endif

    if (temperature_count) {
        *temperature_count = 0;
    }
    if (COUNTOF(pvtmon_result_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        /* Ignore PVTMON8 reg for results */
        num_entries_out = COUNTOF(pvtmon_result_reg) - 1;
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                                PVTMON_SELECTf, 0));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                PVTMON_ADC_RESETBf, 1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                PVTMON_ADC_RESETBf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                PVTMON_ADC_RESETBf, 1));

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MAX_RST_Lf, 1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MIN_RST_Lf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MAX_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MIN_RST_Lf, 0);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MAX_RST_Lf, 1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MIN_RST_Lf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    }
#endif

    sal_usleep(1000);

    for (index = 0; index < num_entries_out; index++) {
        peak = 0;
        cur = 0;
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));

        fval = soc_reg_field_get(unit, reg, rval, pvtmon_field_data);
        cur = (max_value - (mult * fval)) / 1000;
        fval = soc_reg_field_get(unit, reg, rval, pvtmon_field_peak);
        peak = (max_value - (mult * fval)) / 1000;
        if (temperature_array) {
            (temperature_array + index)->curr = cur;
            (temperature_array + index)->peak = peak;
        }
    }

    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, AVS_REG_HW_MNTR_SW_CONTROLSr,
                REG_PORT_ANY, SW_TAKEOVERf, 0));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                AVS_REG_PVT_MNTR_CONFIG_PVT_MNTR_TP_MODE_ENABLEr,
                REG_PORT_ANY, TP_MODE_ENf, 0));
    }
#endif
    if (temperature_count) {
        *temperature_count=num_entries_out;
    }
    return SOC_E_NONE;
}

int
soc_trident2_show_material_process(int unit)
{
    soc_reg_t reg;
    int index;
    uint32 rval, fval, nmos[COUNTOF(pvtmon_result_reg)], n_avg, p_avg;
    soc_field_t pvtmon_field_data = TEMP_DATAf;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        pvtmon_field_data = PVT_DATAf;
    }
#endif

    READ_TOP_PVTMON_CTRL_1r(unit, &rval);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 0);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    sal_usleep(1000);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    sal_usleep(1000);

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                                PVTMON_SELECTf, 1));
    sal_usleep(1000);

    p_avg = 0;

    /* Read NMOS information */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 5));

    sal_usleep(1000);

    n_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        nmos[index] = soc_reg_field_get(unit, reg, rval, pvtmon_field_data);
        n_avg += nmos[index];
    }

    /* Read PMOS information and print both NMOS and PMOS value */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 7));

    sal_usleep(1000);

    p_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, pvtmon_field_data);
        p_avg += fval;

        LOG_CLI((BSL_META_U(unit,
                            "Material process location %d: NMOS = %3d PMOS = %3d\n"),
                 index, nmos[index], fval));
    }

    LOG_CLI((BSL_META_U(unit,
                        "Average:                     NMOS = %3d PMOS = %3d\n"),
             n_avg / COUNTOF(pvtmon_result_reg),
             p_avg / COUNTOF(pvtmon_result_reg)));

    return SOC_E_NONE;
}

int
soc_trident2_show_ring_osc(int unit)
{
    static const struct {
        int osc_sel;
        soc_field_t field0;
        int value0;
        soc_field_t field1;
        int value1;
        char *name;
    } osc_tbl[] = {
        { 0, OSC_0_SELf, 0, INVALIDf, -1, "IO ring 0 HVT min" },
        { 0, OSC_0_SELf, 1, INVALIDf, -1, "IO ring 0 HVT mid" },
        { 0, OSC_0_SELf, 2, INVALIDf, -1, "IO ring 0 HVT max" },
        { 0, OSC_0_SELf, 3, INVALIDf, -1, "IO ring 0 SVT min" },
        { 1, OSC_1_SELf, 0, INVALIDf, -1, "IO ring 1 HVT min" },
        { 1, OSC_1_SELf, 1, INVALIDf, -1, "IO ring 1 HVT mid" },
        { 1, OSC_1_SELf, 2, INVALIDf, -1, "IO ring 1 HVT max" },
        { 1, OSC_1_SELf, 3, INVALIDf, -1, "IO ring 1 SVT min" },
        { 2, IROSC_SELf, 0, INVALIDf, -1, "Core ring 0 five stages" },
        { 2, IROSC_SELf, 1, INVALIDf, -1, "Core ring 0 nine stages" },
        { 3, IROSC_SELf, 0, INVALIDf, -1, "Core ring 1 five stages" },
        { 3, IROSC_SELf, 1, INVALIDf, -1, "Core ring 1 nine stages" },
        { 4, SRAM_OSC_0_PENf, 0, SRAM_OSC_0_NENf, 1, "SRAM ring 0 NMOS" },
        { 5, SRAM_OSC_0_PENf, 1, SRAM_OSC_0_NENf, 0, "SRAM ring 0 PMOS" },
        { 6, SRAM_OSC_1_PENf, 0, SRAM_OSC_1_NENf, 1, "SRAM ring 1 NMOS" },
        { 7, SRAM_OSC_1_PENf, 1, SRAM_OSC_1_NENf, 0, "SRAM ring 1 PMOS" },
        { 8, SRAM_OSC_2_PENf, 0, SRAM_OSC_2_NENf, 1, "SRAM ring 2 NMOS" },
        { 9, SRAM_OSC_2_PENf, 1, SRAM_OSC_2_NENf, 0, "SRAM ring 2 PMOS" },
        { 10, SRAM_OSC_3_PENf, 0, SRAM_OSC_3_NENf, 1, "SRAM ring 3 NMOS" },
        { 11, SRAM_OSC_3_PENf, 1, SRAM_OSC_3_NENf, 0, "SRAM ring 3 PMOS" },
        { 12, SRAM_OSC_4_PENf, 0, SRAM_OSC_4_NENf, 1, "SRAM ring 4 NMOS" },
        { 13, SRAM_OSC_4_PENf, 1, SRAM_OSC_4_NENf, 0, "SRAM ring 4 PMOS" },
        { 14, SRAM_OSC_5_PENf, 0, SRAM_OSC_5_NENf, 1, "SRAM ring 5 NMOS" },
        { 15, SRAM_OSC_5_PENf, 1, SRAM_OSC_5_NENf, 0, "SRAM ring 5 PMOS" },
    };
    soc_reg_t ctrl_reg, stat_reg;
    uint32 rval, fval;
    int index, core_clk, quo, rem, frac, retry;

    core_clk = SOC_INFO(unit).frequency * 1024;
    ctrl_reg = TOP_RING_OSC_CTRLr;
    stat_reg = TOP_OSC_COUNT_STATr;

    for (index = 0; index < COUNTOF(osc_tbl); index++) {
        rval = 0;
        /*
         * set OSC_CNT_RSTBf to 0 to do softreset
         * set OSC_CNT_START to 0 to hold the counter until it selects
         * the input signal
         */
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_ENABLEf, 1);
        soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_ENf, 1);
        soc_reg_field_set(unit, ctrl_reg, &rval, osc_tbl[index].field0,
                          osc_tbl[index].value0);
        if (osc_tbl[index].field1 != INVALIDf) {
            soc_reg_field_set(unit, ctrl_reg, &rval, osc_tbl[index].field1,
                              osc_tbl[index].value1);
        }
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_SELf,
                          osc_tbl[index].osc_sel);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_CNT_RSTBf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_CNT_STARTf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));

        for (retry = 0; retry < 10; retry++) {
            sal_usleep(1000);
            SOC_IF_ERROR_RETURN(READ_TOP_OSC_COUNT_STATr(unit, &rval));
            if (!soc_reg_field_get(unit, stat_reg, rval, OSC_CNT_DONEf)) {
                continue;
            }

            fval = soc_reg_field_get(unit, stat_reg, rval, OSC_CNT_VALUEf);
            quo = core_clk / fval;
            rem = core_clk - quo * fval;
            frac = (rem * 10000) / fval;
            LOG_CLI((BSL_META_U(unit,
                                "%s: %d.%04d Mhz\n"),
                     osc_tbl[index].name, quo, frac));
            break;
        }
    }

    return SOC_E_NONE;
}

void
soc_td2_process_func_intr(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    uint32 rval;

    if (soc_feature(unit, soc_feature_l2_overflow)) {
        if (READ_IL2LU_INTR_STATUSr(unit, &rval)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d: Error reading %s reg !!\n"),
                                  unit, SOC_REG_NAME(unit, IL2LU_INTR_STATUSr)));
            return;
        }
        if (soc_reg_field_get(unit, IL2LU_INTR_STATUSr, rval, L2_LEARN_INSERT_FAILUREf)) {
            soc_td2_l2_overflow_interrupt_handler(unit);
        } 
    } 
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d1 != NULL) {
        (void)soc_cmicm_intr1_enable(unit, PTR_TO_INT(d1));
    }
}

int
soc_td2_port_asf_speed_set(int unit, soc_port_t port, int speed)
{
    uint32 asf_speed_mode;
    uint32 rval; 

    SOC_IF_ERROR_RETURN(READ_ASF_PORT_CFGr(unit, port, &rval));
    
    switch (speed) {
        case 10:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_10M_FULL;
            break;
        case 100:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_100M_FULL;
            break;
        case 1000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_1000M_FULL;
            break;
        case 2500:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_2500M_FULL;
            break;
        case 5000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_5000M_FULL;
            break;
        case 10000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_10000M_FULL;
            break;
        case 11000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_11000M_FULL;
            break;
        case 12000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_12000M_FULL;
            break;
        case 13000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_13000M_FULL; 
            break; 
        case 15000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_15000M_FULL;
            break;
        case 16000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_16000M_FULL;
            break;
        case 20000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_20000M_FULL;
            break;
        case 21000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_21000M_FULL;
            break;
        case 24000:
        /* As 24G HG is not supported in TD2, so use 24G value of ASF_PORT_CFG
         * (20 = 24Gbps (full duplex)) for HG 25G case */
        case 25000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_24000M_FULL;
            break;
        case 30000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_30000M_FULL;
            break;
        case 32000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_32000M_FULL;
            break;
        case 40000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_40000M_FULL;
            break;
        case 42000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_42000M_FULL;
            break;
        case 100000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_100000M_FULL;
            break;
        case 120000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_120000M_FULL;
            break;
        case 0:
            return SOC_E_NONE;
        default:
            return SOC_E_PARAM;
    }   
    
    soc_reg_field_set(unit, ASF_PORT_CFGr, &rval,
                      ASF_PORT_SPEEDf, asf_speed_mode);
    
    SOC_IF_ERROR_RETURN(WRITE_ASF_PORT_CFGr(unit, port, rval));  
    return SOC_E_NONE;
}

int
soc_trident2_port_speed_update(int unit, soc_port_t port, int speed)
{
    soc_info_t *si;
    soc_reg_t reg;
    soc_field_t field;
    uint16 dev_id;
    uint8 rev_id;
    uint32 rval, fval;
    uint64 rval64;
    int block_info_idx;
    int pipe, xlp, obm_inst, phy_port, mmu_port, index, i;
    int asf_credit_thresh_lo, asf_credit_thresh_hi;
    int max_quad_core_bandwidth, quad_oversub_core_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    egr_edb_xmit_ctrl_entry_t entry;
    int lossless;
    int obm_setting_idx, oversub_ratio_idx;
    int min_threshold, xoff_threshold, xon_threshold, xon_threshold_offset;
    static const struct _obm_setting_s {
        int max_threshold;
        int xoff_threshold[3]; /* for oversub ratio 1.27, 1.43, and above */
    } obm_settings[] = {
        { _TD2_TD2_CELLS_PER_OBM / 4, { 79, 26, 37 } },      /* 10G */
        { _TD2_TD2_CELLS_PER_OBM / 2, { 315, 242, 86 } },    /* 20G */
        { _TD2_TD2_CELLS_PER_OBM, { 707, 584, 339 } },       /* 40G */
        { _TD2_TD2_CELLS_PER_OBM }                           /* 42G */
    };
    static soc_reg_t asf_credit_thresh_lo_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_LOr, ES_PIPE1_ASF_CREDIT_THRESH_LOr
    };
    static soc_reg_t asf_credit_thresh_hi_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_HIr, ES_PIPE1_ASF_CREDIT_THRESH_HIr
    };
    static const soc_reg_t pgw_obm_threshold_regs[] = {
        PGW_OBM0_THRESHOLDr, PGW_OBM1_THRESHOLDr,
        PGW_OBM2_THRESHOLDr, PGW_OBM3_THRESHOLDr
    };
    static soc_field_t t2oq_fields[] = {
        IS_MC_T2OQ_PORT0f, IS_MC_T2OQ_PORT1f
    };

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);
    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    si = &SOC_INFO(unit);
    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port) ? 1 : 0;

    /* Update Edatabuf transmit start count */
    if (si->frequency == 415 && !SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
        SOC_IF_ERROR_RETURN(soc_mem_read(unit, EGR_EDB_XMIT_CTRLm,
                                         MEM_BLOCK_ALL, phy_port, &entry));
        soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, &entry, START_CNTf,
                _TD2_MMU_XMIT_START_CNT_LINERATE(speed));
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                          MEM_BLOCK_ALL, phy_port, &entry));
    }

    /* Updtae VBS (HSP) port multicast T2OQ setting */
    if (SOC_PBMP_MEMBER(si->eq_pbm, port) && si->frequency < 500) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, TOQ_MC_CFG1r, REG_PORT_ANY, 0, &rval));
        field = t2oq_fields[pipe];
        fval = soc_reg_field_get(unit, TOQ_MC_CFG1r, rval, field);
        if (speed >= 30000) {
            fval |= 1 << (mmu_port & 0x3f);
        } else {
            fval &= ~(1 << (mmu_port & 0x3f));
        }
        soc_reg_field_set(unit, TOQ_MC_CFG1r, &rval, field, fval);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, TOQ_MC_CFG1r, REG_PORT_ANY, 0, rval));

        /* write 0 to Q_NOT_EMPTY field of sister entry locations in MMU_MCQDBx */
        if (speed < 30000) {
            int base;
            int cosq;
            int num;
            mmu_mcqdb0_entry_t mcqdb0_entry;
            mmu_mcqdb1_entry_t mcqdb1_entry;
            base = si->port_cosq_base[port];
            num = si->port_num_cosq[port];
            for (index = 0; index < num; index++) {
                if (pipe == 0) {
                    cosq = base + 360 + index;
                    memset(&mcqdb0_entry, 0, sizeof(mcqdb0_entry));
                    SOC_IF_ERROR_RETURN
                        (READ_MMU_MCQDB0m(unit, MEM_BLOCK_ANY, cosq, &mcqdb0_entry));
                    soc_MMU_MCQDB0m_field32_set(unit, &mcqdb0_entry, Q_NOT_EMPTYf, 0);
                    SOC_IF_ERROR_RETURN
                        (WRITE_MMU_MCQDB0m(unit, MEM_BLOCK_ALL, cosq, &mcqdb0_entry));
                } else {
                    cosq = base - 568 + 360 + index;
                    memset(&mcqdb1_entry, 0, sizeof(mcqdb1_entry));
                    SOC_IF_ERROR_RETURN
                        (READ_MMU_MCQDB1m(unit, MEM_BLOCK_ANY, cosq, &mcqdb1_entry));
                    soc_MMU_MCQDB1m_field32_set(unit, &mcqdb1_entry, Q_NOT_EMPTYf, 0);
                    SOC_IF_ERROR_RETURN
                        (WRITE_MMU_MCQDB1m(unit, MEM_BLOCK_ALL, cosq, &mcqdb1_entry));
                }
            }
        }
    }
    
    if (SOC_PBMP_MEMBER(si->eq_pbm, port)) {
        SOC_IF_ERROR_RETURN(_soc_trident2_mc_toq_cfg(unit, port,
                    (speed >= 40000) ? TRUE : FALSE));
    }

    /* Update cut through credit threshold */
    if (speed > 42000){
        asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,100G);
        asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,100G);
    } else if (speed > 21000){
        asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,40G);
        asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,40G);
    } else if (speed > 11000) {
        asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,20G);
        asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,20G);
    } else {
        asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,10G);
        asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,10G);
    }
    reg = asf_credit_thresh_lo_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_lo);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));
    reg = asf_credit_thresh_hi_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_hi);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));

    SOC_IF_ERROR_RETURN(soc_td2_port_asf_speed_set(unit, port, speed));

    /* Update oversubscription buffer manager (OBM) threshold */
    if (rev_id >= BCM56850_A2_REV_ID) {
        obm_inst = si->port_group[port] | SOC_REG_ADDR_INSTANCE_MASK;

        xlp = 0;
        index = -1;
        for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
            block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port, i);
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_PGW_CL) {
                xlp = SOC_PORT_IDX_BINDEX(unit, phy_port, i) /
                    _TD2_PORTS_PER_XLP;
                index = SOC_PORT_IDX_BINDEX(unit, phy_port, i) %
                    _TD2_PORTS_PER_XLP;
                break;
            }
        }

        reg = pgw_obm_threshold_regs[xlp];
        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index, &rval64));


        if (SOC_IS_TRIDENT2PLUS(unit)) {
            if (soc_reg64_field32_get(unit, reg, rval64, FLOW_CTRL_XOFFf) !=
                soc_reg64_field32_get(unit, reg, rval64, FLOW_CTRL_XONf)) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            soc_td2p_set_obm_registers (unit, reg, speed, index, 
                    obm_inst, 1);
#endif
            }
        } else {
            _soc_trident2_quad_bandwidth_calculate
                (unit, si->port_group[port] / _TD2_PGWS_PER_QUAD,
                 &max_quad_core_bandwidth, &quad_linerate_bandwidth,
                 &quad_oversub_bandwidth);
            quad_oversub_core_bandwidth =
                max_quad_core_bandwidth - quad_linerate_bandwidth;

            if (speed == 42000 && si->port_speed_max[port] > 20000) {
                obm_setting_idx = 3; /* entry 3 in the lookup table */
                xon_threshold_offset = 24; /* xon = xoff - 24 */

            } else if (speed > 20000 && si->port_speed_max[port] > 20000) {
                obm_setting_idx = 2; /* entry 2 in the lookup table */
                xon_threshold_offset = 24; /* xon = xoff - 24 */
            } else if (speed > 10000 && si->port_speed_max[port] > 10000) {
                obm_setting_idx = 1; /* entry 1 in the lookup table */
                xon_threshold_offset = 12; /* xon = xoff - 12 */
            } else {
                obm_setting_idx = 0; /* entry 0 in the lookup table */
                xon_threshold_offset = 6; /* xon = xoff - 6 */
            }

            if (lossless) {
                if (quad_oversub_bandwidth * 2 >
                    quad_oversub_core_bandwidth * 3) {
                    /* oversub ratio greater than 1.5 (3/2) */
                    oversub_ratio_idx = 2;
                } else if (quad_oversub_bandwidth * 3 >
                    quad_oversub_core_bandwidth * 4) {
                    /* oversub ratio greater than 1.33 (4/3) */
                    oversub_ratio_idx = 1;
                } else {
                    oversub_ratio_idx = 0;
                }

                if (speed == 42000) {
                    /* oversub ratio equal to 1.33 (4/3) */
                    xoff_threshold = 632;
                } else {
                    xoff_threshold = obm_settings[obm_setting_idx].
                        xoff_threshold[oversub_ratio_idx];
                }

                xon_threshold = xoff_threshold - xon_threshold_offset;
                min_threshold = xon_threshold + 3;
            } else {
                xoff_threshold = 1023;
                xon_threshold = 1023;
                min_threshold = obm_settings[obm_setting_idx].
                    max_threshold;
            }

            soc_reg64_field32_set(unit, reg, &rval64,
                                  MIN_THRESHOLDf, min_threshold);
            soc_reg64_field32_set
                (unit, reg, &rval64, MAX_THRESHOLDf,
                 obm_settings[obm_setting_idx].max_threshold);
            soc_reg64_field32_set(unit, reg, &rval64,
                                  FLOW_CTRL_XONf, xon_threshold);
            soc_reg64_field32_set(unit, reg, &rval64,
                                  FLOW_CTRL_XOFFf, xoff_threshold);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, obm_inst, index, rval64));
        }

    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            SOC_IF_ERROR_RETURN(soc_td2p_mmu_delay_insertion_set (unit,
                        port, speed));
        }
#endif

    return SOC_E_NONE;
}


STATIC int
_soc_td2_thdo_hw_set(int unit, soc_port_t port, int enable)
{
    uint64 rval64, rval64_tmp;
    int mmu_port, phy_port, i;
    soc_info_t *si;
    soc_reg_t reg_tmp;
    soc_reg_t reg[3][2] = {
        {
            THDU_OUTPUT_PORT_RX_ENABLE0_64r,
            THDU_OUTPUT_PORT_RX_ENABLE1_64r
        },
        {
            MMU_THDM_DB_PORTSP_RX_ENABLE0_64r,
            MMU_THDM_DB_PORTSP_RX_ENABLE1_64r
        },
        {
            MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r,
            MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r
        }
    };

    si = &SOC_INFO(unit);

    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];


    for (i = 0; i < 3; i++) {
        COMPILER_64_ZERO(rval64);
        COMPILER_64_ZERO(rval64_tmp);
        reg_tmp = SOC_TD2_PREG(unit, port, reg[i][0], reg[i][1]);
        
        SOC_IF_ERROR_RETURN(
            soc_reg_get(unit, reg_tmp, REG_PORT_ANY, 0, &rval64));

        mmu_port &= 0x3f;
        if (mmu_port < 32) {
            COMPILER_64_SET(rval64_tmp, 0, 1 << mmu_port);
        } else {
            COMPILER_64_SET(rval64_tmp, 1 << (mmu_port - 32), 0);
        }

        if (enable) {
            COMPILER_64_OR(rval64, rval64_tmp);
        } else {
            COMPILER_64_NOT(rval64_tmp);
            COMPILER_64_AND(rval64, rval64_tmp);
        }

        SOC_IF_ERROR_RETURN(
            soc_reg_set(unit, reg_tmp, REG_PORT_ANY, 0, rval64));
    }
        
    return SOC_E_NONE;    
}


/*
 * Function:
 *      _soc_td2_port_thdo_rx_enable_set
 * Purpose:
 *     enable/disable  the traffic to the port according to
 *     different callers.
 *  the traffic to the port can be enabled only if all of the callers
 *  are to enable it.
 * Parameters:
 *     unit                - (IN) unit number
 *     port                - (IN) local port
 *     enable              - (IN) enable/disable the traffic to the port.
 *     flag                - (IN) different callers.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_soc_td2_port_thdo_rx_enable_set(int unit, soc_port_t port, 
                                 int enable, uint8 flag)
{
    int   rv = SOC_E_NONE;
    uint8 *thdo_drop_bmp;
    _soc_td2_mmu_traffic_ctrl_t *mmu_traffic_ctrl;

    FWD_CTRL_LOCK(unit);
    
    mmu_traffic_ctrl = _soc_td2_mmu_traffic_ctrl[unit];
    if (mmu_traffic_ctrl ==  NULL) {
        FWD_CTRL_UNLOCK(unit);
        return SOC_E_INIT;
    }
    thdo_drop_bmp = 
        &(mmu_traffic_ctrl->thdo_drop_bmp[port]);
    
    if (!enable) { 
        if (*thdo_drop_bmp & flag) {
            FWD_CTRL_UNLOCK(unit);
            return rv;
        }
        
        if (*thdo_drop_bmp == 0) {
            rv = _soc_td2_thdo_hw_set(unit, port, enable);
            if (SOC_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Clear the registers fail.")));
                FWD_CTRL_UNLOCK(unit);
                return rv;
            }
        }

        *thdo_drop_bmp |= flag;
        
        FWD_CTRL_UNLOCK(unit);
        return rv;
    } else {
        if (*thdo_drop_bmp != flag) {
            /*other callers are in thdo drop*/
            *thdo_drop_bmp &= ~flag;
            FWD_CTRL_UNLOCK(unit);
            return rv;
        }

        /*Ok, only self is in thdo drop, enbable it*/
        rv = _soc_td2_thdo_hw_set(unit, port, enable);
        if (SOC_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Set the registers fail.")));
            FWD_CTRL_UNLOCK(unit);
            return rv;
        }

        *thdo_drop_bmp &= ~flag;

        FWD_CTRL_UNLOCK(unit);
        return rv;
    }

    FWD_CTRL_UNLOCK(unit);
    return rv;
}


int
soc_td2_port_traffic_egr_enable_set(int unit, soc_port_t port,
                               int enable)
{
    return _soc_td2_port_thdo_rx_enable_set(unit, port, enable, 
                                            COSQ_SCHED_SET_CTRL);
}

int
soc_td2_port_mmu_tx_enable_set(int unit, soc_port_t port,
                               int enable)
{
    return _soc_td2_port_thdo_rx_enable_set(unit, port, enable, 
                                           MMU_TRAFFIC_EN_CTRL); 
}


int
soc_trident2_port_thdo_rx_enable_set(int unit, soc_port_t port, 
                                     int enable)
{
    return _soc_td2_port_thdo_rx_enable_set(unit, port, enable, 
                                            MAC_ENABLE_SET_CTRL);
}

#if defined(SER_TR_TEST_SUPPORT)

#define MAX_HW_TCAMS 20
typedef struct ser_td2_skipped_mem_s {
    soc_mem_t mem;
    soc_acc_type_t acc_type;
} ser_td2_skipped_mem_t;

const ser_td2_skipped_mem_t td2_skipped_mems[] = {
    {FP_METER_TABLEm, _SOC_ACC_TYPE_PIPE_Y},
    {ING_L3_NEXT_HOPm, _SOC_ACC_TYPE_PIPE_Y},
    {L2MCm, _SOC_ACC_TYPE_PIPE_Y},
    {L3_IPMCm, _SOC_ACC_TYPE_PIPE_Y},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_Y},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_Y},
    {L2_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2Xm, _SOC_ACC_TYPE_PIPE_Y},
    {INVALIDm}
};

#ifdef BCM_TRIDENT2PLUS_SUPPORT
const ser_td2_skipped_mem_t td2p_skipped_mems[] = {
    {FP_METER_TABLEm, _SOC_ACC_TYPE_PIPE_Y},
    {L2MCm, _SOC_ACC_TYPE_PIPE_Y},
    {L3_IPMCm, _SOC_ACC_TYPE_PIPE_Y},
    {L2Xm, _SOC_ACC_TYPE_PIPE_Y},
    {L2_ENTRY_ONLYm, _SOC_ACC_TYPE_PIPE_Y},
    {L2_BULK_MATCH_DATAm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_BULK_MATCH_MASKm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_BULK_REPLACE_DATAm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_BULK_REPLACE_MASKm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_MOD_FIFOm, _SOC_ACC_TYPE_PIPE_ANY},
    {ING_SNAT_ONLYm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_LEARN_INSERT_FAILUREm, _SOC_ACC_TYPE_PIPE_ANY},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_ANY},
    {LMEPm, _SOC_ACC_TYPE_PIPE_ANY},
    {LMEP_DAm, _SOC_ACC_TYPE_PIPE_ANY},
    {MAID_REDUCTIONm, _SOC_ACC_TYPE_PIPE_ANY},
    {MA_INDEXm, _SOC_ACC_TYPE_PIPE_ANY},
    {MA_STATEm, _SOC_ACC_TYPE_PIPE_ANY},
    {RMEPm, _SOC_ACC_TYPE_PIPE_ANY},
    {MPLS_ENTROPY_LABEL_DATAm, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_ALPM_ECCm, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_ALPM_IPV4m, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_ALPM_IPV4_1m, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_ALPM_IPV6_128m, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_ALPM_IPV6_64m, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_ALPM_IPV6_64_1m, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_ALPM_RAWm, _SOC_ACC_TYPE_PIPE_ANY},
    {INVALIDm}
};
#endif

const soc_ser_overlay_test_t soc_ser_td2_overlay_mems[] = {

    {MODPORT_MAP_M0m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},
    {MODPORT_MAP_M1m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},
    {MODPORT_MAP_M2m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},
    {MODPORT_MAP_M3m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},

    {MODPORT_MAP_M0m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},
    {MODPORT_MAP_M1m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},
    {MODPORT_MAP_M2m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},
    {MODPORT_MAP_M3m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},

    {L3_ENTRY_IPV4_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},
    {L3_ENTRY_IPV4_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},
    {L3_ENTRY_IPV6_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},
    {L3_ENTRY_IPV6_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},

    {L3_ENTRY_IPV4_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_IPV4_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_IPV6_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_IPV6_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},

    {EGR_IP_TUNNEL_IPV6m, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_X},
    {EGR_IP_TUNNEL_MPLSm, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_X},
    {EGR_DVP_ATTRIBUTE_1m, EGR_EL3_ECC_PARITY_CONTROLr,
     EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm,
     _SOC_ACC_TYPE_PIPE_X},
     {EGR_IP_TUNNEL_IPV6m, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_Y},
    {EGR_IP_TUNNEL_MPLSm, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_Y},
    {EGR_DVP_ATTRIBUTE_1m, EGR_EL3_ECC_PARITY_CONTROLr,
     EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm,
     _SOC_ACC_TYPE_PIPE_Y},
    {INVALIDm}
};


static soc_mem_t _soc_td2_alpm_sram_list[] = {
    L3_DEFIP_ALPM_IPV4m,
    L3_DEFIP_ALPM_IPV4_1m,
    L3_DEFIP_ALPM_IPV6_64m,
    L3_DEFIP_ALPM_IPV6_64_1m,
    L3_DEFIP_ALPM_IPV6_128m,
    INVALIDm
};

STATIC int
_soc_trident2_ser_mem_is_hw_cached (int unit, soc_mem_t mem)
{
    switch (mem) {
    case L3_DEFIP_ALPM_RAWm:
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    case L3_DEFIP_ALPM_ECCm:
    case L2_ENTRY_LPm:
    case L3_ENTRY_LPm:
    case VLAN_XLATE_LPm:
    case EGR_VLAN_XLATE_LPm:
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    case L3_DEFIP_AUX_TABLEm:
    case L3_DEFIP_PAIR_128m:
    case L3_DEFIPm:
    case L3_DEFIP_128_DATA_ONLYm:
    case L3_DEFIP_PAIR_128_DATA_ONLYm:
    case L3_DEFIP_DATA_ONLYm:
        return 1;
    default:
        return 0;
    }
}

STATIC soc_acc_type_t
_soc_trident2_pipe_to_acc_type(int pipe)
{
    soc_acc_type_t rv;
    switch (pipe) {
        case -1:
        case 0:
            rv = _SOC_ACC_TYPE_PIPE_X;
            break;
        case 1:
            rv = _SOC_ACC_TYPE_PIPE_Y;
            break;
        default:
            rv =_SOC_ACC_TYPE_PIPE_ALL;
    };
    return rv;
}


STATIC int
_soc_trident2_ser_test_skip_check (int unit, soc_mem_t mem,
                                   soc_acc_type_t acc_type)
{
    int i;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        for (i = 0; td2p_skipped_mems[i].mem != INVALIDm; i++) {
            if ((td2p_skipped_mems[i].mem == mem) &&
                 ((td2p_skipped_mems[i].acc_type == acc_type) || 
                  (td2p_skipped_mems[i].acc_type == _SOC_ACC_TYPE_PIPE_ANY))) {
                return 1;
            }
        }
    } else
#endif
    {
        for (i = 0; td2_skipped_mems[i].mem != INVALIDm; i++) {
            if ((td2_skipped_mems[i].mem == mem) &&
                (td2_skipped_mems[i].acc_type == acc_type)) {
                return 1;
            }
        }
    }
    return 0;
}

STATIC soc_error_t
_soc_trident2_ipep_ser_mem_info_get (int unit, soc_mem_t mem,
                                     void** ser_mem_info)
{
    int i, j;
    _soc_td2_fifo_ser_info_t *fifo_parity = NULL;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    _soc_mem_ser_en_info_t *ipep_fifo_parity = NULL;
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        /* Search for mems listed in:
         * _soc_bcm56860_a0_ip_mem_ser_info,
         * _soc_bcm56860_a0_ep_mem_ser_info */
        for (i = 0; _soc_td2p_ser_block_info[i].blocktype != 0; i++) {
            if ((_soc_td2p_ser_block_info[i].type == _SOC_TD2P_SER_TYPE_MEM) &&
                ((_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_IPIPE) ||
                 (_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_EPIPE))) {
                ipep_fifo_parity = _soc_td2p_ser_block_info[i].info;
                for (j = 0; ipep_fifo_parity[j].mem != INVALIDm; j++) {
                    if (ipep_fifo_parity[j].mem == mem) {
                        *ser_mem_info = &ipep_fifo_parity[j];
                        return SOC_E_NONE;
                    }
                }
            }
        }
    } else
#endif
    {
        for (i = 0; _soc_td2_ser_block_info[i].blocktype != 0; i++) {
            fifo_parity = _soc_td2_ser_block_info[i].info;
            for (j = 0; fifo_parity[j].enable_reg != INVALIDr;j++) {
                if (fifo_parity[j].mem != INVALIDm && fifo_parity[j].mem == mem) {
                    *ser_mem_info = &fifo_parity[j];
                    return SOC_E_NONE;
                }
            }
        }
    }
    return SOC_E_NOT_FOUND;
}

STATIC 
soc_error_t
_soc_trident2_overlay_ser_mem_info_get (int unit, soc_mem_t mem,
                                        int * index)
{
    int i;
    for (i = 0; soc_ser_td2_overlay_mems[i].mem != INVALIDm; i++) {
        if (soc_ser_td2_overlay_mems[i].mem == mem) {
            *index = i;
            return SOC_E_NONE;
        }
    }
    return SOC_E_NOT_FOUND;
}

STATIC 
soc_error_t
_soc_trident2_tcam_ser_mem_info_get (int unit, soc_mem_t mem,
                                     int * index_p)
{
    int i;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    
    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        if (tcams[i].mem == mem) {
            *index_p = i;
            return SOC_E_NONE;
        }
    }
    return SOC_E_NOT_FOUND;
}

STATIC 
soc_error_t
_soc_trident2_sram_ser_mem_info_get (int unit, soc_mem_t mem,
                                     soc_mem_t ** mem_info)
{
    int i;
    for (i = 0; _soc_td2_alpm_sram_list[i] != INVALIDm; i++) {
        if (_soc_td2_alpm_sram_list[i] == mem) {
            *mem_info = &_soc_td2_alpm_sram_list[i];
            return SOC_E_NONE;
        }
    }
    return SOC_E_NOT_FOUND;
}

/*
 * Function:
 *      soc_td2_ser_error_injection_support
 * Purpose:
 *      Checks if a memory is supported by error injection interface
 *
 * Parameters:
 *      unit        - (IN) Device Number
 *      memory      - (IN) Test data required for SER test
 *      pipe        - (IN) How many indices to test for each memory
 *
 * Returns:
 *  SOC_E_NONE if memory / reg is supported, SOC_E_UNAVAIL if unsupported
 *
 */
soc_error_t
soc_td2_ser_error_injection_support (int unit, soc_mem_t mem,
                                     int pipe)
{
    int rv = SOC_E_UNAVAIL;
    void * ser_mem_info = NULL;
    int  tcam_idx = 0;
    int  overlay_mem_idx = 0;
    soc_mem_t * sram_mem_info = NULL;

    
    soc_acc_type_t soc_acc_type_target = _soc_trident2_pipe_to_acc_type(pipe);
    
    /* Check if memory is listed in skipped mems structure */
    if (_soc_trident2_ser_test_skip_check(unit, mem, soc_acc_type_target)) {
        return rv;
    }

    rv = _soc_trident2_ipep_ser_mem_info_get(unit, mem, &ser_mem_info);
    if (rv == SOC_E_NONE) {
        return rv;
    }
    
    rv = _soc_trident2_tcam_ser_mem_info_get(unit, mem, &tcam_idx);
    if (rv == SOC_E_NONE) {
        return rv;
    }
    
    if(!SOC_IS_TRIDENT2PLUS(unit)) {
        rv = _soc_trident2_overlay_ser_mem_info_get(unit, mem, &overlay_mem_idx);
        if (rv == SOC_E_NONE) {
            return rv;   
        }
        rv = _soc_trident2_sram_ser_mem_info_get(unit, mem, &sram_mem_info);
        if (rv == SOC_E_NONE) {
            return rv;   
        }
    }
    
    return rv;
}

/*
 * Function:
 *      _soc_trident2_perform_ser_test
 * Purpose:
 *      Performs test operations common to TCAM and FIFO memory tests before
 *      invoking common SER test.
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_data   - (IN) Test data required for SER test
 *      test_type   - (IN) How many indices to test for each memory
 *      mem_failed  - (OUT) Incremented when memories fail the test.
 * Returns:
 *  SOC_E_NONE if test passes, an error otherwise (multiple types of errors are
 *      possible.)
 */
soc_error_t
_soc_trident2_perform_ser_test(int unit, ser_test_data_t *test_data,
                                   _soc_ser_test_t test_type,
                                   int *mem_skipped, int *mem_failed)
{
    int skip_mem = FALSE;
    soc_error_t rv = SOC_E_NONE;
    
    if (_soc_trident2_ser_test_skip_check(unit, test_data->mem, test_data->acc_type)) {
        skip_mem = TRUE;
    }
    
    if (!skip_mem) {
        rv = ser_test_mem(unit, 0, test_data, test_type, mem_failed);
    } else {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Memory %s skipped due to known issues.\n"),
                     SOC_MEM_NAME(unit,test_data->mem)));
        (*mem_skipped)++;
    }
    return rv;
}

/*
 * Function:
 *      soc_td2_ser_tcam_test
 * Purpose:
 *      Tests that SER is working for fifo and SRAM memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) How many indices to test for each memory
 * Returns:
 *  the number of tests which are failed
 */
int
soc_td2_ser_tcam_test (int unit, _soc_ser_test_t test_type) {
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    ser_test_data_t test_data;
    int mem_failed = 0, mem_tests = 0, mem_skipped = 0;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    int i;
    soc_acc_type_t acc_type;
    soc_field_t test_field = VALIDf;
    
    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        mem_tests++;
        if ( i >= MAX_HW_TCAMS) {
            mem_skipped++;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "Memory %s skipped due to lack of test mechanism \
                                    for Software-protected TCAMS.\n"),
                         SOC_MEM_NAME(unit,test_data.mem)));
            continue;
        }
        if (tcams[i].ser_flags & _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y) {
            acc_type = _SOC_ACC_TYPE_PIPE_Y;
        } else {
            acc_type = _SOC_ACC_TYPE_PIPE_X;
        }
        
        if (tcams[i].mem == L3_DEFIPm) {
            test_field = VALID0f;
        } else if (tcams[i].mem == L3_DEFIP_PAIR_128m) {
            test_field = VALID0_LWRf;
        } else {
            test_field = VALIDf;
        }
        
        soc_ser_create_test_data(unit, tmp_entry, field_data, SER_RANGE_ENABLEr,
                                 i, INVALIDf, tcams[i].mem, test_field,
                                 MEM_BLOCK_ANY, REG_PORT_ANY, acc_type, 0,
                                 &test_data);
        _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                       &mem_skipped, &mem_failed);
    }
    LOG_CLI((BSL_META_U(unit,
                        "\nTCAM memories tested on unit %d: %d\n"), unit, mem_tests));
    LOG_CLI((BSL_META_U(unit,
                        "TCAM tests passed:\t%d\n"),
             mem_tests - mem_failed - mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "TCAM tests skipped:\t%d (use verbose option to see "
                        "skipped memories)\n"),
             mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "TCAM tests failed:\t%d\n\n"), mem_failed));
    return mem_failed;
}

/*
 * Function:
 *      soc_td2_ser_hardware_test
 * Purpose:
 *      Tests that SER is working for fio and SRAM memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) How many indices to test for each memory
 * Returns:
 *  the number of tests which are failed
 */
STATIC int
soc_td2_ser_hardware_test (int unit, _soc_ser_test_t test_type) {
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    ser_test_data_t test_data;
    int mem_failed = 0, mem_tests = 0, mem_skipped = 0;
    _soc_td2_fifo_ser_info_t *fifo_parity = _soc_td2_ip_ser_info;
    int i, j;
    soc_acc_type_t acc_type;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int k, num_instance_to_test = 0;
    _soc_mem_ser_en_info_t *ipep_fifo_parity = NULL;
    soc_acc_type_t mem_acc_type, acc_type_list[SOC_MAX_NUM_PIPES];
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        for (i = 0; _soc_td2p_ser_block_info[i].blocktype != 0; i++) {
            if ((_soc_td2p_ser_block_info[i].type == _SOC_TD2P_SER_TYPE_MEM) &&
                ((_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_IPIPE) ||
                 (_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_EPIPE))) {
                ipep_fifo_parity = _soc_td2p_ser_block_info[i].info;
                for (j = 0; ipep_fifo_parity[j].mem != INVALIDm; j++) {
                    mem_acc_type = SOC_MEM_ACC_TYPE(unit, ipep_fifo_parity[j].mem);
                    sal_memset(acc_type_list, 0, sizeof(acc_type_list));
                    switch (mem_acc_type) {
                    case _SOC_ACC_TYPE_PIPE_BCAST:
                    case _SOC_ACC_TYPE_PIPE_SBS:
                        num_instance_to_test = NUM_PIPE(unit);
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_Y;
                        acc_type_list[1] = _SOC_ACC_TYPE_PIPE_ANY;
                        break;
                    case _SOC_ACC_TYPE_PIPE_Y:
                        num_instance_to_test = 1;
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_Y;
                        break;
                    case _SOC_ACC_TYPE_PIPE_X:
                        num_instance_to_test = 1;
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_X;
                        break;
                    default:
                        num_instance_to_test = 1;
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_ANY;
                        break;
                    }
                    mem_tests += num_instance_to_test;
                    for (k = 0; k < num_instance_to_test; k++) {
                        test_data.test_field = EVEN_PARITYf;
                        acc_type = acc_type_list[k];
                        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                                 ipep_fifo_parity[j].en_reg,
                                                 SOC_INVALID_TCAM_PARITY_BIT,
                                                 ipep_fifo_parity[j].en_fld,
                                                 ipep_fifo_parity[j].mem,
                                                 test_data.test_field, 
                                                 MEM_BLOCK_ANY,
                                                 REG_PORT_ANY, acc_type, 0, 
                                                 &test_data);
                        if ((test_data.mem_info == NULL) || 
                        	  (!(soc_mem_index_count(unit, ipep_fifo_parity[j].mem) > 0))) {
                            mem_skipped++;
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "Memory %s skipped due to lack of"
                                                " mem_info structure or being disabled.\n"),
                                     SOC_MEM_NAME(unit,test_data.mem)));
                            continue;
                        }
                        _soc_trident2_perform_ser_test(unit, &test_data,
                                                       test_type, &mem_skipped,
                                                       &mem_failed);
                    }
                }
            }
        }
    } else
#endif    
    {
        for (i = 0; _soc_td2_ser_block_info[i].blocktype != 0; i++) {
            fifo_parity = _soc_td2_ser_block_info[i].info;
            for (j = 0; fifo_parity[j].enable_reg != INVALIDr; j++) {
                if (fifo_parity[j].mem != INVALIDm) {
                    mem_tests += 2;
                    test_data.test_field = EVEN_PARITYf;
                    acc_type = _SOC_ACC_TYPE_PIPE_Y;
                    soc_ser_create_test_data(unit, tmp_entry, field_data,
                                             fifo_parity[j].enable_reg,
                                             SOC_INVALID_TCAM_PARITY_BIT,
                                             fifo_parity[j].enable_field,
                                             fifo_parity[j].mem,
                                             test_data.test_field, MEM_BLOCK_ANY,
                                             REG_PORT_ANY, acc_type, 0, &test_data);
                    if ((test_data.mem_info == NULL) || 
                        (!(soc_mem_index_count(unit, fifo_parity[j].mem) > 0))) {
                        mem_skipped += 2;
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "Memory %s skipped due to lack of"
                                                " mem_info structure.\n"),
                                     SOC_MEM_NAME(unit,test_data.mem)));
                        continue;
                    }
                    _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                                   &mem_skipped, &mem_failed);
                    test_data.acc_type = _SOC_ACC_TYPE_PIPE_ANY;
                    _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                                   &mem_skipped, &mem_failed);
                }
            }
        }
        /* Perform SER test for SRAM memories */
        for (i = 0; _soc_td2_alpm_sram_list[i] != INVALIDm; i++) {
            soc_ser_create_test_data(unit, tmp_entry, field_data,
                                     ILPM_SER_CONTROLr,
                                     SOC_INVALID_TCAM_PARITY_BIT,
                                     L3_DEFIP_ALPM_PARITY_ENf,
                                     _soc_td2_alpm_sram_list[i],
                                     EVEN_PARITYf, MEM_BLOCK_ANY,
                                     REG_PORT_ANY, _SOC_ACC_TYPE_PIPE_Y, 0,
                                     &test_data);
            if ((test_data.mem_info == NULL) || 
                (!(soc_mem_index_count(unit, _soc_td2_alpm_sram_list[i]) > 0))) {
                mem_skipped += 2;
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "Memory %s skipped due to lack of"
                                        " mem_info structure.\n"),
                             SOC_MEM_NAME(unit,test_data.mem)));
                continue;
            }
            _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                           &mem_skipped, &mem_failed);
            test_data.acc_type = _SOC_ACC_TYPE_PIPE_X;
            _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                           &mem_skipped, &mem_failed);
            mem_tests += 2;
        }
    }
    
    LOG_CLI((BSL_META_U(unit,
                        "\nH/W memories tested on unit %d: %d\n"), unit, mem_tests));
    LOG_CLI((BSL_META_U(unit,
                        "H/W tests passed:\t%d\n"),
             mem_tests - mem_failed - mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "H/W tests skipped:\t%d (use verbose option to see "
                        "skipped memories)\n"),
             mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "H/W tests failed:\t%d\n\n"), mem_failed));
    return mem_failed;
}


/*
 * Function:
 *      soc_td2_ser_test
 * Purpose:
 *      Tests that SER is working for all supported memories.
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) How many indices to test for each memory
 * Returns:
 *  SOC_E_NONE if test passes, an error otherwise (multiple types of errors are
 *      possible.)
 */
soc_error_t
soc_td2_ser_test (int unit, _soc_ser_test_t test_type) {
    int errors = 0;
    /* Test for overlay memories */
    if (!SOC_IS_TRIDENT2PLUS(unit))
    {
        soc_ser_test_long_sleep = TRUE;
        errors += soc_td2_ser_test_overlay(unit, test_type);
        soc_ser_test_long_sleep = FALSE;
    }
    
    /* Test TCAM memories */
    errors += soc_td2_ser_tcam_test(unit, test_type);
    /* Test for FIFO memories */
    errors += soc_td2_ser_hardware_test(unit, test_type);

    if (errors == 0) {
        return SOC_E_NONE;
    } else {    
        LOG_CLI((BSL_META_U(unit,
                    "TR 144 test failed, failed cases:%d.\n"), errors));
        return SOC_E_FAIL;
    }
}

#define TR_MEM_NAME_SIZE_MAX    100

#ifdef SOC_MEM_NAME
#define TR_TEST_MEM_NAME_GET(_unit, _msg, _mem) do {                    \
        const char *_mem_name = SOC_MEM_NAME(_unit_, _mem);             \
        if (sal_strlen(_mem_name) < TR_MEM_NAME_SIZE_MAX) {             \
            sal_strcpy(_msg, _mem_name);                                \
        }                                                               \
    } while (0)
#else
#define TR_TEST_MEM_NAME_GET(_unit, _msg, _mem)
#endif

#define TR_TEST_MEM_PRINT(_unit, _msg, _mem) do {                       \
        sal_sprintf(_msg, "Mem ID: %d", _mem);                          \
        TR_TEST_MEM_NAME_GET(_unit, _msg, _mem);                        \
        LOG_CLI((BSL_META_U(_unit,                                      \
                            "Memory %s is valid, but not currently testable.\n"), \
                 _msg));                                                \
    } while (0)


/*
 * Function:
 *      soc_td2_ser_test_overlay
 * Purpose:
 *      performs a test of all overlay memories along with their base memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) how to test memories
 */
int
soc_td2_ser_test_overlay (int unit, _soc_ser_test_t test_type)
{
    int rv = 0;
    int numOverlays = COUNTOF(soc_ser_td2_overlay_mems) - 1;

    rv = soc_ser_test_overlays(unit, test_type, soc_ser_td2_overlay_mems,
                              NULL);

    if (rv >= 0) {
        LOG_CLI((BSL_META_U(unit,
                            " Overlay memories tested: \t %d\n"),
                 numOverlays));
        LOG_CLI((BSL_META_U(unit,
                            " Overlay memories passed: \t %d\n"),
                 numOverlays - rv));
        LOG_CLI((BSL_META_U(unit,
                            " Overlay memories failed: \t %d\n\n"),
                 rv));
    } else {
        LOG_INFO(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "Internal Error during overlay test.\n")));
    }
    return rv;
}


/*
 * Function:
 *      soc_ser_inject_or_test_mem
 * Purpose:
 *      Provide a common function for injecting errors and testing single
 *      single memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      index       - (IN) The index into which the error will be injected.
 *      test_type   - (IN) How many indices to test in the passes memory
 *      cmd         - (IN) TRUE if a command-line test is desired.
 * Returns:
 *      SOC_E_NONE if test passes, an error otherwise (multiple types of errors
 *      are possible.)
 */
soc_error_t
soc_ser_inject_or_test_mem (int unit, soc_mem_t mem, int pipe_target, int block,
                            int index, _soc_ser_test_t test_type,
                            int inject_only, int cmd, uint32 flags)
{
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    ser_test_data_t test_data;
    int tcam_idx = 0;
    void * ser_mem_info = NULL;
    int overlay_mem_idx = 0;
    soc_mem_t * sram_mem_info = NULL;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    int error_count = 0, skip_count = 0, found_mem = FALSE;
    char fail_message[TR_MEM_NAME_SIZE_MAX + 1];

    soc_error_t rv = SOC_E_NONE;
    soc_acc_type_t soc_acc_type_target = _soc_trident2_pipe_to_acc_type(pipe_target);
    soc_field_t test_field = INVALIDf;

    /* Search for TCAM memories */
    rv = _soc_trident2_tcam_ser_mem_info_get(unit, mem, &tcam_idx);
    if (rv == SOC_E_NONE) {
        if (tcams[tcam_idx].mem == L3_DEFIPm) {
            test_field = VALID0f;
        } else if (tcams[tcam_idx].mem == L3_DEFIP_PAIR_128m) {
            test_field = VALID0_LWRf;
        } else {
            test_field = VALIDf;
        }
        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                     SER_RANGE_ENABLEr, tcam_idx, INVALIDf, mem,
                                     test_field, block, REG_PORT_ANY,
                                     soc_acc_type_target, index, &test_data);
        found_mem = TRUE;
    }    

    if (!found_mem) {
        rv = _soc_trident2_ipep_ser_mem_info_get (unit, mem, &ser_mem_info);
        if (rv == SOC_E_NONE) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TRIDENT2PLUS(unit)) {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         ((_soc_mem_ser_en_info_t*)ser_mem_info)->en_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         ((_soc_mem_ser_en_info_t*)ser_mem_info)->en_fld,
                                         mem, EVEN_PARITYf, block,
                                         REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
                if (SOC_REG_IS_VALID(unit, ((_soc_mem_ser_en_info_t*)ser_mem_info)->ecc_1b_report_en_reg) &&
                    (INVALIDf != ((_soc_mem_ser_en_info_t*)ser_mem_info)->ecc_1b_report_en_fld)) {
                    flags |= SOC_INJECT_ERROR_2BIT_ECC;
                }
                if (ser_test_mem_index_remap(unit, &test_data)) {
                    flags |= SOC_INJECT_ERROR_2BIT_ECC;
                }
            } else
#endif
            {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         ((_soc_td2_fifo_ser_info_t*)ser_mem_info)->enable_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         ((_soc_td2_fifo_ser_info_t*)ser_mem_info)->enable_field,
                                         mem, EVEN_PARITYf, block,
                                         REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
            }
            found_mem = TRUE;
        }
    }

    if (!SOC_IS_TRIDENT2PLUS(unit)) {
        if (!found_mem) {
            rv = _soc_trident2_overlay_ser_mem_info_get(unit, mem, &overlay_mem_idx);
            if (rv == SOC_E_NONE) {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         soc_ser_td2_overlay_mems[overlay_mem_idx].parity_enable_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         soc_ser_td2_overlay_mems[overlay_mem_idx].parity_enable_field,
                                         soc_ser_td2_overlay_mems[overlay_mem_idx].mem, EVEN_PARITYf,
                                         block, REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
                found_mem = TRUE;
            }
        }
        if (!found_mem) {
            rv = _soc_trident2_sram_ser_mem_info_get(unit, mem, &sram_mem_info);
            if (rv == SOC_E_NONE) {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         ILPM_SER_CONTROLr,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         L3_DEFIP_ALPM_PARITY_ENf,
                                         mem, EVEN_PARITYf,
                                         block, REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
                found_mem = TRUE;
            }
        }
    }
    
    if (found_mem) {
        if ((pipe_target == _SOC_ACC_TYPE_PIPE_ANY) &&
            (!_soc_trident2_ser_mem_is_hw_cached(unit, test_data.mem))) {
            test_data.acc_type = SOC_MEM_ACC_TYPE(unit, test_data.mem);
        }
        if (inject_only) {
            if (_soc_trident2_ser_test_skip_check(unit, mem, test_data.acc_type)) {
                TR_TEST_MEM_PRINT(unit, fail_message, mem);
                return SOC_E_UNAVAIL;
            }
            /* Disable parity */
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
            /* Read the memory (required for successful injection) */
            SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
            /* Inject error */
            SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
            /* Enable parity */
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
        } else {
            if (cmd) {
                ser_test_cmd_generate(unit, &test_data);
            } else {
                rv = _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                                    &skip_count, &error_count);
                if (error_count == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "SER test PASSED for memory %s\n"),
                             test_data.mem_name));
                }
                if (skip_count !=0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Test skipped due to known issues with "
                                        "this memory.\n")));
                }
            }
        }
    } else {
        TR_TEST_MEM_PRINT(unit, fail_message, mem);
        rv = SOC_E_UNAVAIL;
    }
    return rv;
}
#undef TR_TEST_MEM_PRINT

/*
 * Function:
 *      soc_td2_ser_inject_error
 * Purpose:
 *      Injects an error into a single td2 memory
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      index       - (IN) The index into which the error will be injected.
 *      test_tcam   - (IN) If the memory is a TCAM, test the KEY/MASK portion,
 *                         not the DATA portion
 */
soc_error_t
soc_td2_ser_inject_error (int unit, uint32 flags, soc_mem_t mem,
                          int pipe_target, int block, int index)
{
    /* Check if memory needs to be skipped */
    if (ser_trident2_test_fun.injection_support) {
        SOC_IF_ERROR_RETURN(
            soc_td2_ser_error_injection_support(unit, mem, pipe_target));
    }

    return soc_ser_inject_or_test_mem(unit, mem, pipe_target, block, index,
                                      SER_SINGLE_INDEX, TRUE, FALSE, flags);
}

/*
 * Function:
 *      soc_td2_ser_test_mem
 * Purpose:
 *      Perform SER test on a single memory, or generate a test the user can
 *      enter by the command line.
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      test_type   - (IN) How many indices to test in the passes memory
 *      cmd         - (IN) TRUE if a command-line test is desired.
 * Returns:
 *      SOC_E_NONE if test passes, an error otherwise (multiple types of errors
 *      are possible.)
 */
soc_error_t
soc_td2_ser_test_mem(int unit, soc_mem_t mem, _soc_ser_test_t test_type,
                     int cmd)
{
    soc_acc_type_t mem_acc_type;
    soc_error_t rv = SOC_E_NONE;
    
    if ((!SOC_MEM_IS_VALID(unit, mem)) ||
    	  (!(soc_mem_index_count(unit, mem) > 0))) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return SOC_E_UNAVAIL;
    }
    mem_acc_type = SOC_MEM_ACC_TYPE(unit, mem);
    
    if (mem_acc_type == _SOC_ACC_TYPE_PIPE_BCAST ||
    	  mem_acc_type == _SOC_ACC_TYPE_PIPE_SBS) {
        /* Test X-pipe memory instance */
        rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_ANY,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
        /* Test Y-pipe memory instance */
        if (SOC_SUCCESS(rv)) {
            rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_Y_COMMON,
                                            MEM_BLOCK_ANY, 0, test_type,
                                            FALSE, cmd, FALSE);
        }
        
    } else if (mem_acc_type == _SOC_ACC_TYPE_PIPE_X) {
        /* Only X-pipe access is allowed */
        rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_X_COMMON,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
    } else if (mem_acc_type == _SOC_ACC_TYPE_PIPE_Y) {
        /* Only Y-pipe access is allowed */
        rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_Y_COMMON,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
    } else {
        rv = soc_ser_inject_or_test_mem(unit, mem, _SOC_ACC_TYPE_PIPE_ANY,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
    }
    return rv;
}
#endif /*defined(SER_TR_TEST_SUPPORT)*/

int
soc_td2_reg_cpu_write_control(int unit, int enable)
{
    uint32 intfo_dis = 0;

    if (enable) {
        /* Disable HW updates */
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          EG_SPf, 1);
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          ING_SPf, 1);
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          CONGST_STf, 1);
    }
    SOC_IF_ERROR_RETURN(WRITE_INTFO_HW_UPDATE_DISr(unit, intfo_dis));

    return SOC_E_NONE;
}

/*
 * Trident2 chip driver functions.
 */
soc_functions_t soc_trident2_drv_funs = {
    _soc_trident2_misc_init,
    _soc_trident2_mmu_init,
    _soc_trident2_age_timer_get,
    _soc_trident2_age_timer_max_get,
    _soc_trident2_age_timer_set,
    _soc_trident2_tsc_firmware_set
};

uint32* soc_td2_mmu_params_arr_get (uint16 dev_id, uint8 rev_id)
{
    return soc_mmu_pkt_buf_size_arr[_MMU_PKT_BUF_SIZE_12MB];
}

void
soc_cm_get_id_otp(int unit, uint16 *dev_id, uint8 *rev_id)
{

    soc_cm_get_id(unit, dev_id, rev_id);

}

int soc_td2_is_blk_valid(int unit, int blk)
{
    int valid = 1;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int blktype;
    int instance;

    if (SOC_IS_TRIDENT2PLUS(unit)) {
        blktype = SOC_BLOCK_INFO(unit, blk).type;
        if ( blktype == SOC_BLK_PGW_CL ) {
            if (!soc_td2p_if_full_chip(unit)) {
                instance = SOC_BLOCK_INFO(unit, blk).number;
                if ( instance >= _TD2_PGWS_PER_PIPE ) {
                    valid = 0;
                    LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                               (BSL_META_U(unit,
                                           "Unit %d half chip config block is not valid %d\n"),
                                                unit, valid));
                }
            }
        }
    }
#endif

    return valid;
}

#endif /* BCM_TRIDENT2_SUPPORT */
