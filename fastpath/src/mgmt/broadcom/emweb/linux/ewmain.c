/*
 *
 * Product: EmWeb
 * Release: R6_2_0
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION OF VIRATA CORPORATION
 * THE EMWEB SOFTWARE ARCHITECTURE IS PATENTED (US PATENT #5,973,696)
 * AND OTHER US AND INTERNATIONAL PATENTS PENDING.
 * 'EMWEB' AND 'EMSTACK' ARE TRADEMARKS OF VIRATA CORPORATION
 *
 * Notice to Users of this Software Product:
 *
 * This software product of Virata Corporation ("Virata"), 5 Clock Tower
 * Place, Suite 400, Maynard, MA  01754 (e-mail: info@virata.com) in
 * source and object code format embodies valuable intellectual property
 * including trade secrets, copyrights and patents which are the exclusive
 * proprietary property of Virata. Access, use, reproduction, modification
 * disclsoure and distribution are expressly prohibited unless authorized
 * in writing by Virata.  Under no circumstances may you copy this
 * software or distribute it to anyone else by any means whatsoever except in
 * strict accordance with a license agreement between Virata and your
 * company.  This software is also protected under patent, trademark and
 * copyright laws of the United States and foreign countries, as well as
 * under the license agreement, against any unauthorized copying, modification,
 * or distribution.
 * Please see your supervisor or manager regarding any questions that you may
 * have about your right to use this software product.  Thank you for your
 * cooperation.
 *
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Virata Corporation
 * All Rights Reserved
 *
 * Virata Corporation
 * 5 Clock Tower Place
 * Suite 400
 * Maynard, MA  01754
 *
 * Voice: +1 (978) 461-0888
 * Fax:   +1 (978) 461-2080
 *
 * http://www.emweb.com/
 *   support@agranat.com
 *     sales@agranat.com
 *
 * EmWeb reference port
 *
 * Usage:       ews hostname datafile
 */

#include <termios.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>

#include "l7_common.h"
#include "user_manager_exports.h"
#include "usmdb_sim_api.h"
#include "usmdb_sslt_api.h"
#include "usmdb_telnet_api.h"
#include "usmdb_unitmgr_api.h"
#include "commdefs.h"
#include "cliapi.h"
#include "osapi_support.h"
#include "cli_web_include.h"
#include "usmdb_user_mgmt_api.h"
#include "ewa_common.h"

#ifdef L7_MGMT_SECURITY_PACKAGE
#include "sshd_api.h"
#include "sslt_api.h"
#endif /* L7_MGMT_SECURITY_PACKAGE */
#include "sshd_exports.h"
#include "sslt_exports.h"

#ifdef L7_CAPTIVE_PORTAL_PACKAGE
#include "captive_portal_commdefs.h"
#include "captive_portal_defaultconfig.h"
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

#include "posix_config.h"
#include "ew_config.h"

/* Library definitions to declare inet_addr(). */
#ifdef L7_ORIGINAL_VENDOR_CODE
#if !defined(WIN32) && !defined(_WIN32_WCE)
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>
#endif
#endif

#ifdef EW_CONFIG_OPTION_UPNP
/* Needed to include configuration symbols, so other include files will
 * define the right things. */
  #include "ews_upnp.h"
#endif /* EW_CONFIG_OPTION_UPNP */

#ifdef EW_CONFIG_OPTION_SIGSETJMP
  #include <setjmp.h>
#endif


#include "ews_api.h"
#include "ew_db.h"
#include "ews.h"

#include "ewnet.h"
#include "ew_lib.h"

#define _EWMAIN_C_
#include "ewa_routines.h"

extern void timeOutGetSemaId( void );
extern void timeOutReturnSemaId( void );
extern int ewaFileDownloadGetProgressGlobal(void);
extern L7_int32 cliTxtCfgPoll (L7_int32);
extern int ewaTaskInit(void);
extern int use_connection_socket_select;
#define HTTP_WELL_KNOWN_PORT 80
#define L7_LOOPBACK_ADDR  0x7F000001 /* 127.0.0.1 */
#define L7_MAX_BIND_ERROR_RETRY 60

#ifdef EW_CONFIG_OPTION_UPNP

/* Posix implementation of the timer subsystem. */

  #include "ews_timer.h"
  #if !defined(_WIN32_WCE) && !defined(_WIN32)
    #include <time.h>
    #include <unistd.h>
  #endif

/* Timer functions used only by the select() loop here. */
static time_t ewaTimerNextTimeout(void);
static void ewaTimerCheck(void);

/* Start of the list of ewaTimerEvent structures that describe the outstanding
 * timer requests. */
static EwaTimerEvent *timerRequestListPtr = NULL;
/* Large positive value to be used as timeout if no events are pending. */
  #define EWA_TIMEOUT_NO_TIMER 0x7FFFFFFF

/* The system identification string used to make device UUIDs.
 * (Defined in main.c.) */
extern char ewaUPnPSystemIdString[50];

#endif /* EW_CONFIG_OPTION_UPNP */

#if defined (EW_CONFIG_OPTION_SSL_RSA)
/*
 * specify server certificate and matching key in private_key.h
 *
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * ATTENTION EMWEB SERVER USER:
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 * we are going to use self-signed certificate generated by RSA's utility program
 * sslc for AGRANAT TESTING/SHIPING ONLY.
 * You MUST create your own, secure certificate and edit private_key.pem
 * to include your own information.
 *
 */
  #include "private_key.h"
#endif /* EW_CONFIG_OPTION_SSL_RSA */

/* Define the special handle that discards all output. */
struct EwaNetHandle_s *ewaNetHandleSpecialDiscardObject = NULL;

extern L7_RC_t cliWebIsReady();

L7_uint32 cliWebGetSystemTelnetNumSessions(void);
L7_uint32 cliWebGetSystemTelnetNewSessions(void);

/* ****************************************************************
 * Internal Routine Declarations
 * **************************************************************** */
static
void ewaInitConnections( int maxConnections );

static
EwaNetHandle ewaNewConnection( SOCKET master_socket );

static
EwaNetHandle ewaNewSSHConnection(SOCKET master_socket);

#ifdef EW_CONFIG_OPTION_UPNP
EwaNetHandle ewaNetUdpOutStart(EwsContext context);

EwaStatus ewaNetUdpSendMsg ( EwaNetHandle net_handle );

static
EwaNetHandle ewaSsdpNewConnection( SOCKET master_socket,
                                   boolean isMulticastMsg,
                                   boolean doGetContext,
                                   EwsContext context);
static
void udpRecvData( EwaNetHandle connection );

static
EwaStatus fillUdpXmitBuffer( EwaNetHandle connection );

#endif /* EW_CONFIG_OPTION_UPNP */

static
void NetReceiveLoop( fd_set* fds );

#ifdef EW_CONFIG_OPTION_SCHED_FC
static
void NetTransmitPendingLoop( fd_set* fds );
#endif /* EW_CONFIG_OPTION_SCHED_FC */

static
void ChainPending( EwaNetHandle connection, EwaNetBuffer buffer );

static
EwaStatus TransmitPending( EwaNetHandle connection );

#ifdef EMWEB_USE_SIGNALS
static
void sig_handler( int sig );           /* signal handler */
#endif

static void cleanup( void );         /* shutdown emweb and exit */

void ewaConnectionFinish(EwaNetHandle connection);

#if defined (EW_CONFIG_OPTION_SSL_RSA)
static
boolean sslConnectionInit ( EwaNetHandle net_handle );

static
EwaNetHandle ewaSSLNewConnection( SOCKET master_socket );

static
boolean sslInit(void);

static void doSSLRecvLoop(int s, EwaNetHandle connection, fd_set* fds );
#endif



/* if any options are turned on, call setupOptionSockets */
#if defined(EW_CONFIG_OPTION_UPNP) || defined(EW_CONFIG_OPTION_TELNET) || \
        defined(EW_CONFIG_OPTION_SSL_RSA)
static void setupOptionSockets(uint32 listenAddr,uint16 port);
#endif
/* ****************************************************************
 * Net Connection Handle Variables
 * **************************************************************** */
void *dbgConsoleContext = L7_NULLPTR;
static EwaNetHandle* Handle;    /* net_handles allocated at init time */
static uintf ConnectionsActive;
static uintf MaxConnections;
static L7_uint32 httpListenPort;
uintf ConnectionsActiveTelnet;   /* lvl7_P0006 */
uintf ConnectionsActiveSSH;   /* lvl7_P0006 */
char sockErr[256];

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)
    int     rcvBufLen = 4096;
    int     sndBufLen = 4096;
#endif


/* ****************************************************************
 * Buffer Pool Variables
 * **************************************************************** */

/* ****************************************************************
 * Main Loop Control Flag
 *
 * SlowShutdown - when set TRUE, server will stop accepting
 * new connections, and will exit when all existing connections
 * terminate.
 * **************************************************************** */
static boolean SlowShutdown = FALSE;

/* ****************************************************************
 * SMTP Mail Data
 * **************************************************************** */

#ifdef EW_CONFIG_OPTION_SMTP
/*
 * NOTE: If the EmWeb/Mail option is licensed, this example illustrates
 *       the APIs required to support it.  For more information about
 *       licensing, contact sales@agranat.com.
 *
 * For this example, we assume that the device is configured to send
 * mail to a single SMTP server.  There are three configuration parameters
 * that are needed as follows:
 */

static
uint32 SMTP_Ip = 0x7f000001;   /* IP address of SMTP mail gateway */

  #define SMTP_WELL_KNOWN_PORT 25
static
uint16 SMTP_Port = SMTP_WELL_KNOWN_PORT; /* TCP port of SMTP mail gateway */

static
char   SMTP_Domain[ EW_CONFIG_SMTP_DOMAIN_MAXLEN ] = "host.local";

#endif /* EW_CONFIG_OPTION_SMTP */

#ifdef EW_CONFIG_OPTION_TELNET
/*
 * NOTE: If the EmWeb/Telnet option is licensed, this example illustrates
 *       the APIs required to support it.  For more information about
 *       licensing, contact sales@agranat.com.
 */

  #define TELNET_WELL_KNOWN_PORT 23
static

  #ifndef TELNET_PORT
uint16 Telnet_Port = TELNET_WELL_KNOWN_PORT; /* TCP port of telnet server*/
  #else
uint16 Telnet_Port = TELNET_PORT;            /* TCP port of telnet server*/
  #endif

static uint16 SSH_Internal_Port = L7_SSHD_EMWEB_PORT;

#endif /* EW_CONFIG_OPTION_TELNET */

#ifdef EW_CONFIG_OPTION_SSL_RSA
/*
 * Support for Secure Socket Layer (SSL) implemented by RSA
 */

  #define SSL_port 443
#endif /* EW_CONFIG_OPTION_SSL_RSA */

#ifdef EW_CONFIG_OPTION_UPNP
/* the SSDP multicast address to listen to is 239.255.255.250.
   The port is 1900 */
  #define EWU_SSDP_MCAST_ADDR "239.255.255.250"
  #define EWU_SSDP_PORT 1900
#endif /* EW_CONFIG_OPTION_UPNP */

SOCKET http_s = 0; /* HTTP listening socket */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
SOCKET http6_s = 0; /* HTTP listening socket */
#endif

uint32 ewsBytesSent;        /* statistics */
uint32 ewsBytesRecv;
extern cliWebCfgData_t cliWebCfgData;

#ifdef EMWEB_SANITY
static boolean
isHandleTableInvalid(void)
{
  uintf count = 0;
  uintf i;

  for (i = 0; i < MaxConnections; i++)
  {
    if (NULL != Handle[i])
    {
      count++;
    }
  }

  return(count != ConnectionsActive);
}
#endif /* EMWEB_SANITY */

#ifdef L7_CAPTIVE_PORTAL_PACKAGE
/* ################################################################ */
/*                   CAPTIVE PORTAL SUPPORT                         */
/*                                                                  */
/* Add variables to identify a CP port (if configured) and add a    */
/* simple list (array of cpConn_t) used to track the CP connections.*/
/* CP connection control is as follows;                             */
/* - Added to list (if not full) when initially served (ewaUrlHook) */
/* - Deleted when the last socket connection closes (ewaNetHTTPEnd) */
/* ################################################################ */

static  int      cp_http_s = 0;      /* CP HTTP listening socket */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
static  int      cp_http6_s = 0;     /* CP HTTP ipv6 listening socket */
#endif
static  int      cp_http_port = FD_CP_HTTP_PORT; /* CP HTTP port */
static  int      cp_http_mode_config;/* CP HTTP user configured mode */
static  L7_BOOL  cp_http_active;     /* CP HTTP Active */

typedef struct
{
  L7_inet_addr_t remote;
} cpConn_t;

static cpConn_t cpConnList[FD_CP_WEB_DEFAULT_MAX_CONNECTIONS];

/*********************************************************************
* @purpose  Simple search/match for remote.
*
* @returns  L7_SUCCESS if add. L7_FAILURE if list is full
*
* @notes    Currently ipv4 only support
*
* @end
*********************************************************************/
L7_RC_t ewaCpConnListAnd(L7_inet_addr_t remote)
{
  L7_RC_t status = L7_FAILURE;
  L7_BOOL found = L7_FALSE;
  L7_int8 i;
  L7_int8 j = -1;

  for (i=0; (i<FD_CP_WEB_DEFAULT_MAX_CONNECTIONS); i++)
  {
    if (0==cpConnList[i].remote.addr.ipv4.s_addr)
    {
      if (-1==j)
      {
        j = i;
      }
    }
    if (cpConnList[i].remote.addr.ipv4.s_addr==remote.addr.ipv4.s_addr)
    {
      found = L7_TRUE;
      break;
    }
  }
  if (found)
  {
    status = L7_SUCCESS;
  }
  else if (-1!=j)
  {
    status = L7_SUCCESS;
    cpConnList[j].remote = remote;
  }
  return status;
}

/*********************************************************************
* @purpose  Simple delete in search/match for remote. If found,
*           initialize.
*
* @returns  L7_SUCCESS if deleted
*
* @notes    Currently ipv4 only support
*
* @end
*********************************************************************/
L7_RC_t ewaCpConnListDelete(L7_inet_addr_t remote)
{
  L7_BOOL found = L7_FALSE;
  L7_int8 i;

  for (i=0; (i<FD_CP_WEB_DEFAULT_MAX_CONNECTIONS); i++)
  {
    if (cpConnList[i].remote.addr.ipv4.s_addr==remote.addr.ipv4.s_addr)
    {
      found = L7_TRUE;
      break;
    }
  }
  if (found)
  {
    cpConnList[i].remote.addr.ipv4.s_addr = 0;
  }
  return (found)?L7_SUCCESS:L7_FAILURE;
}

/*********************************************************************
* @purpose  General helper function used to parse the handle peer
*           to return a valid internet address structure
*
* @returns  L7_inet_addr_t validate structure
*
* @end
*********************************************************************/
L7_inet_addr_t ewaRemoteGet(EwaNetHandle handle)
{
  L7_inet_addr_t remote;

  memset(&remote,0,sizeof(L7_inet_addr_t));

  if (NULL == handle)
  {
    return remote;
  }

  if (handle->peer.u.sa.sa_family == AF_INET6)
  {
    if(L7_IP6_IS_ADDR_V4MAPPED(&handle->peer.u.sa6.sin6_addr))
    {
      remote.family = L7_AF_INET;
      remote.addr.ipv4.s_addr = handle->peer.u.sa4.sin_addr.s_addr;
    }
    else
    {
      remote.family = L7_AF_INET6;
      remote.addr.ipv6 = *(L7_in6_addr_t *)&handle->peer.u.sa6.sin6_addr;
    }
  }
  else
  {
    remote.family = L7_AF_INET;
    remote.addr.ipv4.s_addr = handle->peer.u.sa4.sin_addr.s_addr;
  }
  return remote;
}

/*********************************************************************
* @purpose  General helper function used to loop through the servers
*           global list of Handles in search for a matching address.
*           Since a web connection can consist of several connections
*           (accept sockets), this function is used to determine if no
*           more connections exist for the given remote. This
*           indicates to CP that it can now be removed from the CP
*           connection list.
*
* @returns  L7_inet_addr_t validate structure
*
* @notes    Currently ipv4 only support
*
* @end
*********************************************************************/
L7_BOOL ewaHandleRemoteFind(EwaNetHandle* handles, L7_inet_addr_t remote)
{
  L7_BOOL found = L7_FALSE;
  L7_inet_addr_t tmpRemote;
  uintf i; /* match ewa datatype */

  /* Find the connection in the Handle table */
  for (i = 0; (i < MaxConnections); i++)
  {
    if (NULL != handles[i])
    {
      tmpRemote = ewaRemoteGet(handles[i]);
      if (tmpRemote.addr.ipv4.s_addr==remote.addr.ipv4.s_addr)
      {
        found = L7_TRUE;
        break;
      }
    }
  }
  return found;
}

/*********************************************************************
* @purpose  This function loops through the servers Handle array
*           looking for a IP match. If found, flush the buffer and
*           kill the connection.
*
* @end
*********************************************************************/
void ewaFlushAndAbortHandles(L7_IP_ADDR_t ipAddr)
{
  L7_inet_addr_t tmpRemote;
  uintf i; /* match ewa datatype */

  /* Find the connection in the Handle table */
  for (i = 0; (i < MaxConnections); i++)
  {
    if (NULL != Handle[i])
    {
      tmpRemote = ewaRemoteGet(Handle[i]);
      if (tmpRemote.addr.ipv4.s_addr==ipAddr)
      {
        ewsFlushAll(Handle[i]->context);
        ewsNetHTTPAbort(Handle[i]->context);
      }
    }
  }
}

/*********************************************************************
* @purpose  For debug purposes
*
* @returns  L7_int32 number of active CP connections
*
* @end
*********************************************************************/
L7_int32 ewaCpConnListCountGet(void)
{
  L7_int8 i;
  L7_int8 j=0;

  for (i=0; (i<FD_CP_WEB_DEFAULT_MAX_CONNECTIONS); i++)
  {
    if (0!=cpConnList[i].remote.addr.ipv4.s_addr)
    {
      j++;
    }
  }
  return j;
}

/*********************************************************************
* @purpose  For general debug purposes. This function loops through
*           servers Handle array and displays each handle entry and
*           its assigned IP address (ipv4)
*
*********************************************************************/
L7_RC_t dumpHandles(void)
{
  L7_inet_addr_t remote;
  uintf i;

  for (i = 0; (i < MaxConnections); i++)
  {
    if (NULL != Handle[i])
    {
      remote = ewaRemoteGet(Handle[i]);
      printf("\r\n%s: Handle[%d] = %p remote[%d] = %d",
             __FUNCTION__,(int)i,Handle[i],(int)i,(int)remote.addr.ipv4.s_addr);
    }
  }
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  For general debug purposes. This function loops through
*           the CP connection array and displays each entry.
*
*********************************************************************/
L7_RC_t dumpCP(void)
{
  L7_int8 i;

  printf("\r\n%s: FD_CP_WEB_DEFAULT_MAX_CONNECTIONS = %d",
         __FUNCTION__,FD_CP_WEB_DEFAULT_MAX_CONNECTIONS);
  printf("\r\n%s: MaxConnections = %d",
         __FUNCTION__,(int)MaxConnections);

  for (i=0; (i<FD_CP_WEB_DEFAULT_MAX_CONNECTIONS); i++)
  {
    printf("\r\n%s: cpConnList[%d].remote.addr.ipv4.s_addr = %d",
           __FUNCTION__,i,(int)cpConnList[i].remote.addr.ipv4.s_addr);
  }
  return L7_SUCCESS;
}

/* ################################################################ */
/*                   END CAPTIVE PORTAL SUPPORT                     */
/* ################################################################ */
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

/* ################################################################ */
/*                          M A I N                                 */
/* ################################################################ */


/*****
 * if ipv6 package is defined, there are two choices for binding
 * telnet and http sockets. with a linux kernel, bind once with the ipv6
 * unspecified address. v4 connections are then accepted as ipv6 v4-mapped.
 * a v4 bind cannot be performed as addr_in_use error is returned.
 * with other stacks, bind once for v4 inaddr_any and once for v6 unspecified.
 *
*****/
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
/* this is for linux kernel stack */
#undef L7_TELNET_V4_BIND
#undef L7_HTTP_V4_BIND
#else
#define L7_TELNET_V4_BIND
#define L7_HTTP_V4_BIND
#endif

#ifdef EW_CONFIG_OPTION_TELNET
SOCKET                telnet_s = 0;      /* telnet listening socket */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
SOCKET                telnet6_s = 0;      /* telnet listening socket */
#endif
SOCKET                ssh_s = 0;      /* internal ssh listening socket */
static  L7_BOOL       telnet_active;    /* Telnet Active - L7_TRUE or L7_FALSE */
#endif /* EW_CONFIG_OPTION_TELNET */

static  int           http_mode_config; /* HTTP user configured mode - L7_ENABLE / L7_DISABLE */
static  L7_BOOL       http_active;      /* HTTP Active - L7_TRUE or L7_FALSE */
static  int           ssl_mode_config;  /* SSL user configured mode - L7_ENABLE / L7_DISABLE */


#ifdef EW_CONFIG_OPTION_SSL_RSA
BIO                   *ssl_l_bio;         /* SSL listening BIO */
BIO                   *ssl_template_bio;  /* SSL template BIO */
SSL_CTX               *ssl_ctx;
SOCKET                ssl_s = 0;              /* SSL listening socket */
#endif /* EW_CONFIG_OPTION_SSL_RSA */

#ifdef EW_CONFIG_OPTION_UPNP
SOCKET                upnp_server_s = 0;        /* upnp listening socket,
                                             * for when acting as a UPnP
                                             * server */
struct ip_mreq        ipMreq;      /* multicast socket info */
SOCKET                upnp_client_s = 0;        /* upnp sending socket,
                         * for when acting as a UPnP
                         * client */
#endif /* EW_CONFIG_OPTION_UPNP */


#ifdef _WIN32_WCE
time_t
time(time_t * pRetval)
{
  SYSTEMTIME      systemTime;
  time_t          secondsSinceEpoch;
  int             year;
  int             numLeapYears;
  int             daysSinceYearStart[] =
  {
    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
  };

#define      SECONDS_PER_MINUTE              60
#define      MINUTES_PER_HOUR                60
#define      HOURS_PER_DAY                   24
#define      DAYS_PER_YEAR                   365
#define      DAYS_SINCE_YEARSTART(month)     daysSinceYearStart[month]
#define      SECONDS_PER_DAY                 (SECONDS_PER_MINUTE *   \
                                                MINUTES_PER_HOUR *      \
                                                HOURS_PER_DAY)
#define      SECONDS_PER_YEAR                (SECONDS_PER_DAY *      \
                                                DAYS_PER_YEAR)


  /* Get the current time in Windows time structure */
  GetSystemTime(&systemTime);

  /*
   * Convert the structured time to a number of seconds since the beginning
   * of the epoch.  The epoch began at midnight, 1 Jan 1970.  Don't deal
   * with leap years yet.  We'll handle them later.
   */
  secondsSinceEpoch =
  (((systemTime.wYear - 1970) * SECONDS_PER_YEAR) +
   (DAYS_SINCE_YEARSTART(systemTime.wMonth - 1) * SECONDS_PER_DAY) +
   ((systemTime.wDay - 1) * SECONDS_PER_DAY) +
   (systemTime.wHour * MINUTES_PER_HOUR * SECONDS_PER_MINUTE) +
   (systemTime.wMinute * SECONDS_PER_MINUTE) +
   (systemTime.wSecond) +
   ((systemTime.wMilliseconds + 500) / 1000));

  /*
   * Now let's figure out how many leap years there have been, and add the
   * number of seconds per day for each of those.
   *
   * Note, this function will fail in year 2100, which is not a leap year,
   * but will be counted as one.  Do we really care?
   *
   * (We could optimize this by pre-calculating the number of leap years
   * prior to the date this code was written, but I think the code is
   * clearer this way and not substantially slower.)
   */
  for (numLeapYears = 0, year = 1972;
      year < systemTime.wYear;
      year += 4, numLeapYears++)
  {
    /* Nothing to do; just counting leap years. */
  }

  /* If the current year is a leap year and we're into March... */
  if (systemTime.wYear % 4 == 0 && systemTime.wMonth >= 3)
  {
    /* ... then we have one more leap year to handle */
    numLeapYears++;
  }

  /* Add in the number of seconds in this number of leap years */
  secondsSinceEpoch += numLeapYears * SECONDS_PER_DAY;

  /* If they gave us a place to put the value... */
  if (pRetval != NULL)
  {
    /* ... then give it to 'em */
    *pRetval = secondsSinceEpoch;
  }

  /* Give 'em what they came for */
  return secondsSinceEpoch;
}
#endif /* _WIN32_WCE */


/*********************************************************************
* @purpose  Close any open http/ssl connections
*
* @returns nothing
*
* @notes none
*
* @end
*********************************************************************/
void closeWebConnections(void)
{
  uint32 s;

  /* Clean up the open HTTP connections */
  for (s = FD_CLI_DEFAULT_MAX_CONNECTIONS; s < MaxConnections; s++)
  {
    if ( Handle[s] != NULL && Handle[s]->socket > 0 )
    {
      EMWEB_TRACE_SOCKET("closing web connection on Handle[%d]\n", (int) s);
      if (Handle[s]->context != NULL)
      {
        ewsNetHTTPAbort(Handle[s]->context);
      }
      /* shutdown( Handle[s]->socket, 2 );
      close( Handle[s]->socket );
      */
    }
  }
  osapiSleepMSec(1000);
  for (s = FD_CLI_DEFAULT_MAX_CONNECTIONS; s < MaxConnections; s++)
  {
    if ( Handle[s] != NULL && Handle[s]->socket > 0)
    {
      shutdown( Handle[s]->socket, 2 );
      close( Handle[s]->socket );
      Handle[s]->socket = -1;
    }
  }

}


/*********************************************************************
* @purpose  used to activate the telnet socket
*
* @returns L7_SUCCESS successfully activated
*          L7_FAILURE otherwise
*
* @notes none
*
* @end
*********************************************************************/
L7_RC_t ewaNetTelnetSocketActivate(void)
{
  int                   one = 1;
  int                   retry;
  L7_uint32             telnet_port;
#ifdef L7_TELNET_V4_BIND
  struct linger         linger;
  struct sockaddr_in    addr;             /* TCP/IP socket structure */
  uint32                hostaddr;
#endif
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  struct sockaddr_in6   addr6;
#endif

  cliWebTelnetPortGet((&telnet_port));
  Telnet_Port = telnet_port;
#ifdef L7_TELNET_V4_BIND
  /* Create socket */
  ClearErrno();
  telnet_s = socket( AF_INET, SOCK_STREAM, 0 );
  if (SOCKET_IS_INVALID(telnet_s))
  {
    EMWEB_ERROR(( "telnet socket call failed: %s\n", strerror(errno)));
    return L7_ERROR;
  }

  /* allowing address reuse allows the server to be stopped and restarted */
  ClearErrno();
  if ((setsockopt(telnet_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "telnet setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    return L7_ERROR;
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

    errno = 0;
    if ((setsockopt(telnet_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
    {
        EMWEB_ERROR(( "telnet setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
    }

    errno = 0;
    if ((setsockopt(telnet_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
    {
        EMWEB_ERROR(( "telnet setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
    }

#endif


  /* finish sending pending data before closing tcp connection */
  ClearErrno();

  /* tbd */
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 20;
  if ( (setsockopt(telnet_s, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger)) ) < 0 )
  {
    EMWEB_ERROR(( "telnet setsockopt LINGER failed %s\n", strerror(errno)));
  }


  /* bind the TELNET listening port */
  ClearErrno();
  hostaddr = osapiHtonl(EMWEB_LISTEN_IPADDR);
  memset( &addr, 0, sizeof( addr ));
  /* memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof(uint32) );*/
  addr.sin_family = AF_INET;
  addr.sin_port = osapiHtons(  Telnet_Port );

  for (retry=0; retry < L7_MAX_BIND_ERROR_RETRY; retry++)
  {
    if (bind(telnet_s, (struct sockaddr *) &addr, sizeof(addr)) >= 0)
      break;
    osapiSleep(1);
  }

  if (retry > 0)
    EMWEB_TRACE_SOCKET("Telnet bind took %d seconds\n", retry);

  if (retry >= L7_MAX_BIND_ERROR_RETRY)
  {
    EMWEB_ERROR(( "telnet bind failed: %s\n", strerror(errno)));
    return L7_ERROR;
  }

  ClearErrno();
  if ( listen(telnet_s, MaxConnections ) < 0 )
  {
    EMWEB_ERROR(( "telnet listen failed: %s\n", strerror(errno)));
    return L7_ERROR;
  }
#endif /* L7_TELNET_V4_BIND */

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  /* Create socket */
  ClearErrno();
  telnet6_s = socket( AF_INET6, SOCK_STREAM, 0 );
  if (SOCKET_IS_INVALID(telnet6_s))
  {
    EMWEB_ERROR(( "telnet6 socket call failed: %s\n", strerror(errno)));
    return L7_ERROR;
  }

  /* allowing address reuse allows the server to be stopped and restarted */
  ClearErrno();
  if ((setsockopt(telnet6_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "telnet6 setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    return L7_ERROR;
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

  errno = 0;
  if ((setsockopt(telnet6_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
  {
    EMWEB_ERROR(( "telnet6 setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
  }

  errno = 0;
  if ((setsockopt(telnet6_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
  {
    EMWEB_ERROR(( "telnet6 setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
  }

#endif


  /* finish sending pending data before closing tcp connection */
  ClearErrno();
#if 0
  /* tbd */
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 20;
  if ( (setsockopt(telnet6_s, SOL_SOCKET, SO_LINGER, (void *)&linger,
                   sizeof(linger))
       )
       < 0
     )
  {
    EMWEB_ERROR(( "telnet setsockopt LINGER failed %s\n", strerror(errno)));
  }
#endif

  /* bind the TELNET6 listening port */
  ClearErrno();
  memset( &addr6, 0, sizeof( addr6 ));
  addr6.sin6_family = AF_INET6;
  addr6.sin6_port = osapiHtons( Telnet_Port );

  for (retry=0; retry < L7_MAX_BIND_ERROR_RETRY; retry++)
  {
    if (bind(telnet6_s, (struct sockaddr *) &addr6, sizeof(addr6)) >= 0)
      break;
    osapiSleep(1);
  }

  if (retry > 0)
    EMWEB_TRACE_SOCKET("Telnet6 bind took %d seconds\n", retry);

  if (retry >= L7_MAX_BIND_ERROR_RETRY)
  {
    EMWEB_ERROR(( "telnet6 bind failed: %s\n", strerror(errno)));
    return L7_ERROR;
  }

  ClearErrno();
  if ( listen(telnet6_s, MaxConnections ) < 0 )
  {
    EMWEB_ERROR(( "telnet6 listen failed: %s\n", strerror(errno)));
    return L7_ERROR;
  }
#endif /* L7_IPV6_PACKAGE */
  telnet_active = L7_TRUE;

  EMWEB_TRACE_SOCKET("telnet Socket Activated\n");

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  To change the listening port of the telnet server
*
* @param    port - port on which the telnet runs
*
* @returns  L7_SUCCESS
*           L7_ADDR_INUSE If failed to bind since address given is already in use
*           L7_FAILURE
*
* @notes    Closes the existing listening socket and opens the listening socket and puts it
*                into the Listening state.
*
* @end
*********************************************************************/
L7_RC_t telnetPortSet(L7_uint32 port)
{
  L7_RC_t rc, rcTemp;

  L7_uint32 portTemp;
  cliWebTelnetPortGet(&portTemp);

  cliWebTelnetPortSet(port, L7_FALSE);

  rcTemp = cliWebTelnetPortUpdate();

  /* if failed, reset the port to the previous port in use */
  if (rcTemp != L7_SUCCESS)
  {
    cliWebTelnetPortSet(portTemp, L7_FALSE);

    rc = ewaNetTelnetSocketActivate();

    if (rc != L7_SUCCESS)
    {
      return rc;
    }
    else
    {   /* you stil throw  rcTemp to let user know that given port is not set */
      return rcTemp;
    }
  }
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  used to close the telnet socket
*
* @returns L7_SUCCESS successfully activated
*          L7_FAILURE otherwise
*
* @notes none
*
* @end
*********************************************************************/
L7_RC_t ewaNetTelnetSocketClose(void)
{
  /* closeTelnetConnections(); */

  telnet_active = L7_FALSE;

  if(telnet_s != 0)
  {
  shutdown(telnet_s, 2);
  close(telnet_s);
  }

  telnet_s = 0;
  EMWEB_TRACE_SOCKET("Telnet Socket Closed\n");
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)

  if(telnet6_s != 0)
  {
  shutdown(telnet6_s, 2);
  close(telnet6_s);
  }

  telnet6_s = 0;
  EMWEB_TRACE_SOCKET("Telnet6 Socket Closed\n");
#endif
  return L7_SUCCESS;
}


/*********************************************************************
* @purpose  used to activate the http socket bound to port 80
*
* @returns L7_SUCCESS successfully activated
*          L7_FAILURE otherwise
*
* @notes none
*
* @end
*********************************************************************/
L7_RC_t ewaNetHTTPSocketActivate(uint32 httpHostAddr)
{
  int                   one = 1;
  int                   retry;
  L7_uint32             httpListeningPort;
#ifdef L7_HTTP_V4_BIND
  struct sockaddr_in    addr;             /* TCP/IP socket structure */
  uint32                hostaddr;
#endif
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  struct sockaddr_in6 addr6;
#endif
#if defined(L7_MGMT_SECURITY_PACKAGE)
  L7_uint32  ssltmode;
#endif

  cliWebHttpPortGet(&httpListeningPort);
  httpListenPort = httpListeningPort;
#ifdef L7_HTTP_V4_BIND
  hostaddr = osapiHtonl(httpHostAddr);
  memset( &addr, 0, sizeof( addr ));
  if (httpHostAddr != 0)
    memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof(uint32) );
  addr.sin_family = AF_INET;
  addr.sin_port = osapiHtons( httpListeningPort );

  /* Create socket */
  ClearErrno();
  http_s = socket( AF_INET, SOCK_STREAM, 0 );
  if (SOCKET_IS_INVALID(http_s))
  {
    EMWEB_ERROR(( "ewmain: HTTP socket() call failed: %s\n",
                  strerror(errno)));
    return(L7_FAILURE);
  }

  /* allowing address reuse allows the server to be stopped and restarted */
  ClearErrno();
  if ((setsockopt(http_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "http setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    return(L7_FAILURE);
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

    errno = 0;
    if ((setsockopt(http_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
    {
        EMWEB_ERROR(( "http setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
    }

    errno = 0;
    if ((setsockopt(http_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
    {
        EMWEB_ERROR(( "http setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
    }

#endif


  /* finish sending pending data before closing tcp connection */
  ClearErrno();

#if 0
  /* tbd */
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 20;
  if ( (setsockopt(http_s, SOL_SOCKET, SO_LINGER, (void *)&linger,
                   sizeof(linger))) < 0 )
  {
    EMWEB_ERROR(( "http setsockopt LINGER failed %s\n", strerror(errno)));
  }
#endif

  /* bind the HTTP listening port */
  ClearErrno();
  for(retry=0; retry < L7_MAX_BIND_ERROR_RETRY; retry++)
  {
    if (bind(http_s, (struct sockaddr *) &addr, sizeof(addr)) >= 0)
      break;
    osapiSleep(1);
  }

  if (retry > 0)
    EMWEB_TRACE_SOCKET("HTTP bind took %d seconds\n", retry);

  if(retry >= L7_MAX_BIND_ERROR_RETRY)
  {
    EMWEB_ERROR(( "http bind failed: 1 %s\n", strerror(errno)));
    return(L7_FAILURE);
  }

  ClearErrno();
  if ( listen(http_s, MaxConnections) < 0 )
  {
    EMWEB_ERROR(( "http listen failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }
#endif /* L7_HTTP_V4_BIND */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  memset( &addr6, 0, sizeof( addr6 ));
  addr6.sin6_family = AF_INET6;
  addr6.sin6_port = osapiHtons( httpListeningPort );

  /* Create socket */
  ClearErrno();
  http6_s = socket( AF_INET6, SOCK_STREAM, 0 );
  if (SOCKET_IS_INVALID(http6_s))
  {
    EMWEB_ERROR(( "ewmain: HTTP6 socket() call failed: %s\n",
                  strerror(errno)));
    return(L7_FAILURE);
  }

  /* allowing address reuse allows the server to be stopped and restarted */
  ClearErrno();
  if ((setsockopt(http6_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "http6 setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    return(L7_FAILURE);
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

    errno = 0;
    if ((setsockopt(http6_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
    {
        EMWEB_ERROR(( "http6 setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
    }

    errno = 0;
    if ((setsockopt(http6_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
    {
        EMWEB_ERROR(( "http6 setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
    }

#endif


  /* finish sending pending data before closing tcp connection */
  ClearErrno();
#if 0
  /* tbd */
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 20;
  if ( (setsockopt(http6_s, SOL_SOCKET, SO_LINGER, (void *)&linger,
                   sizeof(linger))) < 0 )
  {
    EMWEB_ERROR(( "http6 setsockopt LINGER failed %s\n", strerror(errno)));
  }
#endif

  /* bind the HTTP listening port */
  ClearErrno();
  for(retry=0; retry < L7_MAX_BIND_ERROR_RETRY; retry++)
  {
    if (bind(http6_s, (struct sockaddr *) &addr6, sizeof(addr6)) >= 0)
      break;
    osapiSleep(1);
  }

  if (retry > 0)
    EMWEB_TRACE_SOCKET("HTTP6 bind took %d seconds\n", retry);

  if(retry >= L7_MAX_BIND_ERROR_RETRY)
  {
    EMWEB_ERROR(( "http6 bind failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }

  ClearErrno();
  if ( listen(http6_s, MaxConnections ) < 0 )
  {
    EMWEB_ERROR(( "http6 listen failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }
#endif /* L7_FLEX_PACKAGE */
#if defined(L7_MGMT_SECURITY_PACKAGE)
  ssltmode=L7_DISABLE;

  if ((ssltAdminModeGet(&ssltmode) == L7_SUCCESS) &&
      (ssltmode == L7_ENABLE))
  {
     ssltUnSecurePortSet(httpListeningPort);
  }
#endif /* L7_MGMT_SECURITY_PACKAGE */

  http_active = L7_TRUE;

  EMWEB_TRACE_SOCKET("HTTP Socket Activated on address 0x%x\n", (unsigned int) httpHostAddr);

  return L7_SUCCESS;
}

#ifdef L7_CAPTIVE_PORTAL_PACKAGE
/*********************************************************************
* @purpose  used to activate the http socket bound to the Captive
*           Portal port
*
* @returns L7_SUCCESS successfully activated
*          L7_FAILURE otherwise
*
* @notes none
*
* @end
********************************************************************/
L7_RC_t ewaNetCaptivePortalHTTPSocketActivate(uint32 httpHostAddr)
{
  int                   one = 1;
  int                   retry;
#ifdef L7_HTTP_V4_BIND
  struct sockaddr_in    addr;             /* TCP/IP socket structure */
  uint32                hostaddr;
#endif
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  struct sockaddr_in6 addr6;
#endif

#ifdef L7_HTTP_V4_BIND
  hostaddr = osapiHtonl(httpHostAddr);
  memset( &addr, 0, sizeof( addr ));
  if (httpHostAddr != 0)
    memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof(uint32) );
  addr.sin_family = AF_INET;
  addr.sin_port = cp_http_port;

  /* Create socket */
  ClearErrno();
  cp_http_s = socket( AF_INET, SOCK_STREAM, 0 );
  if (SOCKET_IS_INVALID(cp_http_s))
  {
    EMWEB_ERROR(( "ewmain: HTTP socket() call failed: %s\n",
                  strerror(errno)));
    return(L7_FAILURE);
  }

  /* allowing address reuse allows the server to be stopped and restarted */
  ClearErrno();
  if ((setsockopt(cp_http_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "http setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    return(L7_FAILURE);
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

    errno = 0;
    if ((setsockopt(cp_http_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
    {
        EMWEB_ERROR(( "http setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
    }

    errno = 0;
    if ((setsockopt(cp_http_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
    {
        EMWEB_ERROR(( "http setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
    }

#endif


  /* finish sending pending data before closing tcp connection */
  ClearErrno();

#if 0
  /* tbd */
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 20;
  if ( (setsockopt(cp_http_s, SOL_SOCKET, SO_LINGER, (void *)&linger,
                   sizeof(linger))) < 0 )
  {
    EMWEB_ERROR(( "http setsockopt LINGER failed %s\n", strerror(errno)));
  }
#endif

  /* bind the HTTP listening port */
  ClearErrno();
  for(retry=0; retry < L7_MAX_BIND_ERROR_RETRY; retry++)
  {
    if (bind(cp_http_s, (struct sockaddr *) &addr, sizeof(addr)) >= 0)
      break;
    osapiSleep(1);
  }

  if (retry > 0)
    EMWEB_TRACE_SOCKET("HTTP bind took %d seconds\n", retry);

  if(retry >= L7_MAX_BIND_ERROR_RETRY)
  {
    EMWEB_ERROR(( "http bind failed: 2 %s\n", strerror(errno)));
    return(L7_FAILURE);
  }

  ClearErrno();
  if ( listen(cp_http_s, MaxConnections ) < 0 )
  {
    EMWEB_ERROR(( "http listen failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }
#endif /* L7_HTTP_V4_BIND */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  memset( &addr6, 0, sizeof( addr6 ));
  addr6.sin6_family = AF_INET6;
  addr6.sin6_port = cp_http_port;

  /* Create socket */
  ClearErrno();
  cp_http6_s = socket( AF_INET6, SOCK_STREAM, 0 );
  if (SOCKET_IS_INVALID(cp_http6_s))
  {
    EMWEB_ERROR(( "ewmain: HTTP6 socket() call failed: %s\n",
                  strerror(errno)));
    return(L7_FAILURE);
  }

  /* allowing address reuse allows the server to be stopped and restarted */
  ClearErrno();
  if ((setsockopt(cp_http6_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "cp_http6 setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    return(L7_FAILURE);
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

    errno = 0;
    if ((setsockopt(cp_http6_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
    {
        EMWEB_ERROR(( "cp_http6 setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
    }

    errno = 0;
    if ((setsockopt(cp_http6_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
    {
        EMWEB_ERROR(( "cp_http6 setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
    }

#endif


  /* finish sending pending data before closing tcp connection */
  ClearErrno();
#if 0
  /* tbd */
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 20;
  if ( (setsockopt(cp_http6_s, SOL_SOCKET, SO_LINGER, (void *)&linger,
                   sizeof(linger))) < 0 )
  {
    EMWEB_ERROR(( "cp_http6 setsockopt LINGER failed %s\n", strerror(errno)));
  }
#endif

  /* bind the HTTP listening port */
  ClearErrno();
  for(retry=0; retry < L7_MAX_BIND_ERROR_RETRY; retry++)
  {
    if (bind(cp_http6_s, (struct sockaddr *) &addr6, sizeof(addr6)) >= 0)
      break;
    osapiSleep(1);
  }

  if (retry > 0)
    EMWEB_TRACE_SOCKET("HTTP6 bind took %d seconds\n", retry);

  if(retry >= L7_MAX_BIND_ERROR_RETRY)
  {
    EMWEB_ERROR(( "http6 bind failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }

  ClearErrno();
  if ( listen(cp_http6_s, MaxConnections ) < 0 )
  {
    EMWEB_ERROR(( "cp_http6 listen failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }
#endif /* L7_FLEX_PACKAGE */
  cp_http_active = L7_TRUE;

  EMWEB_TRACE_SOCKET("HTTP CP Socket Activated on address 0x%x\n", (unsigned int) httpHostAddr);

  return L7_SUCCESS;
}
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

/*********************************************************************
* @purpose  used to close the http socket bound to port 80
*
* @returns L7_SUCCESS successfully activated
*          L7_FAILURE otherwise
*
* @notes none
*
* @end
*********************************************************************/
L7_RC_t ewaNetHTTPSocketClose(void)
{
  http_active = L7_FALSE;

  if (http_s != 0)
  {
  shutdown(http_s, 2);
  close(http_s);
  }

  http_s = 0;
  EMWEB_TRACE_SOCKET("HTTP Socket Closed\n");

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  if (http6_s != 0)
  {
    shutdown(http6_s, 2);
    close(http6_s);
  }

  http6_s = 0;
  EMWEB_TRACE_SOCKET("HTTP6 Socket Closed\n");
#endif /* L7_IPV6_PACKAGE */

  return L7_SUCCESS;
}

#ifdef L7_CAPTIVE_PORTAL_PACKAGE
/*********************************************************************
* @purpose  Used to close the http socket bound to the captive portal
*           port
*
* @returns L7_SUCCESS successfully activated
*          L7_FAILURE otherwise
*
* @end
*********************************************************************/
L7_RC_t ewaNetCaptivePortalHTTPSocketClose()
{
  cp_http_active = L7_FALSE;

  if (cp_http_s != 0)
  {
  shutdown(cp_http_s, 2);
  close(cp_http_s);
  }

  cp_http_s = 0;
  EMWEB_TRACE_SOCKET("HTTP CP Socket Closed\n");

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  if (cp_http6_s != 0)
  {
    shutdown(cp_http6_s, 2);
    close(cp_http6_s);
  }

  cp_http6_s = 0;
  EMWEB_TRACE_SOCKET("HTTP6 CP Socket Closed\n");
#endif /* L7_IPV6_PACKAGE */

  return L7_SUCCESS;
}
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

/*********************************************************************
* @purpose  initialize the emweb globals for the port 80 socket
*
* @returns nothing
*
* @notes none
*
* @end
*********************************************************************/
void ewaNetVarsInit(void)
{
  http_active = L7_FALSE;
  http_mode_config = L7_DISABLE;
  ssl_mode_config = L7_DISABLE;
  telnet_active = L7_FALSE;
#ifdef L7_CAPTIVE_PORTAL_PACKAGE
  cp_http_active = L7_FALSE;
  cp_http_mode_config = L7_DISABLE;
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */
}

/*********************************************************************
* @purpose  HTTP mode has changes so reconfigure the socket as appropriate
*
* @returns nothing
*
* @notes 0.0.0.0.80 Any address when http enabled
*        127.0.0.1.80 Loopback address when http disabled and ssl enabled
*        CLOSED when http and ssl are disabled
*
* @end
*********************************************************************/
void ewaNetHTTPModeToggle(void)
{
#ifdef L7_MGMT_SECURITY_PACKAGE
  L7_uint32 ssl_mode;
  if (usmDbssltAdminModeGet(0, &ssl_mode) != L7_SUCCESS)
        ssl_mode = L7_DISABLE;
#endif

  if (http_mode_config == L7_ENABLE)
    http_mode_config = L7_DISABLE;
  else
    http_mode_config = L7_ENABLE;

  EMWEB_TRACE_SOCKET("http mode toggle\n");
  if (http_mode_config == L7_ENABLE)
  {

#ifdef L7_MGMT_SECURITY_PACKAGE
    if (ssl_mode == L7_ENABLE)
    {
      closeWebConnections();

      if (usmDbssltAdminModeSet(0, L7_DISABLE) != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to disable SSL\n");
      osapiSleepMSec(200);

      if (ewaNetHTTPSocketClose() != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to Close the HTTP Loopback Socket\n");
      osapiSleepMSec(200);
    }
#endif

    if (ewaNetHTTPSocketActivate(0x00) != L7_SUCCESS)
      EMWEB_TRACE_SOCKET("ERROR: Failed to Activate the HTTP Socket\n");

#ifdef L7_MGMT_SECURITY_PACKAGE
    if (ssl_mode == L7_ENABLE)
    {
      if (usmDbssltAdminModeSet(0, L7_ENABLE) != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to enable SSL\n");
    }
#endif
  }
  else
  {

#ifdef L7_MGMT_SECURITY_PACKAGE
    if (ssl_mode == L7_ENABLE)
    {
      if (usmDbssltAdminModeSet(0, L7_DISABLE) != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to disable SSL\n");
      osapiSleepMSec(200);
    }
#endif

    closeWebConnections();

    if (ewaNetHTTPSocketClose() != L7_SUCCESS)
      EMWEB_TRACE_SOCKET("ERROR: Failed to Close the HTTP Socket\n");

#ifdef L7_MGMT_SECURITY_PACKAGE
    if (ssl_mode == L7_ENABLE)
    {
      osapiSleepMSec(200);
      if (ewaNetHTTPSocketActivate(L7_LOOPBACK_ADDR) != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to Activate the HTTP Loopback Socket\n");
      if (usmDbssltAdminModeSet(0, L7_ENABLE) != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to disable SSL\n");
    }
    #endif

  }
}


#ifdef L7_CAPTIVE_PORTAL_PACKAGE
/*********************************************************************
* @purpose  Captive Portal HTTP mode has changes so reconfigure the
* socket as appropriate.
*
* @returns nothing
*
* @notes 0.0.0.0.port Any address when captive portal http enabled
*        127.0.0.1.port Loopback address when captive portal http disabled
*        CLOSED when http is disabled
*
*        We can provide Captive Portal SSL support here as well if it
*        becomes a requirements
*
* @end
*********************************************************************/
void ewaNetCaptivePortalHTTPPortModeSet(int cp_mode, int cp_port)
{
  L7_BOOL fNewPort = L7_FALSE;

  /*
  ** Shutdown the additional socket if the configured HTTP port is 0
  ** We'll just use the default emweb socket & port
  */
  if ((0==cp_port) || (EMWEB_LISTEN_PORT==cp_port))
  {
    cp_port = EMWEB_LISTEN_PORT;
    closeWebConnections();
    ewaNetCaptivePortalHTTPSocketClose();
    return;
  }

  if ((cp_http_port!=cp_port) && (EMWEB_LISTEN_PORT!=cp_port))
  {
    cp_http_port = cp_port;
    fNewPort = L7_TRUE;
  }

  if (cp_mode==L7_ENABLE)
  {
    if (cp_http_mode_config == L7_ENABLE)
    {
      if (fNewPort)
      {
        closeWebConnections();
        ewaNetCaptivePortalHTTPSocketClose();
        ewaNetCaptivePortalHTTPSocketActivate(0x00);
      }
    }
    else
    {
      ewaNetCaptivePortalHTTPSocketActivate(0x00);
    }
  }
  else
  {
    closeWebConnections();
    ewaNetCaptivePortalHTTPSocketClose();
  }
  cp_http_mode_config = cp_mode;
}
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

/*********************************************************************
* @purpose  SSL mode has changes so reconfigure the socket as appropriate
*
* @returns nothing
*
* @notes 0.0.0.0.80 Any address when http enabled
*        127.0.0.1.80 Loopback address when http disabled and ssl enabled
*        CLOSED when http and ssl are disabled
*
* @end
*********************************************************************/
void ewaNetSSLModeToggle(void)
{
  if (ssl_mode_config == L7_ENABLE)
    ssl_mode_config = L7_DISABLE;
  else
    ssl_mode_config = L7_ENABLE;

  EMWEB_TRACE_SOCKET("ssl mode toggle\n");
  if (ssl_mode_config == L7_ENABLE)
  {
    if (http_mode_config != L7_ENABLE)
    {
      if (ewaNetHTTPSocketActivate(L7_LOOPBACK_ADDR) != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to Activate the HTTP Socket\n");
    }
  }
  else
  {
    if (http_mode_config != L7_ENABLE)
    {
      if (ewaNetHTTPSocketClose() != L7_SUCCESS)
        EMWEB_TRACE_SOCKET("ERROR: Failed to Close the HTTP Socket\n");
    }
  }
}

/*********************************************************************
* @purpose  debug
*********************************************************************/
void dumpConnectionCounters()
{
  printf("\r\n MaxConnections           = %d", MaxConnections);
  printf("\r\n ConnectionsActive        = %d", ConnectionsActive);
  printf("\r\n ConnectionsActiveTelnet  = %d", ConnectionsActiveTelnet);
  printf("\r\n ConnectionsActiveSSH     = %d", ConnectionsActiveSSH);
#ifdef L7_CAPTIVE_PORTAL_PACKAGE
  printf("\r\n CaptivePortalConnections = %d", ewaCpConnListCountGet());
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */
}
/* this function will allocate the max number of buffers as many as EB_MAX_BUFFER_DESCR
 * so that we have maximum number of buffer descriptors,maximum number of buffer segments allocated
 * and free them immediately so that they are present in
 * free list. This will clear the memory leak doubts because
 * the buffer mechanism will not configured count free entries
 * For this purpose we have set EB_MAX_BUFFER_DESCR, EB_MAX_BUFFER_SEGS to same value so that we do not
 *  get issue of net buffers not available after 512 segements are allocated
 */
static
void ewaNetBufferPreAlloc()
{
  int i;


  char **ptrs = (char **)ebAlloc(EB_MAX_BUFFER_DESCR * sizeof(char *));

  for(i=0; i<EB_MAX_BUFFER_DESCR; i++)
  {
    ptrs[i] = (char *)ewaNetBufferAlloc();
  }

  for(i=0; i<EB_MAX_BUFFER_DESCR; i++)
  {
     ewaNetBufferFree((EwaNetBuffer )ptrs[i]);
  }

  ewaFree(ptrs);

}

/*********************************************************************
*********************************************************************/
L7_RC_t L7_ewsPhaseOneInit(arg0 /* max connections - use default */
                           ,arg1 /* max buffers - use default */
                           ,arg2 /* buffer data size - use default */
                           ,arg3 /* port number - use default */
                          )
{
#if defined(L7_WEB_PACKAGE) || defined(L7_XWEB_PACKAGE)
  EwaStatus             app_status;
#endif
  /*
  sigset_t              BlockedSigs;
  */

  time_t                lastTime;      /* for manual periodic timer */

  ewaInitConnections( arg0 ? arg0 : EMWEB_MAX_CONNECTIONS );
  ewaNetBufferPreAlloc();


  /* If any of the options that require a socket to be setup are turned on,
     then call setupOptionSockets()
  */
#if defined(EW_CONFIG_OPTION_UPNP) || defined(EW_CONFIG_OPTION_TELNET) || \
        defined(EW_CONFIG_OPTION_SSL_RSA)
  setupOptionSockets(EMWEB_LISTEN_IPADDR,EMWEB_LISTEN_PORT);
#endif

#ifdef EMWEB_USE_SIGNALS
  /*
   * Ignore PIPE signal -- there's a race condition in which EmWeb/Server
   * may attempt to write to a socket just as the browser is closing the
   * connection.  By ignoring the signal, we will eventually be notified
   * of the closed connection and clean up gracefully.
   */
  signal(SIGPIPE, SIG_IGN);

  /*
   * Catch SIGINT and SIGQUIT for graceful exit
   */
  signal( SIGINT, sig_handler );
  signal( SIGQUIT, sig_handler );

#ifdef EMWEB_POSIX_OPTION_SERVER_PUSH
  signal( SIGALRM, sig_handler );
  alarm( APPLICATION_TIMER_INTERVAL );
#endif /* EMWEB_POSIX_OPTION_SERVER_PUSH */

#endif /* EMWEB_USE_SIGNALS */

#ifdef COMMENTED_OUT
  signal(SIGPIPE, SIG_IGN);
  sigemptyset(&BlockedSigs);
  sigaddset(&BlockedSigs, SIGPIPE);
  sigaddset(&BlockedSigs, SIGTERM);
  sigprocmask(SIG_SETMASK, &BlockedSigs, NULL);
#endif /* COMMENTED_OUT */

  /* Initialize EmWeb/Server */
  ewsInit();

  ewaTaskInit();

#if defined(L7_WEB_PACKAGE) || defined(L7_XWEB_PACKAGE)
  /* Install archive in EmWeb/Server database. */
  app_status = ewaInstallArchives();
  if (app_status != EWA_STATUS_OK)
  {
    EMWEB_ERROR(( "ewaInstallArchives() failed %d\n", app_status ));
    return(L7_FAILURE);
  }
#endif

#ifdef EW_CONFIG_OPTION_UPNP
#ifdef EWA_LOG_HOOK
  /* Initialize the discard object so that data dump looks OK. */
  strcpy(ewaNetHandleSpecialDiscardObject.sourceAddrStr, "[Discard]");
#endif /* EWA_LOG_HOOK */
  /* TEMPORARY FOR TESTING - set a device address, ENABLE UPNP before
   * receiving MSearch reqs. */
  ewuSsdpDeviceIPAddress(TRUE);
#endif /* EW_CONFIG_OPTION_UPNP */

#ifdef EMWEB_MAX_IDLE
  /* initialize idle time base value */
  lastTime = time(NULL);
#endif /* EMWEB_MAX_IDLE */

  cliDevshellInit();

/*LVL7_P0006 start*/

  {
    /*
      L7_int32 on = 1;
    */
    L7_int32 i;
    L7_int32 found;
    /*
      L7_int32 tmp;
    */
    EwaNetHandle connection;

  /* PTin removed: serial port */
  #if (L7_SERIAL_COM_ATTR)
    struct termios tio;

    tcgetattr(CLI_SERIAL_HANDLE_NUM, &tio);

    tio.c_iflag &= ~(ISTRIP|INLCR|IGNCR|ICRNL);
    tio.c_lflag &= ~(ECHO|ECHONL|ICANON);
    tio.c_cc[VSUSP] = _POSIX_VDISABLE;
    /*
    Defined in man pages but not in .h file
    tio.c_cc[VDSUSP] = _POSIX_VDISABLE;
    */
    tcflush(CLI_SERIAL_HANDLE_NUM, TCIFLUSH);
    tcsetattr(CLI_SERIAL_HANDLE_NUM,TCSANOW, &tio);
  #endif

    setvbuf( stdin, 0, _IONBF, BUFSIZ );
    setvbuf( stdout,0, _IONBF, BUFSIZ );

    connection = (EwaNetHandle) ewaAlloc(sizeof(EwaNetHandle_t));
    memset(connection, 0, sizeof(EwaNetHandle_t));
    connection->socket = bspapiConsoleFdGet();

    osapiSleep(1);
    connection->context = ewsNetTelnetStart( connection
                                             ,cliUtil.systemPrompt
                                             ,NULL
                                             ,EWS_TELNET_SERIAL_PORT);

    for (( i = 0 ,found = -1 ); ( ( found == -1 ) && ( i < FD_CLI_DEFAULT_MAX_CONNECTIONS ) ); i++)
    {
      if (Handle[i] == NULL)
      {
        found = i;
      }
    }

    if (found >= 0)
    {
      connection->handleNum = found;

      /*log in the serial connection*/
      connection->logged_in = TRUE;

      Handle[found] = connection;
      ConnectionsActive++;

      cliCurrentHandleSet(connection->handleNum);
      cliCurrentSocketSet(connection->socket);
      cliDevshellAssign();
      dbgConsoleContext = connection->context;
    }
  }

  ewaNetHandleSpecialDiscardObjectAllocate();

  return(L7_SUCCESS);

} /* end L7_ewsPhaseOneInit */

#define EMWEB_TXTCFG_WAKEUP_PIPENAME "/tmp/EmWebTxtCfgWakeup"

#define EMWEB_PIPE_NAME "/tmp/EmWebPipe"

/*
 * This pipe is what other applications write to and EmWeb reads from.
 */
static L7_int emwebPipeFd = -1;

L7_RC_t emwebMessageWrite(emwebMessage_t *message)
{
  ssize_t count;

  if (-1 == emwebPipeFd)
  {
    return L7_NOT_EXIST;
  }

  count = write(emwebPipeFd, (L7_char8 *)message, sizeof(*message));
  if (sizeof(*message) != count)
  {
    L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_CLI_WEB_COMPONENT_ID, "Error writing to pipe \"%s\"", EMWEB_PIPE_NAME);
    return L7_ERROR;
  }

  return L7_SUCCESS;
}


_DLLEXPORT
_EXTERN_EMAIN
int
ewmain(void)
{
  fd_set                read_ready;
  fd_set                write_ready;
  int                   sockstat;
  boolean               pending;        /* some socket has pending xmit */
  EwsStatus             status;         /* status code from calls to server */
  EwaNetHandle          connection;
  int                   s;
  SOCKET                max_socket = 0;
  struct timeval        socket_timeout;
  boolean               transfer;
  EwsContext            transferContext;
  L7_BOOL               http_is_active;
#ifdef L7_CAPTIVE_PORTAL_PACKAGE
  L7_BOOL               cp_http_is_active;
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */
  L7_BOOL               telnet_is_active;
  L7_int32              breakFdWr = -1;
  L7_int32              breakFdRd = -1;
  L7_int32              breakFd = -1;
  emwebMessage_t        emwebMessage;

  osapiPipeCreate (EMWEB_TXTCFG_WAKEUP_PIPENAME, 1, 1);
  osapiPipeOpen (EMWEB_TXTCFG_WAKEUP_PIPENAME, O_RDWR | O_NONBLOCK, 0666, &breakFd);
  breakFdWr = breakFdRd = breakFd;

  if (L7_SUCCESS != osapiPipeCreate(EMWEB_PIPE_NAME, 10, sizeof(emwebMessage))) /* Can hold 10 messages */
  {
    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID, "Unable to create pipe \"%s\"", EMWEB_PIPE_NAME);
  }

  osapiPipeOpen (EMWEB_PIPE_NAME, O_RDWR | O_NONBLOCK, 0666, &emwebPipeFd);
  if (-1 == emwebPipeFd)
  {
    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID, "Unable to open pipe \"%s\"", EMWEB_PIPE_NAME);
  }

  /*
   * Main Loop - process events from the network
   * until we are told to "slow shutdown" and there are
   * no connections active.
   */

  while (cliWebIsReady() != L7_SUCCESS)
  {
    osapiSleep(1);
    osapiTaskYield();
  }

  cliWebAccessSemaGet ();
  for (;!SlowShutdown || ConnectionsActive != 0;)
  {
    breakFd = cliTxtCfgPoll(breakFdWr);
    timeOutGetSemaId();

    http_is_active = http_active;
#ifdef L7_CAPTIVE_PORTAL_PACKAGE
    cp_http_is_active = cp_http_active;
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */
    telnet_is_active = telnet_active;

    /*
     * Run server for outstanding connections
     */
#ifdef EW_CONFIG_OPTION_SCHED
    status = ewsRun();
    if ( status != EWS_STATUS_OK )
    {
      timeOutReturnSemaId();
      EMWEB_ERROR(( "ewsRun() failed: %d\n", status));
      return(L7_FAILURE);
    }
#endif
    transfer = usmDbTransferSuspendMgmtAccessGet(U_IDX); /*Set transfer in progress flag*/
    if (transfer == L7_FALSE)
    {
      transfer = ewaFileDownloadGetProgressGlobal();
    }
    /*
     * Set up FD lists for the select
     */
    FD_ZERO(&read_ready);
    FD_ZERO(&write_ready);
    pending = FALSE;

    if ( !SlowShutdown && ConnectionsActive < MaxConnections )
    {
        if (-1 != emwebPipeFd)
      {
        FD_SET(emwebPipeFd, &read_ready);
        if (max_socket < emwebPipeFd)
        {
          max_socket = emwebPipeFd;
        }
      }

      /* Set the watch-for-read-ready bit for the HTTP listen socket. */
        max_socket = 0;
        if (breakFd != -1 && breakFdRd != -1)
        {
          FD_SET(breakFdRd, &read_ready);
          if (max_socket < breakFdRd) max_socket = breakFdRd;
        }
        if (http_is_active == L7_TRUE)
        {
#ifdef L7_HTTP_V4_BIND
          FD_SET(http_s, &read_ready); /* wake up for a connection request */
          if (max_socket < http_s) max_socket = http_s;
#endif
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
          /* Set the watch-for-read-ready bit for the http6 listen socket. */
          FD_SET(http6_s, &read_ready); /* wake up for a connection request */
          if (max_socket < http6_s) max_socket = http6_s;
#endif
        }

#ifdef L7_CAPTIVE_PORTAL_PACKAGE
      if (cp_http_is_active == L7_TRUE)
      {
      FD_SET(cp_http_s, &read_ready); /* wake up for a connection request */
      if(max_socket < cp_http_s)max_socket = cp_http_s;

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
      FD_SET(cp_http6_s, &read_ready); /* wake up for a connection request */
      if (max_socket < cp_http6_s) max_socket = cp_http6_s;
#endif
      }
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

#ifdef EW_CONFIG_OPTION_TELNET
        /* Set the watch-for-read-ready bit for the Telnet listen socket. */
        if (telnet_is_active == L7_TRUE && transfer == L7_FALSE)
        {
#ifdef L7_TELNET_V4_BIND
          FD_SET(telnet_s, &read_ready); /* wake up for a connection request */
          if (max_socket < telnet_s) max_socket = telnet_s;
#endif
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
          /* Set the watch-for-read-ready bit for the telnet6 listen socket. */
          FD_SET(telnet6_s, &read_ready); /* wake up for a connection request */
          if (max_socket < telnet6_s) max_socket = telnet6_s;
#endif
        }

      if (transfer == L7_FALSE)
      {
        /* Set the watch-for-read-ready bit for the internal ssh listen socket. */
        FD_SET(ssh_s, &read_ready); /* wake up for a connection request */
        if (max_socket < ssh_s) max_socket = ssh_s;
      }
#endif /* EW_CONFIG_OPTION_TELNET */

#ifdef EW_CONFIG_OPTION_SSL_RSA
        if ( ssl_s != 0 )
        {
          FD_SET(ssl_s, &read_ready); /* wake up for a connection request */
          if (max_socket < ssl_s) max_socket = ssl_s;
        }
#endif /* EW_CONFIG_OPTION_SSL_RSA */

#ifdef EW_CONFIG_OPTION_UPNP
        /* Wake up for incoming HTTP/UDP packets for SSDP. */
        FD_SET(upnp_server_s, &read_ready);
        if (max_socket < upnp_server_s)
        {
          max_socket = upnp_server_s;
        }

#ifdef EW_CONFIG_OPTION_UPNP_SSDP_CP
        /* Wake up for incoming HTTP/UDP packets for SSDP M-Search replies. */
        FD_SET(upnp_client_s, &read_ready);
        if (max_socket < upnp_client_s)
        {
          max_socket = upnp_client_s;
        }
#endif /* EW_CONFIG_OPTION_UPNP_SSDP_CP */

#endif /* EW_CONFIG_OPTION_UPNP */

      if (transfer == L7_FALSE)
      {
        FD_SET(bspapiConsoleFdGet() , &read_ready ); /*LVL7_P0006*/
      }
    }
    else
    {
      /*
       * We have the maximum number of connections already active,
       * or we are no longer accepting connections since we are exiting
       * don't wake up for new requests; up to the maximum will queue
       * in TCP in most implementations.
       */
      max_socket = 0;
    }

    /* Scan through all currently active connections. */
      for (s = 0; s < (int) MaxConnections; s++)
      {
        if ( Handle[s] != NULL )
        {
          SOCKET this_socket;
          this_socket = 0;

#ifdef EW_CONFIG_OPTION_IN_FLOW
          if ( ! Handle[s]->in_flow_control )
#endif
          {
            /* This connection is active and is not flow-controlled for
             * incoming data, so set the watch-for-read-ready bit for
             * its fd.
             */
            this_socket = Handle[s]->socket;
            if (this_socket != -1)
            {
              if ((Handle[s]->connection_type == EW_CONNECTION_HTTP || Handle[s]->connection_type == EW_CONNECTION_HTTPS) || (transfer == L7_FALSE))
              {
                FD_SET( this_socket, &read_ready );
              }
            }
          }

          if (    Handle[s]->pending_xmit != EWA_NET_BUFFER_NULL
#ifdef EW_CONFIG_OPTION_CLIENT
                  || Handle[s]->connect_pending
#endif
             )
          {
            /* This connection is active and has data buffered to be
             * sent (it is flow-controlled for outgoing data),
             * so set the watch-for-write-ready bit for its fd.
             */
            this_socket = Handle[s]->socket;
            if ((Handle[s]->connection_type == EW_CONNECTION_HTTP || Handle[s]->connection_type == EW_CONNECTION_HTTPS) || (transfer == L7_FALSE))
            {
              FD_SET( this_socket, &write_ready );
            }
            pending = TRUE;
          }

          /* If OBT is Active...  */
          if (Handle[s]->context->obtActive == L7_TRUE)
          {
            if (transfer == L7_FALSE)
            {
              FD_SET( Handle[s]->context->obtSocket, &read_ready );
            }

            /* keep the max socket value in this_socket */
            if ( this_socket < Handle[s]->context->obtSocket )
            {
              this_socket = Handle[s]->context->obtSocket;
            }
          }

          if ( this_socket > max_socket )
          {
            max_socket = this_socket;
          }
        }
      }

    /*
     * The timeout allows us to detect idle connections and trigger timing
     * events.
     */
#ifdef EW_CONFIG_OPTION_UPNP
    socket_timeout.tv_sec = ewaTimerNextTimeout();
    if (EMWEB_MAX_IDLE < socket_timeout.tv_sec)
    {
      socket_timeout.tv_sec = EMWEB_MAX_IDLE;
    }
#else /* EW_CONFIG_OPTION_UPNP */
    socket_timeout.tv_sec = EMWEB_MAX_IDLE;
#endif /* EW_CONFIG_OPTION_UPNP */
    socket_timeout.tv_usec = 0;

#ifdef EMWEB_SANITY
    if (isHandleTableInvalid())
    {
      EMWEB_WARN(("Handle[] entries do not match ConnectionsActive\n"));
    }
#endif /* EMWEB_SANITY */
    ClearErrno();

/* lvl7_P0006 start */
    transferContext = usmDbTransferContextGet(U_IDX);
    if ((transfer != L7_FALSE) && (transferContext != L7_NULL))
    {
      struct timeval        tmout;
      /* EmWebWakeupMsg dummy = 0;  LVL7_P0006 unused ... compiler warning */  /* we don't care about content */

      tmout.tv_sec = 3;    /* LVL7 set timeout to 3 second */
      tmout.tv_usec = 0;

      cliWebAccessSemaFree ();
      sockstat = select( max_socket+1
                         ,FDSET_CAST(&read_ready)
                         ,FDSET_CAST(&write_ready)
                         ,NULL
                         ,&tmout
                       );
      cliWebAccessSemaGet ();

      if (sockstat >= 0)
      {
        EwsContext transferContext = usmDbTransferContextGet(U_IDX);
        if (transferContext && transferContext->schedulingState == ewsContextSuspended)
        {
          ewsResume(transferContext, EWA_STATUS_OK_YIELD);
        }
      }
    }
    else
    {
      cliWebAccessSemaFree ();
      sockstat = select( max_socket+1
                         ,FDSET_CAST(&read_ready)
                         ,FDSET_CAST(&write_ready)
                         ,NULL
                         ,&socket_timeout
                       );
      cliWebAccessSemaGet ();
    }
    /* lvl7_P0006 end */

    if ( sockstat >= 0 )
    {
      /*
       * Check for request for action on behalf of another task.
       */
      if (FD_ISSET(emwebPipeFd, &read_ready))
      {
        if (0 > read(emwebPipeFd, (L7_char8 *)&emwebMessage, sizeof(emwebMessage)))
        {
          L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_CLI_WEB_COMPONENT_ID,
                  "Error reading from pipe \"%s\"", EMWEB_PIPE_NAME);
        }
        else
        {
          switch (emwebMessage.msgType)
          {
            case L7_EMWEBMSG_DO_CALLBACK:
              (emwebMessage.CbFuncPtr)(emwebMessage.pContext);
              break;

            default:
              L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_CLI_WEB_COMPONENT_ID,
                      "Received unknown message type %u", emwebMessage.msgType);
              break;
          }
        }
      }

      if(breakFd != -1 && breakFdRd != -1 && FD_ISSET(breakFdRd, &read_ready))
      {
        int ch = 0;
        if(0 > read(breakFdRd, &ch, 1)){}
      }
      /*
       * If the HTTP listen socket is read-ready, it means that there
       * is an incoming HTTP connection request.
       */
      if (http_is_active == L7_TRUE)
      {
        if ((ConnectionsActive < MaxConnections ) &&
            ( FD_ISSET(http_s, &read_ready)))
        {
          EMWEB_TRACE(("connection request\n"));

          /*
           * Set up new connection with the server
           */
          connection = ewaNewConnection( http_s );
      if (connection)
      {
        connection->listeningPort = EMWEB_LISTEN_PORT;
      }
        }
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
        /*
         * If the HTTP6 listen socket is read-ready, it means that there
         * is an incoming HTTP connection request.
         */
        if ((ConnectionsActive < MaxConnections) &&
            (FD_ISSET(http6_s, &read_ready)))
        {
          EMWEB_TRACE(("connection request\n"));

          /*
           * Set up new connection with the server
           */
          connection = ewaNewConnection( http6_s );
          if ( connection != NULL )
          {
            connection->listeningPort = EMWEB_LISTEN_PORT;
          }
        }
#endif /* L7_IPV6_PACKAGE */
      }

#ifdef L7_CAPTIVE_PORTAL_PACKAGE
      /*
       * If new CP connection request
       */
      if (cp_http_is_active == L7_TRUE)
      {
        if (   ( ConnectionsActive < MaxConnections )
             && ( FD_ISSET(cp_http_s, &read_ready) )
           )
        {

          EMWEB_TRACE(("HTTP connection request\n"));
          /*
           * Set up new connection with the server
           */
          connection = ewaNewConnection( cp_http_s );

          if ( connection != NULL )
          {
            EMWEB_TRACE(( "Open %p\n", connection ));
            connection->listeningPort = cp_http_port;
          }
        }
      }

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
      if (   ( ConnectionsActive < MaxConnections )
               && ( FD_ISSET(cp_http6_s, &read_ready) )
           )
      {
        EMWEB_TRACE(("HTTP-V6 connection request\n"));
        /*
         * Set up new connection with the server
        */
        connection = ewaNewConnection( cp_http6_s );
        if ( connection != NULL )
          {
            EMWEB_TRACE(( "Open %p\n", connection ));
            connection->listeningPort = cp_http_port;
          }
        }
#endif
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */


#ifdef EW_CONFIG_OPTION_TELNET
      /*
       * If the Telnet listen socket is read-ready, it means that there
       * is an incoming Telnet connection request.
       */
      if (telnet_is_active == L7_TRUE)
      {
        if (   ( ConnectionsActive < MaxConnections )
               && ( FD_ISSET(telnet_s, &read_ready) )
           )
        {
          EMWEB_TRACE(("telnet connection request\n"));

          /*
           * Set up new connection with the server
           */
          connection = ewaNewConnection( telnet_s );
        }
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
        /*
         * If the telnet6_s listen socket is read-ready, it means that there
         * is an incoming telnet6_s connection request.
         */
        if (   ( ConnectionsActive < MaxConnections )
               && ( FD_ISSET(telnet6_s, &read_ready) )
           )
        {
          EMWEB_TRACE(("telnet6 connection request\n"));

          /*
           * Set up new connection with the server
           */
          connection = ewaNewConnection( telnet6_s );
        }
#endif /* L7_IPV6_PACKAGE */
      }

      /*
       * If the internal ssh listen socket is read-ready, it means that there
       * is an incoming internal ssh connection request.
       */
      if ((ConnectionsActive < MaxConnections)
          && (FD_ISSET(ssh_s, &read_ready)))
      {
        EMWEB_TRACE(("internal ssh connection request\n"));

        /*
         * Set up new connection with the server
         */
        connection = ewaNewSSHConnection(ssh_s);
      }
#endif /* EW_CONFIG_OPTION_TELNET */

#if defined (EW_CONFIG_OPTION_SSL_RSA)
      /*
       * If the SSL listen socket is read-ready, it means that there
       * is an incoming SSL connection request.
       */
      if (   ( ConnectionsActive < MaxConnections )
             && ( FD_ISSET(ssl_s, &read_ready) )
         )
      {
        connection = ewaSSLNewConnection( ssl_s );
      }

#endif /* EW_CONFIG_OPTION_SSL_RSA */

#if defined (EW_CONFIG_OPTION_UPNP)
      /*
       * If the UPnP SSDP listen socket is read-ready, it means that there
       * is an incoming SSDP (UDP) packet.
       */
      if (   ( ConnectionsActive < MaxConnections )
             && ( FD_ISSET(upnp_server_s, &read_ready) )
         )
      {
        connection = ewaSsdpNewConnection( upnp_server_s, FALSE, TRUE,
                                           (EwsContext) NULL );
        /* Read the incoming packet.
         * Read data into 'buffer', possibly chaining additional
         * buffers to it to hold all the data.
         * Then send the data to the Server.
         * We do this outside of the NetReceiveLoop() which
         * is used to scan tcp connections so that we will
         * not lose the UDP data.
         */
        udpRecvData(connection);
      }

#ifdef EW_CONFIG_OPTION_UPNP_SSDP_CP
      /*
       * If the UPnP SSDP M-SEARCH response socket is read-ready, it means
       * that there is an incoming SSDP (UDP) packet.
       */
      if (   ( ConnectionsActive < MaxConnections )
             && ( FD_ISSET(upnp_client_s, &read_ready) )
         )
      {
        connection = ewaSsdpNewConnection( upnp_client_s, FALSE, TRUE,
                                           (EwsContext) NULL );
        /* Read the incoming packet.
         * Read data into 'buffer', possibly chaining additional
         * buffers to it to hold all the data.
         * Then send the data to the Server.
         * We do this outside of the NetReceiveLoop() which
         * is used to scan tcp connections so that we will
         * not lose the UDP data.
         */
        udpRecvData(connection);
      }
#endif /* EW_CONFIG_OPTION_UPNP_SSDP_CP */

#endif /* EW_CONFIG_OPTION_UPNP */

      /*
       * NetReceiveLoop checks for and handles incoming data for all of
       * the sockets for HTTP, Telnet, and SSL connections.
       */
      NetReceiveLoop( &read_ready );

#ifdef EW_CONFIG_OPTION_SCHED_FC
      /*
       * Check for write-ready bits on sockets which have queued output
       * data.
       */
      if ( pending )
      {
        NetTransmitPendingLoop( &write_ready );
      }
#endif /* EW_CONFIG_OPTION_SCHED_FC */

    }
    else /* error returned by select */
    {
      switch ( errno )
      {
#ifdef EMWEB_MAX_IDLE
      case ETIMEDOUT:
        /* this is expected, and dealt with below */
        break;
#endif
#ifdef EMWEB_USE_SIGNALS
      case EINTR:
        break;
#endif

      default:
        /* LVL7 - Closing the socket causes an error in select() */
#ifdef COMMENTED_OUT
        EMWEB_ERROR(( "EmWeb: select() failed: %s\n", strerror(errno)));
#endif /* COMMENTED_OUT */
        break;
      }
    }

#ifdef COMMENTED_OUT
#ifdef EMWEB_MAX_IDLE
    {
      time_t now;
      time_t interval;

      now = time(NULL);
      interval = now - lastTime;
      if ( interval >= EMWEB_MAX_IDLE )
      {
        for ( s = 0; s < (int)MaxConnections; s++ )
        {
          if ( Handle[s] != EWA_NET_HANDLE_NULL  &&
               Handle[s]->context != EWS_CONTEXT_NULL &&
               Handle[s]->socket != -1 &&
               Handle[s]->socket != bspapiConsoleFdGet())
          {
            if ( Handle[s]->idle )
            {
              /* Idle time exceeded - shut it down */
              ewsNetHTTPAbort( Handle[s]->context );
            }
            else
            {
              /*
               * Mark as idle - this will be cleared
               * by either a send or a receive
               */
              Handle[s]->idle = TRUE;
            }
          }
        }
        lastTime = now;
      }
    }
#endif /* EMWEB_MAX_IDLE */
#endif /* COMMENTED_OUT */

    timeOutReturnSemaId();

#ifdef EW_CONFIG_OPTION_UPNP
    /* Check for and execute timer events that have expired. */
    ewaTimerCheck();
#endif /* EW_CONFIG_OPTION_UPNP */

    osapiSleepMSec(20);

  } /* end of Main Loop */

#ifdef EW_CONFIG_OPTION_CLEANUP
  cleanup();       /* bring down the emweb server */
#endif

#ifdef WIN32
  WSACleanup();     /* unload WINSOCK.DLL */
#endif

#ifdef EW_CONFIG_OPTION_UPNP
  /* Close the socket for outgoing UDP data. */
  if (upnp_client_s)
  {
    closesocket(upnp_client_s);
  }
  if (upnp_server_s)
  {
    /* ipMreq was set up earlier in setupOptionSockets() */
    setsockopt (upnp_server_s
                ,IPPROTO_IP
                ,IP_DROP_MEMBERSHIP
                ,(char *)&ipMreq
                ,sizeof (ipMreq));
  }

#endif /* EW_CONFIG_OPTION_UPNP */

  return(0);
}

/*
 * ewaStartSlowShutdown()
 * Call this function to initiate slow server shutdown - don't
 * accept new connections and exit the main loop when all existing
 * connections close
 */
_DLLEXPORT
_EXTERN_EMAIN
void ewaStartSlowShutdown( void )
{
  SlowShutdown = TRUE;      /* see main emweb task loop */
}



/* ################################################################ */
/*                       Network Connections                        */
/* ################################################################ */

static
void ewaInitConnections( int maxConnections )
{

  MaxConnections = (  ( maxConnections <= 0 )
                      ? EMWEB_MAX_CONNECTIONS
                      : maxConnections
                   );

  ConnectionsActive = 0;
  ConnectionsActiveTelnet = 0;  /* LVL7_P0006 */
  ConnectionsActiveSSH = 0;  /* LVL7_P0006 */

  Handle = (EwaNetHandle*) ewaAlloc( MaxConnections * sizeof( EwaNetHandle ) );

  if ( Handle != NULL )
  {
    memset( Handle, 0, sizeof( EwaNetHandle ) * MaxConnections );
  }
  else
  {
    EMWEB_ERROR(( "EmWeb: Handle table allocation failed" ));
  }
}
static
EwaNetHandle ewaNewConnection( SOCKET master_socket )
{
  EwaNetHandle connection;
  uintf i;
  int32 found, found_check= -1;
  EW_SIZE_T addrlen = sizeof(ew_sockaddr_union_t);
  int accept_socket;
  ew_sockaddr_union_t peer;
#ifdef EMWEB_LOOKUP_HOST
  struct hostent *hostentP;
#endif /* EMWEB_LOOKUP_HOST */
  L7_uint32 userIndex;   /* LVL7_P0006 */
  L7_uint32 unit, web_mode;
  L7_inet_addr_t remote;
  int                 numBytes = 0;
  L7_uint32           peerAddress;
  ew_sockaddr_union_t peer2;
  ew_sockaddr_union_t sslhost;
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
  char *rem_v4_v6_map;
#endif /* IPV6 */
  char buf[16];


    /* Find an empty slot in the Handle table */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
   if ((master_socket == telnet_s) ||
       (master_socket == telnet6_s))
#else
   if (master_socket == telnet_s)
#endif
    {
      for ((i = 0,found_check = -1);((found_check == -1)&& (i < FD_CLI_DEFAULT_MAX_CONNECTIONS ));
            i++)
        {
          if ( Handle[i] == NULL )
          {
            found_check = i;
            break;
          }
        }
    }
    else
    {
      for ((i = FD_CLI_DEFAULT_MAX_CONNECTIONS ,found_check = -1 );
           ((found_check == -1) && (i< MaxConnections)); i++)
        {
          if ( Handle[i] == NULL )
          {
            found_check = i;
            break;
          }
        }
    }

    /* No handle is free to allocate memory for New Connection */
    if(found_check < 0)
    {
      return NULL;
    }

  /*
   * Accept connection
   */
  accept_socket = accept( master_socket
                          ,(struct sockaddr*)&peer
                          ,&addrlen
                        );

  /* Allocate and initialize a connection */
  connection = (EwaNetHandle) ewaAlloc( sizeof( EwaNetHandle_t ) );
  memset(buf,0x00,16);
  if ( connection != NULL )
  {
    memset( connection, 0, sizeof( EwaNetHandle_t ) );
    /* Make sure pointer to application data is cleared.  (0 bytes are
     * not necessarily NULL pointer.) */
    connection->app_pointer = NULL;

    connection->socket = accept_socket;
    connection->lastTime = time(NULL);

    if (!SOCKET_IS_INVALID( connection->socket ))
    {
      /* Begin LVL7 2478 */
      ew_sockaddr_union_t localAddr;
      /* End LVL7 2478 */
#ifdef EWA_LOG_HOOK
      uint32 peerAddr;

#ifdef EMWEB_LOOKUP_HOST
      hostentP = gethostbyaddr((char *)&peer.sin_addr
                               ,4
                               ,AF_INET);
      if (hostentP != NULL)
      {
        memcpy(connection->sourceAddrStr
               ,hostentP->h_name
               ,sizeof(connection->sourceAddrStr));
      }
      else
#endif /* EMWEB_LOOKUP_HOST */  /* tbd IPV6 many */
      {
        peerAddr = osapiNtohl(peer.u.sa4.sin_addr.s_addr);
        sprintf( connection->sourceAddrStr
                 ,"%d.%d.%d.%d"
                 ,(int)((peerAddr >> 24) & 0x000000ffL)
                 ,(int)((peerAddr >> 16) & 0x000000ffL)
                 ,(int)((peerAddr >> 8)  & 0x000000ffL)
                 ,(int)((peerAddr)       & 0x000000ffL)
               );
      }

#endif /* EWA_LOG_HOOK */
      memcpy(&connection->peer, &peer, addrlen);

      if(peer.u.sa.sa_family == AF_INET6){
          if(L7_IP6_IS_ADDR_V4MAPPED(&peer.u.sa6.sin6_addr))
          {
              remote.family = L7_AF_INET;
              remote.addr.ipv4.s_addr = L7_IP6_ADDR_V4MAPPED(&peer.u.sa6.sin6_addr);
              peer.u.sa4.sin_addr.s_addr = remote.addr.ipv4.s_addr;

          }
          else
          {
              remote.family = L7_AF_INET6;
              remote.addr.ipv6 = *(L7_in6_addr_t *)&peer.u.sa6.sin6_addr;
          }
      }
      else{
          remote.family = L7_AF_INET;
      remote.addr.ipv4.s_addr = peer.u.sa4.sin_addr.s_addr;
      }


#if ( defined(HAVE_IOCTL_FIONBIO) \
              && defined(EW_CONFIG_OPTION_SCHED_FC) \
              && ! defined(WIN32) \
              && ! defined(_WIN32_WCE) \
              )

      /* Begin LVL7 2478 */
      /*
       * Get the text form of the IP address for ewaNetLocalHostName
       * For each connection it is necessary to get the IP address
       * of the local side of the connection, so that when submit
       * pages are responded to, the switch will have the proper IP
       * address to use in the response.
       */
      addrlen = sizeof( localAddr );
      if ((getsockname(connection->socket
                      ,(struct sockaddr*)&localAddr
                      ,&addrlen)))
      {
        connection->localName[0] ='\000';
        EMWEB_WARN(("Can't read local socket address\n"));
      }
      else
      {
        peerAddress = osapiHtonl(peer.u.sa4.sin_addr.s_addr);
        if (peerAddress == L7_SSLT_UNSECURE_SERVER_ADDR && !(master_socket == telnet_s
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
             || master_socket == telnet6_s
#endif
             ))
        {
          numBytes = read(connection->socket, &peer2, sizeof(ew_sockaddr_union_t));
          if (numBytes < 0)
          {
            close(connection->socket);
            ewaFree(connection);
            connection = NULL;
            return connection;
          }
          memcpy(&connection->peer, &peer2, sizeof(ew_sockaddr_union_t));

          numBytes = read(connection->socket, &sslhost, sizeof(ew_sockaddr_union_t));
          if (numBytes < 0)
          {
            close(connection->socket);
            ewaFree(connection);
            connection = NULL;
            return connection;
          }
          memcpy(&localAddr, &sslhost, sizeof(ew_sockaddr_union_t));
          connection->connection_type = EW_CONNECTION_HTTPS;
        }
        else
        {
          memcpy( &connection->peer, &peer, sizeof(ew_sockaddr_union_t));
          connection->connection_type = EW_CONNECTION_HTTP;

        }

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)

        if(localAddr.u.sa.sa_family == AF_INET6){
            inet_ntop(localAddr.u.sa.sa_family, (void *)&((struct sockaddr_in6 *)&localAddr)->sin6_addr,
                      connection->localName, LOCAL_NAME_MAX);
       if((peer.u.sa.sa_family == AF_INET6) && (L7_IP6_IS_ADDR_V4MAPPED(&peer.u.sa6.sin6_addr))){
            rem_v4_v6_map=strrchr(connection->localName,':');
            strcpy(buf,++rem_v4_v6_map);
            memset(connection->localName,0,sizeof(connection->localName));
            strcpy(connection->localName,buf);
        }
    }
        else
            inet_ntop(localAddr.u.sa.sa_family, (void *)&((struct sockaddr_in *)&localAddr)->sin_addr,
                      connection->localName, LOCAL_NAME_MAX);
#else
        inet_ntop(localAddr.u.sa.sa_family, (void *)&((struct sockaddr_in *)&localAddr)->sin_addr,
                  connection->localName, LOCAL_NAME_MAX);
#endif

      }
      /* End LVL7 2478 */

      /*
       * Set for non-blocking I/O
       */

      /* LVL7_P0006 start */
      {
      /* PTin removed: serial port */
      #if (L7_SERIAL_COM_ATTR)
        struct termios tio;

        tcgetattr(connection->socket, &tio);

        tio.c_iflag &= ~(ISTRIP|INLCR|IGNCR|ICRNL);
        tio.c_lflag &= ~(ECHO|ECHONL|ICANON);
        tio.c_cc[VSUSP] = _POSIX_VDISABLE;
        /*
        Defined in man pages but not in .h file
        tio.c_cc[VDSUSP] = _POSIX_VDISABLE;
        */

        tcflush(connection->socket, TCIFLUSH);
        tcsetattr(connection->socket, TCSANOW, &tio);
      #endif
      }
      /* LVL7_P0006 end */

      osapiSocketNonBlockingModeSet(connection->socket, L7_TRUE);

#else
      /* In WIN32, nonblocking mode with LINGER turned on causes
       * closesocket() to not close immediately.
       */
#endif /* HAVE_IOCTL_FIONBIO && EW_CONFIG_OPTION_SCHED_FC && ! WIN32 */
      /*
       * Notify EmWeb/Server
       */
#ifdef EW_CONFIG_OPTION_TELNET
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
      if ((master_socket == telnet_s) ||
          (master_socket == telnet6_s))
#else
      if (master_socket == telnet_s)
#endif
      {
    connection->connection_type = EW_CONNECTION_TELNET;

        /*to stop new telnet sessions if not mgmt unit*/
        if (cliIsCurrUnitMgmtUnit() != L7_TRUE)
        {
          send( connection->socket, cliutilGetTelnetDisabledError(), strlen(cliutilGetTelnetDisabledError()), 0 );
          close( connection->socket );
          ewaFree( connection );
          connection = NULL;
          return connection;
        }
        /*lvl7_P0006 Start*/
        else if (cliWebGetSystemTelnetNewSessions() == L7_DISABLE)
        {
          send( connection->socket, cliutilGetTelnetDisabledError(), strlen(cliutilGetTelnetDisabledError()), 0 );
          close( connection->socket );
          ewaFree( connection );
          connection = NULL;
          return connection;
        }
        else if (ConnectionsActiveTelnet >= cliWebGetSystemTelnetNumSessions())
        {                                                                 /* has be be >= because it is not incremented until after this call */
          send( connection->socket, cliutilGetMaxConnectionsError(), strlen(cliutilGetMaxConnectionsError()), 0 );
          L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                  "EMWEB (Telnet): Max number of Telnet login sessions exceeded\n");
          close( connection->socket );
          ewaFree( connection );
          connection = NULL;
          return connection;
        }
        else
        {
          /* Display the banner */
          send(connection->socket, cliWebCfgData.cliBanner, strlen(cliWebCfgData.cliBanner), 0 );
          connection->context = ewsNetTelnetStart( connection
                                                   ,cliUtil.systemPrompt /* LVL7_P0006 */
                                                   ,cliUtil.loginUserPrompt    /* LVL7_P0006 */
                                                   ,0 );
        } /* lvl7_P0006 */
      }
      else
#endif /* EW_CONFIG_OPTION_TELNET */
      {
      connection->context = ewsNetHTTPStart( connection );
      EMWEB_TRACE(("ewaNewConnection: setting connection(%p)->context(%p) from return of ewsNetHTTPStart\n",
                     connection, connection->context));
      }
      if (connection->context != EWS_CONTEXT_NULL)
      {
        /*
         * All the setup is complete, so insert this in
         * the Handle table and count the connection.
         */

        connection->context->allow_http = TRUE;
        if (usmDbUnitMgrMgrNumberGet(&unit) == L7_SUCCESS)
        {
          if (usmDbSwDevCtrlWebMgmtModeGet(unit, &web_mode) == L7_SUCCESS)
          {
            if (web_mode != L7_ENABLE)
            {
              EwaNetHandle net = ewsContextNetHandle(connection->context);
              if ((net == NULL) ||
                  (net->connection_type != EW_CONNECTION_HTTPS))
                connection->context->allow_http = FALSE;
            }
          }
        }


        /* Find an empty slot in the Handle table */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
        if ((master_socket == telnet_s) ||
          (master_socket == telnet6_s))
#else
        if (master_socket == telnet_s)
#endif
        {
          for ((i = 0,found = -1);((found == -1)&& (i < FD_CLI_DEFAULT_MAX_CONNECTIONS ));
              i++)
          {
            if ( Handle[i] == NULL )
            {
              found = i;
              break;
            }
          }
        }
        else
        {
          for ((i = FD_CLI_DEFAULT_MAX_CONNECTIONS ,found = -1 );
                 ((found == -1) && (i< MaxConnections)); i++)
          {
            if ( Handle[i] == NULL )
            {
              found = i;
              break;
            }
          }
        }

        if ( found >= 0 )
        {
          connection->handleNum = found;     /* LVL7_P0006 start */

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
          if ((master_socket == telnet_s) ||
          (master_socket == telnet6_s))
#else
          if (master_socket == telnet_s)
#endif
          {
          cliCurrentHandleSet(connection->handleNum);
            cliInitConnection(connection->handleNum);
            usmDbLoginSessionLogin(U_IDX, &userIndex);
            cliLoginSessionIndexSet(userIndex);

#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
        {
                 usmDbLoginSessionRemoteIpAddrSet(U_IDX,
                                      cliLoginSessionIndexGet(),&remote);
        }
#else
            usmDbLoginSessionRemoteIpAddrSet(U_IDX,
                                      cliLoginSessionIndexGet(), &remote);
#endif
            usmDbLoginSessionTypeSet(U_IDX, cliLoginSessionIndexGet(), L7_LOGIN_TYPE_TELNET);
            usmDbLoginSessionUserStorageSet(U_IDX, cliLoginSessionIndexGet(), connection->context);
            cliCommon[connection->handleNum].telnetConnection = TRUE;
          }
          else
          {
            /*
            usmDbLoginSessionLogin(U_IDX, &userIndex);
            cliUserLoginSessionIndexSet(userIndex);
#ifdef L7_IPV6_PACKAGE
        {
                 usmDbLoginSessionRemoteIpAddrSet(U_IDX,
                                      cliLoginSessionIndexGet(),&remote);
        }
#else
            usmDbLoginSessionRemoteIpAddrSet(U_IDX,
                             cliUserLoginSessionIndexGet(),&remote);
#endif
            cliCommon[connection->handleNum].telnetConnection = FALSE;
            */
          } /* LVL7_P0006 end */

          Handle[found] = connection;
          ConnectionsActive++;

          /* LVL7_P0006 start */
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
          if ((master_socket == telnet_s) ||
          (master_socket == telnet6_s))
#else
          if (master_socket == telnet_s)
#endif
          {
            ConnectionsActiveTelnet++;
          }
          /* LVL7_P0006 end */

          EMWEB_TRACE(( "Open %p %d\n"
                        ,connection
                        ,connection->socket
                      ));
#if defined (EW_CONFIG_OPTION_SSL_RSA)
          connection->ssl_connection_flg = FALSE;
#endif
#if defined (EW_CONFIG_OPTION_UPNP)
          connection->upnp_udp_connection_flg = FALSE;
#endif
          if(FALSE == ewaConnectionInit( connection ))
          {
            ewaNetHTTPEnd( connection );
            return NULL;
          }
        }
        else
        {
          /*EMWEB_ERROR(( "EmWeb: Handle table overflow @%d", __LINE__ ));
          ERROR_EXIT;*/
           L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                   "Handle table overflow");
           close(connection->socket);
           ewaConnectionFinish(connection);
           ewaFree(connection->context);
           connection->context = NULL;
           ewaFree(connection);
           connection = NULL;
        }
      }
      else
      {
        EMWEB_WARN(( "ewsNetHTTPStart() refused connection"));
        if (0 !=closesocket( connection->socket ))
        {
          EMWEB_WARN(("ewsNetHTTPStart() closesocket failed for socket= %d, errno=%d\n"
                      ,connection->socket
                      ,errno));
        }
        ewaFree( connection );
        connection = NULL;
      }
    }
    else
    {
      /* Error on the accept call */
      if (master_socket != 0)
      {
         sprintf(sockErr, "ewaNewConnection EmWeb socket accept() failed: %s\n", strerror(errno));
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                 "%s",sockErr);
      }
      ewaFree( connection );
      connection = NULL;
    }
  }
  else
  {
    /* Error allocating the net handle */
    EMWEB_ERROR(( "EmWeb: memory allocation failed @ %s:%d"
                  ,__FILE__
                  ,__LINE__ ));
    ERROR_EXIT;
  }

  return connection;
}


static
EwaNetHandle ewaNewSSHConnection(SOCKET master_socket)
{
  EwaNetHandle connection;
  uintf i;
  int32 found;
  EW_SIZE_T addrlen = sizeof(ew_sockaddr_union_t);
  int accept_socket;
  ew_sockaddr_union_t peer, peer2;
#ifdef EMWEB_LOOKUP_HOST
  struct hostent *hostentP;
#endif /* EMWEB_LOOKUP_HOST */
  struct timeval tmout;
  fd_set read_ready;
  int rc;

  L7_uint32 userIndex;
  char username[L7_LOGIN_SIZE];
  char password[L7_PASSWORD_SIZE];
  char challengePhrase[L7_USER_MGR_MAX_CHALLENGE_PHRASE_LENGTH + 1];
  L7_uint32 accessLevel;

  uint32 peerAddr2;
  L7_inet_addr_t remote;

  /*
  * Accept connection
  */
  accept_socket = accept(master_socket, (struct sockaddr*)&peer,
                         (EW_SIZE_T *) &addrlen);

  /* Allocate and initialize a connection */
  connection = (EwaNetHandle) ewaAlloc(sizeof(EwaNetHandle_t));

  if (connection != NULL)
  {
    memset(connection, 0, sizeof(EwaNetHandle_t));

    /*
    Make sure pointer to application data is cleared.  (0 bytes are
    not necessarily NULL pointer.)
    */
    connection->app_pointer = NULL;

    connection->socket = accept_socket;

    if (!SOCKET_IS_INVALID(connection->socket))
    {
      struct sockaddr_in localAddr;

#ifdef EWA_LOG_HOOK
      uint32 peerAddr;

#ifdef EMWEB_LOOKUP_HOST
      hostentP = gethostbyaddr((char *)&peer.sin_addr, 4, AF_INET);

      if (hostentP != NULL)
      {
        memcpy(connection->sourceAddrStr, hostentP->h_name,
               sizeof(connection->sourceAddrStr));
      }
      else
#endif /* EMWEB_LOOKUP_HOST */
      {
        peerAddr = osapiNtohl(peer.sin_addr.s_addr);
        sprintf(connection->sourceAddrStr, "%d.%d.%d.%d",
                (int)((peerAddr >> 24) & 0x000000ffL),
                (int)((peerAddr >> 16) & 0x000000ffL),
                (int)((peerAddr >> 8)  & 0x000000ffL),
                (int)((peerAddr)       & 0x000000ffL));
      }

#endif /* EWA_LOG_HOOK */

      /*
      memcpy(&connection->peer, &peer, addrlen);
      */

      /*
      Set for non-blocking I/O
      */

      {
      /* PTin removed: serial port */
      #if (L7_SERIAL_COM_ATTR)
        struct termios tio;

        tcgetattr(connection->socket, &tio);

        tio.c_iflag &= ~(ISTRIP|INLCR|IGNCR|ICRNL);
        tio.c_lflag &= ~(ECHO|ECHONL|ICANON);
        tio.c_cc[VSUSP] = _POSIX_VDISABLE;
        /*
        Defined in man pages but not in .h file
        tio.c_cc[VDSUSP] = _POSIX_VDISABLE;
        */

        tcflush(connection->socket, TCIFLUSH);
        tcsetattr(connection->socket, TCSANOW, &tio);
      #endif
      }

#if (defined(HAVE_IOCTL_FIONBIO) && defined(EW_CONFIG_OPTION_SCHED_FC) \
      && ! defined(WIN32) && ! defined(_WIN32_WCE))

      osapiSocketNonBlockingModeSet(connection->socket, L7_TRUE);

      /* Begin LVL7 2478 */
      /*
       * Get the text form of the IP address for ewaNetLocalHostName
       * For each connection it is necessary to get the IP address
       * of the local side of the connection, so that when submit
       * pages are responded to, the switch will have the proper IP
       * address to use in the response.
       */

      addrlen = sizeof(localAddr);

      if (getsockname(connection->socket,
                      (struct sockaddr*)&localAddr, &addrlen))
      {
        connection->localName[0] ='\000';
        EMWEB_WARN(("Can't read local socket address\n"));
      }
      else
      {
    /* internal connection, always v4 */
        inet_ntop(localAddr.sin_family, (void *)&((struct sockaddr_in *)&localAddr)->sin_addr,
                  connection->localName, LOCAL_NAME_MAX);
      }
      /* End LVL7 2478 */

#else
      /* In WIN32, nonblocking mode with LINGER turned on causes
       * closesocket() to not close immediately.
       */
#endif /* HAVE_IOCTL_FIONBIO && EW_CONFIG_OPTION_SCHED_FC && ! WIN32 */

      /*
      Username and password must be read from the connection first
      */

      tmout.tv_sec = 100;    /* LVL7 set timeout to 3 second */
      tmout.tv_usec = 0;

      memset(&read_ready, 0, sizeof(read_ready));
      if(!usmDbTransferInProgressGet(U_IDX));
      FD_SET(connection->socket, &read_ready);

      if ((rc = select(connection->socket + 1,
                       FDSET_CAST(&read_ready),
                       NULL, NULL, &tmout)) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: select of connect socket failed %d, %s\n",
                errno, strerror(errno));
        send(connection->socket, "Could not use connected socket",
             strlen("Could not use connected socket"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }
      else if (rc == 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: select of connect socket timeout\n");
        send(connection->socket, "Could not use connected socket",
             strlen("Could not use connected socket"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }
      /*
      fprintf(stderr, "ewaNewSSHConnection: select returned %d\n", rc);
      */

      if (read(connection->socket, &peer2, sizeof(ew_sockaddr_union_t)) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: read of peer info failed %d, %s\n",
                errno, strerror(errno));
        send(connection->socket, "Could not read peer info",
             strlen("Could not read peer info"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }

      memcpy(&connection->peer, &peer2, addrlen);
      if(peer2.u.sa.sa_family == AF_INET6){
          if(L7_IP6_IS_ADDR_V4MAPPED(&peer2.u.sa6.sin6_addr))
      {
              remote.family = L7_AF_INET;
          remote.addr.ipv4.s_addr = L7_IP6_ADDR_V4MAPPED(&peer2.u.sa6.sin6_addr);
          }
      else
      {
              remote.family = L7_AF_INET6;
          remote.addr.ipv6 = *(L7_in6_addr_t *)&peer2.u.sa6.sin6_addr;
          }
      }
      else{
          remote.family = L7_AF_INET;
      remote.addr.ipv4.s_addr = peer2.u.sa4.sin_addr.s_addr;
      }


      peerAddr2 = osapiNtohl(peer2.u.sa4.sin_addr.s_addr);

      /*
      fprintf(stderr, "ewaNewSSHConnection: read peer \"0x%08x\"\n", peerAddr2);
      */

      tmout.tv_sec = 100;    /* LVL7 set timeout to 3 second */
      tmout.tv_usec = 0;

      memset(&read_ready, 0, sizeof(read_ready));
      FD_SET(connection->socket, &read_ready);

      if ((rc = select(connection->socket + 1,
                       FDSET_CAST(&read_ready),
                       NULL, NULL, &tmout)) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: select 2 of connect socket failed %d, %s\n",
                errno, strerror(errno));
        send(connection->socket, "Could not use connected socket",
             strlen("Could not use connected socket"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }
      else if (rc == 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: select 2 of connect socket timeout\n");
        send(connection->socket, "Could not use connected socket",
             strlen("Could not use connected socket"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }

      if (read(connection->socket, username, L7_LOGIN_SIZE) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: read of username failed %d, %s\n",
                errno, strerror(errno));
        send(connection->socket, "Could not read username",
             strlen("Could not read username"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }
      /*
      fprintf(stderr, "ewaNewSSHConnection: read username \"%s\"\n", username);
      */

      tmout.tv_sec = 100;    /* LVL7 set timeout to 3 second */
      tmout.tv_usec = 0;

      memset(&read_ready, 0, sizeof(read_ready));
      FD_SET(connection->socket, &read_ready);

      if ((rc = select(connection->socket + 1,
                       FDSET_CAST(&read_ready),
                       NULL, NULL, &tmout)) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: select 3 of connect socket failed %d, %s\n",
                errno, strerror(errno));
        send(connection->socket, "Could not use connected socket",
             strlen("Could not use connected socket"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }
      else if (rc == 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: select 3 of connect socket timeout\n");
        send(connection->socket, "Could not use connected socket",
             strlen("Could not use connected socket"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }

      if (read(connection->socket, password, L7_PASSWORD_SIZE) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: read of password failed %d, %s\n", errno, strerror(errno));
        send(connection->socket, "Could not read password",
             strlen("Could not read password"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }
      /*
      fprintf(stderr, "ewaNewSSHConnection: read password \"%s\"\n", password);
      */
      if (read(connection->socket, challengePhrase, (L7_USER_MGR_MAX_CHALLENGE_PHRASE_LENGTH + 1)) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: read of challenge phrase failed %d, %s\n", errno, strerror(errno));
        send(connection->socket, "Could not read challenge", strlen("Could not read challenge"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }

      if (read(connection->socket, (char*)&accessLevel, sizeof(accessLevel)) < 0)
      {
        fprintf(stderr, "ewaNewSSHConnection: read of accessLvl failed %d, %s\n", errno, strerror(errno));
        send(connection->socket, "Could not read accessLvl", strlen("Could not read accessLvl"), 0);
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }

      /*
       * Notify EmWeb/Server
       */
#ifdef EW_CONFIG_OPTION_TELNET
#ifdef L7_MGMT_SECURITY_PACKAGE
      if (ConnectionsActiveSSH >= cliSshdMaxNumSessionsGet())
#else
      if (ConnectionsActiveSSH >= L7_MAX_SSH_LOGINS)
#endif /* L7_MGMT_SECURITY_PACKAGE */
      {
        /* has be be >= because it is not incremented until after this call */
        send(connection->socket, cliutilGetMaxConnectionsError(),
             strlen(cliutilGetMaxConnectionsError()), 0);
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                "EMWEB (SSH): Max number of SSH login sessions exceeded\n");
        close(connection->socket);
        ewaFree(connection);
        connection = NULL;
        return connection;
      }
      else
      {
        /* Display the banner */
        send(connection->socket, cliWebCfgData.cliBanner, strlen(cliWebCfgData.cliBanner), 0 );
        connection->context =
        ewsNetTelnetStart(connection, cliUtil.systemPrompt,
                          cliUtilGetRootPrompt(), EWS_TELNET_SERIAL_PORT);
      }
#endif /* EW_CONFIG_OPTION_TELNET */

      if (connection->context != EWS_CONTEXT_NULL)
      {
        /*
           All the setup is complete, so insert this in
           the Handle table and count the connection.
         */

        /*
           Find an empty slot in the Handle table
         */

        for ((i = 0, found = -1); ((found == -1) && (i < FD_CLI_DEFAULT_MAX_CONNECTIONS)); i++)
        {
          if (Handle[i] == NULL)
          {
            found = i;
            break;
          }
        }

        if (found >= 0)
        {
          L7_char8 buf[L7_USER_MGR_MAX_CHALLENGE_PHRASE_LENGTH + CLI_MAXSIZE_LOGIN_CHALLENGE_PROMPT + 1];

          connection->handleNum = found;

          cliCurrentHandleSet(connection->handleNum);
          cliInitConnection(connection->handleNum);
          usmDbLoginSessionLogin(U_IDX, &userIndex);
          cliLoginSessionIndexSet(userIndex);
#if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
          {
            usmDbLoginSessionRemoteIpAddrSet(U_IDX,
                cliLoginSessionIndexGet(),&remote);
          }
#else
          usmDbLoginSessionRemoteIpAddrSet(U_IDX,
              cliLoginSessionIndexGet(),&remote);
#endif
          usmDbLoginSessionTypeSet(U_IDX, cliLoginSessionIndexGet(), L7_LOGIN_TYPE_SSH);
          usmDbLoginSessionUserStorageSet(U_IDX, cliLoginSessionIndexGet(), connection->context);

          cliCommon[connection->handleNum].telnetConnection = TRUE;
          Handle[found] = connection;
          ConnectionsActive++;
          ConnectionsActiveSSH++;
          connection->context->telnet->ssh = TRUE;

          EMWEB_TRACE(("Open %p %d\n", connection, connection->socket));

#if defined (EW_CONFIG_OPTION_SSL_RSA)
          connection->ssl_connection_flg = FALSE;
#endif

#if defined (EW_CONFIG_OPTION_UPNP)
          connection->upnp_udp_connection_flg = FALSE;
#endif
          if(FALSE == ewaConnectionInit( connection ))
          {
            ewaNetHTTPEnd( connection );
            return NULL;
          }

          /*
             Note that cliSSHLoginCheck has to be called twice in succession,
             both for username and password; by the time we get here, SSH has
             already verified the user identity, but it's still possible to
             fail the Login check if Radius is configured to require a
             challenge phrase.  Since that info does not come from the SSH
             login, emWeb will take care of that phase.
           */
          if (cliCommon[cliUtil.handleNum].loginStatus == L7_FALSE)
          {
            L7_BOOL rcb;

            rcb = cliSSHLoginCheck(username, L7_NULL, L7_NULLPTR, connection->context, connection->peer.u.sa4.sin_addr.s_addr);

            if (cliSSHLoginCheck(password, accessLevel, challengePhrase, connection->context, connection->peer.u.sa4.sin_addr.s_addr) == L7_TRUE)
            {
              cliCommon[cliUtil.handleNum].loginStatus = L7_TRUE;
              cliCommon[cliUtil.handleNum].passwdExpStatus = L7_TRUE;

              if((cliAccessLoginUserIsAllow(ACCESS_LINE_SSH) == L7_TRUE) ||
                  (cliPasswdExpireCheck (L7_NULL, connection->context) == L7_TRUE))
              {
                cliCommon[cliUtil.handleNum].loginStatus = L7_FALSE;
                /*
                 * Successful login, change prompt and state.
                 */

                ewaLogHook(connection->context, EWS_LOG_STATUS_OK);
                connection->logged_in = TRUE;
                cliCommandsInit();
                cliPrompt(connection->context);
              }
            }
            else
            {
              memset(buf, 0, sizeof(buf));
              sprintf(buf, "Login of %s failed", username);
              ewsTelnetWrite(connection->context, buf);
              ewsFlushAll(connection->context);
            }
          }
        }
        else
        {
          /*EMWEB_ERROR(( "EmWeb: Handle table overflow @%d", __LINE__ ));
            ERROR_EXIT;*/
          L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                  "Handle table overflow");
          close( connection->socket );
          ewaFree( connection );
          connection = NULL;
        }
      }
      else
      {
        EMWEB_WARN(("ewsNetTelnetStart() refused connection"));

        if (0 != closesocket(connection->socket))
        {
          EMWEB_WARN(("ewsNetHTTPStart() closesocket failed for socket= %d, errno=%d\n",
                      connection->socket, errno));
        }

        ewaFree(connection);
        connection = NULL;
      }
    }
    else
    {
      /* Error on the accept call */
      sprintf(sockErr, "ewaNewSSHConnection EmWeb socket accept() failed: %s\n", strerror(errno));
      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
              "%s",sockErr);
      ewaFree(connection);
      connection = NULL;
    }
  }
  else
  {
    /* Error allocating the net handle */
    EMWEB_ERROR(("EmWeb: memory allocation failed @ %s:%d",
                 __FILE__ ,__LINE__));
    ERROR_EXIT;
  }

  return connection;
}

/*********************************************************************
* @purpose  To change the listening port of the http server
*
* @param    port - port on which the http runs
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    Closes the existing listening socet and opens the listening socket and puts it
*                into the Listening state.
*
* @end
*********************************************************************/
L7_RC_t ewaNetHttpPortSet(L7_uint32 port)
{
  L7_uint32                hostaddr;
  struct sockaddr_in    addr;           /* TCP/IP socket structure */
  struct linger         linger;
  L7_int32        one = 1;       /* used to set socket options */
#ifdef L7_IPV6_PACKAGE
  struct sockaddr_in6   addr6;        /* TCP/IP socket structure */
#endif
#ifdef L7_MGMT_SECURITY_PACKAGE
  L7_uint32 ssltmode;
#endif

  if (port == httpListenPort)
  {
    return L7_SUCCESS;
  }
  httpListenPort = port;

  closeWebConnections();
  ewaNetHTTPSocketClose();
  osapiSleepMSec(300);

  errno = 0;
  http_s = socket(AF_INET, SOCK_STREAM, 0);
  if (http_s < 0)
  {
    EMWEB_ERROR(("http socket call failed: %s\n", strerror(errno)));
    return L7_FAILURE;
  }

  errno = 0;
  if ((setsockopt(http_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0 )
  {
    EMWEB_ERROR(("http setsockopt REUSEADDR failed: %s\n" , strerror(errno)));
    return L7_FAILURE;
  }

  errno = 0;
  if ((setsockopt(http_s, SOL_SOCKET, SO_KEEPALIVE, (char *)&one,
                  sizeof(one))) < 0 )
  {
    EMWEB_ERROR(("http setsockopt KEEPALIVE failed: %s\n", strerror(errno)));
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

  errno = 0;
  if ((setsockopt(http_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
  {
    EMWEB_ERROR(("http setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
  }

  errno = 0;
  if ((setsockopt(http_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
  {
    EMWEB_ERROR(("http setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
  }

#endif

  errno = 0;
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 0;
  /* VxWorks has setsockopt(int, int, int, char *, int). */
  if ((setsockopt(http_s, SOL_SOCKET, SO_LINGER, (char *)&linger,
                  sizeof(linger))
        )
      < 0
    )
  {
    EMWEB_ERROR(("http setsockopt LINGER failed %s\n", strerror(errno)));
  }

  errno = 0;

  /* bind the HTTP listening port */
  hostaddr = osapiHtonl(INADDR_ANY);
  memset(&addr, 0, sizeof(addr));
  /*memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof(uint32));*/
  addr.sin_family = AF_INET;
  addr.sin_port = osapiHtons(port);
  if (bind(http_s, (struct sockaddr *) &addr, sizeof(addr))
      < 0)
  {
    EMWEB_ERROR(("http bind failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }

  errno = 0;
  if (listen(http_s, MaxConnections) < 0)
  {
    EMWEB_ERROR(("http listen failed: %s\n", strerror(errno)));
    return(L7_FAILURE);
  }

#ifdef L7_IPV6_PACKAGE
  if (http6_s != 0)
  {
    close(http6_s);
  }
  /*
   * Open socket for receiving HTTP connections
   */
  errno = 0;
  http6_s = socket(AF_INET6, SOCK_STREAM, 0);
  if (http6_s < 0)
  {
    EMWEB_ERROR(("http6 socket call failed: %s\n", strerror(errno)));
    return L7_FAILURE;
  }

  errno = 0;
  /* VxWorks has setsockopt(int, int, int, char *, int). */
  if ((setsockopt(http6_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(("http6 setsockopt REUSEADDR failed: %s\n" , strerror(errno)));
    return L7_FAILURE;
  }

  errno = 0;
  if ((setsockopt(http6_s, SOL_SOCKET, SO_KEEPALIVE, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(("http6 setsockopt KEEPALIVE failed: %s\n", strerror(errno)));
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

  errno = 0;
  if ((setsockopt(http6_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
  {
    EMWEB_ERROR(("http6 setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
  }

  errno = 0;
  if ((setsockopt(http6_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
  {
    EMWEB_ERROR(("http6 setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
  }

#endif

  errno = 0;
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 2;
  /* VxWorks has setsockopt(int, int, int, char *, int). */
  if ((setsockopt(http6_s, SOL_SOCKET, SO_LINGER, (char *)&linger,
                  sizeof(linger))
        )
      < 0
    )
  {
    EMWEB_ERROR(("http setsockopt LINGER failed %s\n", strerror(errno)));
  }

  errno = 0;
  hostaddr = osapiHtonl(INADDR_ANY);
  memset(&addr6, 0, sizeof(addr6));
  addr6.sin6_family = AF_INET6;
  addr6.sin6_port = osapiHtons(port);

  if (bind(http6_s, (struct sockaddr *) &addr6, sizeof(addr6)) < 0)
  {
    EMWEB_ERROR(("http6 bind failed: %s\n", strerror(errno)));
    return L7_FAILURE;
  }

  errno = 0;
  if (listen(http6_s, MaxConnections) < 0)
  {
    EMWEB_ERROR(("http6 listen failed: %s\n", strerror(errno)));
    return L7_FAILURE;
  }

#endif  /* L7_IPV6_PACKAGE */

#ifdef L7_MGMT_SECURITY_PACKAGE
  ssltmode=L7_DISABLE;

  if ((ssltAdminModeGet(&ssltmode) == L7_SUCCESS) &&
      (ssltmode == L7_ENABLE))
  {
     ssltUnSecurePortSet(port);
  }
#endif
  http_active    = L7_TRUE;

  return L7_SUCCESS;
}


#if defined (EW_CONFIG_OPTION_SSL_RSA)
static
EwaNetHandle ewaSSLNewConnection( SOCKET master_socket )
{
  EwaNetHandle connection;
  uintf i;
  int32 found;
  unsigned addrlen = sizeof(struct sockaddr);
  int accept_socket;
  struct sockaddr_in peer;
#ifdef EMWEB_LOOKUP_HOST
  struct hostent *hostentP;
#endif

  /*
   * Accept connection
   */

  accept_socket = accept( master_socket
                          ,(struct sockaddr*)&peer
                          ,&addrlen
                        );
  if (getsockname(accept_socket, (struct sockaddr *)&peer, (EW_SIZE_T *)&addrlen))
  {
    return(EWA_NET_HANDLE_NULL);
  }

  /* Allocate and initialize a connection */
  connection = (EwaNetHandle) ewaAlloc( sizeof( EwaNetHandle_t ) );
  if ( connection != NULL )
  {
    memset( connection, 0, sizeof( EwaNetHandle_t ) );

    connection->socket = accept_socket;

    if (!SOCKET_IS_INVALID( connection->socket ))
    {
#ifdef EWA_LOG_HOOK
      uint32 peerAddr;

#ifdef EMWEB_LOOKUP_HOST
      hostentP = gethostbyaddr((char *)&peer.sin_addr
                               ,4
                               ,AF_INET);
      if (hostentP != NULL)
      {
        memcpy(connection->sourceAddrStr
               ,hostentP->h_name
               ,sizeof(connection->sourceAddrStr));
      }
      else
#endif /* EMWEB_LOOKUP_HOST */
      {
        peerAddr = osapiNtohl(peer.sin_addr.s_addr);
        sprintf( connection->sourceAddrStr
                 ,"%d.%d.%d.%d"
                 ,(int)((peerAddr >> 24) & 0x000000ffL)
                 ,(int)((peerAddr >> 16) & 0x000000ffL)
                 ,(int)((peerAddr >> 8)  & 0x000000ffL)
                 ,(int)((peerAddr)       & 0x000000ffL)
               );
      }
#endif /* EWA_LOG_HOOK */
      memcpy(&connection->peer, &peer, addrlen);

      /*
       * Start SSL connection
       */
      if (sslConnectionInit( connection ))
      {
        /*
         * All the setup is complete, so insert this in
         * the Handle table and count the connection.
         */

        /* Find an empty slot in the Handle table */
        for ( i = FD_CLI_DEFAULT_MAX_CONNECTIONS, found = -1; ( found == -1 ) && ( i < MaxConnections ); i++)
        {
          if ( Handle[i] == NULL )
          {
            found = i;
            break;
          }
        }
        if ( found >= 0 )
        {
          Handle[found] = connection;
          ConnectionsActive++;
          /* LVL7_P0006 start */
          if (master_socket == telnet_s)
          {
            ConnectionsActiveTelnet++;
          }
          /* LVL7_P0006 end */

          EMWEB_TRACE(( "Open %p %d\n"
                        ,connection
                        ,connection->socket
                      ));

          if(FALSE == ewaConnectionInit( connection ))
          {
            ewaNetHTTPEnd( connection );
            return NULL;
          }
        }
        else
        { /*
          EMWEB_ERROR(( "EmWeb: Handle table overflow @%d", __LINE__ ));
          ERROR_EXIT;
          */
            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                    "Handle table overflow");
            close( connection->socket );
            ewaFree( connection );
            connection = NULL;
        }
      }
      else
      {
        EMWEB_WARN(( "sslConnectionInit() refused connection"));
        ewaFree( connection );
        connection = NULL;
      }
    }
    else
    {
      sprintf(sockErr, "ewaNewSSLConnection EmWeb socket accept() failed: %s\n", strerror(errno));
      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
              "%s",sockErr);
      ewaFree( connection );
      connection = NULL;
    }
  }
  else
  {
    /* Error allocating the net handle */
    EMWEB_ERROR(( "EmWeb: memory allocation failed @ %s:%d"
                  ,__FILE__
                  ,__LINE__ ));
    ERROR_EXIT;
  }

  return connection;
}
#endif /* EW_CONFIG_OPTION_SSL_RSA */

#ifdef EW_CONFIG_OPTION_UPNP
/********************************************************************
 *
 * ewaSsdpNewConnection (socket, isMulticastMsg)
 *
 * allocate and initialize a new connection.
 * Fill in connection information.
 * call ewsNetUdpStart
 * call ewaConnectionInit( connection );
 * set flag  connection->upnp_udp_connection_flg = TRUE;
 *
 * The caller is responsible for assuring that the internal handle table
 * can accept a new connection, i.e., ConnectionsActive < MaxConnections.
 *
 ********************************************************************/
static
EwaNetHandle ewaSsdpNewConnection( SOCKET master_socket,
                                   boolean isMulticastMsg,
                                   boolean doGetContext,
                                   EwsContext context)
{
  EwaNetHandle connection;
  uintf i;
  int32 found;
#if defined(HAVE_IOCTL_FIONBIO) && defined(EW_CONFIG_OPTION_SCHED_FC)
  int on = 1;
  int result;
#endif
  unsigned addrlen = sizeof(struct sockaddr);
  /*  int accept_socket; */
  struct sockaddr_in peer;
#ifdef EMWEB_LOOKUP_HOST
  struct hostent *hostentP;
#endif /* EMWEB_LOOKUP_HOST */

  /*
   * don't accept() connection since we are using datagrams.
   */
  /* Allocate and initialize a connection */
  connection = (EwaNetHandle) ewaAlloc( sizeof( EwaNetHandle_t ) );
  if ( connection != NULL )
  {
    memset( connection, 0, sizeof( EwaNetHandle_t ) );

    connection->socket = master_socket;
    /* We use the master socket.
     peer is used to figure out who the message came from.
     It can be determeind who sent the message after making recvfrom() call.
    */
    if (getsockname(master_socket, (struct sockaddr *) &peer,
                    (EW_SIZE_T *)&addrlen))
    {
      return(EWA_NET_HANDLE_NULL);
    }

    if (!SOCKET_IS_INVALID( connection->socket ))
    {
#ifdef EWA_LOG_HOOK
#endif /* EWA_LOG_HOOK */

      memcpy(&connection->peer, &peer, addrlen);

#if ( defined(HAVE_IOCTL_FIONBIO) \
              && defined(EW_CONFIG_OPTION_SCHED_FC) \
              && ! defined(WIN32) \
              && ! defined(_WIN32_WCE) \
              )
      /*
       * Set for non-blocking I/O
       */
      osapiSocketNonBlockingModeSet(connection->socket, L7_TRUE);
#else
      /* In WIN32, nonblocking mode with LINGER turned on causes
       * closesocket() to not close immediately.
       */
#endif /* HAVE_IOCTL_FIONBIO && EW_CONFIG_OPTION_SCHED_FC && ! WIN32 */
      /*
       * Notify EmWeb/Server
       */
      if (doGetContext)
      {
#ifdef EW_CONFIG_OPTION_UPNP_SSDP_CP

        connection->context = (  master_socket == upnp_server_s
                                 ? ewsNetUdpStart( connection )
                                 : ewsNetSSDPResponseStart( connection )
                              );

#else /* EW_CONFIG_OPTION_UPNP_SSDP_CP */

        connection->context = ewsNetUdpStart( connection );

#endif /* EW_CONFIG_OPTION_UPNP_SSDP_CP */

        EMWEB_TRACE(("ewaSsdpNewConnection: setting connection(%p)->"
                     "context(%p) from return of ewsNetUdpStart\n",
                     connection, connection->context));
      }
      else
      {
        /* we already have a valid context ! */
        connection->context = context;
        EMWEB_TRACE(("ewaSsdpNewConnection: setting connection(%p)->context(%p) from context argument\n",
                     connection, connection->context));
      }

      if (connection->context != EWS_CONTEXT_NULL)
      {
        /*
         * All the setup is complete, so insert this in
         * the Handle table and count the connection.
         */

        /* Find an empty slot in the Handle table */
        for ( ( i = FD_CLI_DEFAULT_MAX_CONNECTIONS
                ,found = -1
              );
            (   ( found == -1 )
                && ( i < MaxConnections )
            );
            i++
            )
        {
          if ( Handle[i] == NULL )
          {
            found = i;
            break;
          }
        }

        if ( found >= 0 )
        {
          Handle[found] = connection;
          ConnectionsActive++;

          EMWEB_TRACE(( "ewaSsdpNewConnection: Open net handle = %p, context = %p, socket = %d\n"
                        ,connection
                        ,connection->context
                        ,connection->socket
                      ));
#if defined (EW_CONFIG_OPTION_SSL_RSA)
          connection->ssl_connection_flg = FALSE;
#endif
          if(FALSE == ewaConnectionInit( connection ))
          {
            ewaNetHTTPEnd( connection );
            return NULL;
          }
          /* Initialize connection */
          connection->upnp_udp_connection_flg = TRUE;
          connection->udp_xmit_buflen= 0;
          connection->isMulticastMsg = isMulticastMsg;
          connection->udp_xmit_buffer = NULL;
        }
        else
        { /*
          EMWEB_ERROR(( "EmWeb: Handle table overflow @%d", __LINE__ ));
          ERROR_EXIT;
          */
            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                    "Handle table overflow");
            close( connection->socket );
            ewaFree( connection );
            connection = NULL;
        }
      }
      else
      {
        EMWEB_WARN(( "ewsNetHTTPStart() refused connection"));

        /* Do not do closesocket() since we do not do an accept(). */
        ewaFree( connection );
        connection = NULL;
      }
    }
    else
    {
      /* Error on the accept call */
      sprintf(sockErr, "ewaNewSsdpConnection EmWeb socket accept() failed: %s\n", strerror(errno));
      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
              "%s",sockErr);
      ewaFree( connection );
      connection = NULL;
    }
  }
  else
  {
    /* Error allocating the net handle */
    EMWEB_ERROR(( "EmWeb: memory allocation failed @ %s:%d"
                  ,__FILE__
                  ,__LINE__ ));
    ERROR_EXIT;
  }
  return connection;
}
#endif /* EW_CONFIG_OPTION_UPNP */

static
void NetReceiveLoop( fd_set* fds )
{
#ifdef L7_OUTBOUND_TELNET_PACKAGE
  L7_RC_t      rc;
  L7_uint32    unit = 0;
  L7_uint32 loginType = 0;
#endif /*L7_OUTBOUND_TELNET_PACKAGE */
  int s;
  EwaNetHandle connection = NULL;
  EwaNetBuffer buffer;
  int bytes;
  EwsStatus status;
  time_t now = 0;

  /*
   * Scan all of the recorded connections for receive data events
   */
  for ( s = 0; s < (int) MaxConnections; s++ )
  {
    /*
     * Test the read-ready bit mask to see if the socket of the connection
     * has data for us to receive.
     * If SSL is installed, we have to skip all SSL connections here.
     */
    if (NULL != Handle[s]
#if defined (EW_CONFIG_OPTION_SSL_RSA)
        && !Handle[s]->ssl_connection_flg
#endif
        && FD_ISSET( Handle[s]->socket, fds )
        && (Handle[s]->context->obtActive == L7_FALSE))
    {
      connection = Handle[s];
      connection->idle = FALSE;
      connection->lastTime= time(NULL);

#ifdef EMWEB_SANITY
      if (connection->context == NULL)
      {

        if ( connection->close_pending == TRUE)
        {
          /* this is a second call to ewaNetHTTPEnd, this one will
             close the socket because the transmit_pending buffer
             has been cleared */
          if (connection->pending_xmit != EWA_NET_BUFFER_NULL)
          {
            ewaNetBufferFree( connection->pending_xmit );
            connection->pending_xmit = EWA_NET_BUFFER_NULL;
          }
          EMWEB_TRACE(("Null Context : Calling ewaNetHTTPEnd() from NetReceiveLoop()\n"));
          ewaNetHTTPEnd( connection );
        }
        continue;
      }
#endif /* EMWEB_SANITY */

#ifdef EW_CONFIG_OPTION_UPNP
      /* Skip all UDP 'connections' in this loop, as they have been
       * processed in ewaSsdpNewConnection.
       */
      if (connection->upnp_udp_connection_flg)
      {
        continue;
      }
#endif /* EW_CONFIG_OPTION_UPNP */

      EMWEB_TRACE(("NetReceiveLoop: read-ready seen on connection %d, socket %d\n",
                   s, Handle[s]->socket));

      /*
       * Get a network buffer
       */
      buffer = ewaNetBufferAlloc();

      if (buffer != EWA_NET_BUFFER_NULL)
      {
        /*
         * Read data into buffer
         */
        /* LVL7_P0006 Start */

        if (bspapiConsoleFdGet() == connection->socket)
        {
          if(0 > read(bspapiConsoleFdGet(), (char *)ewaNetBufferDataGet(buffer), 1)){}
          bytes = 1;
          if (usmDbTransferSuspendMgmtAccessGet(U_IDX) == L7_TRUE)
           {
             ewaNetBufferFree(buffer);
             connection->pending_xmit = EWA_NET_BUFFER_NULL;
             return;
           }
        }
#if 0
        else if (connection->context->telnet->flags & EWS_TELNET_SERIAL_PORT)
        {
          read(connection->socket, (char *)ewaNetBufferDataGet(buffer), 1);
          bytes = 1;
        }
#endif
        else
        /* LVL7_P0006 End */
        {
          bytes = recv( connection->socket
                        ,(char*)ewaNetBufferDataGet(buffer)
                        ,ewaNetBufferLengthGet(buffer)
                        ,0
                      );
        /*
           * If the context has been closed, drop the keystrokes.
           */
          if (connection->context == EWS_CONTEXT_NULL)
          {
            EMWEB_TRACE(("Calling ewaNetHTTPEnd() from NetReceiveLoop()\n"));
            ewaNetBufferFree(buffer);
            ewaNetHTTPEnd(connection);
            return;
          }

        }

        /*
         * If there is a transfer in progess then the keystrokes should
         * be dropped to avoid exceeding the maximun number of buffers
         * allowed to be queued up.
         */
        if ((usmDbTransferSuspendMgmtAccessGet(U_IDX)) &&
            (connection->context == (EwsContext)usmDbTransferContextGet(U_IDX)))
        {
          ewaNetBufferFree(buffer);
          connection->pending_xmit = EWA_NET_BUFFER_NULL;
          return;
        }

        if (bytes > 0)
        {
          ewsBytesRecv += bytes;        /* update stats */

          /*
           * Forward data to EmWeb/Server
           */
          /* For UDP, the buffer length is set in the rcvUdpLoop
             function.  Therefore,we don't need to set it again
             and there may be chained buffers.
             So, ONLY set this if it is NOT a upnp_udp_connection
             or you don't have UPNP option turned on.
          */
#ifdef EW_CONFIG_OPTION_UPNP
          if (!connection->upnp_udp_connection_flg)
#endif /* EW_CONFIG_OPTION_UPNP */
          {
            ewaNetBufferLengthSet(buffer, bytes);
          }
          status = ewsNetHTTPReceive( connection->context
                                      ,buffer
                                    );
          if (status != EWS_STATUS_OK)
          {
            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                    "ewsNetHTTPReceive failure in NetReceiveLoop() - closing connection.\n");
            if ( connection->pending_xmit != EWA_NET_BUFFER_NULL )
            {
              ewaNetBufferFree( connection->pending_xmit );
              connection->pending_xmit = EWA_NET_BUFFER_NULL;
            }

            /* Test whether the server has already told us to close this
             * connection. */
            if ( connection->close_pending )
            {
              /*
               * the server has already closed this context,
               * so just drop it
               */
              ewaNetHTTPEnd( connection );
            }
            else
            {
              /*
               * tell the server to shut down this context
               */
              ewsNetHTTPAbort( connection->context );
            }
            return;
          }
        }
        else /* bytes =< 0 */
        {
          /*
           * Client closed the TCP connection:
           * Release the buffer that was allocated above (on the
           * assumption that data would be incoming) and abort the
           * context.
           */
          EMWEB_TRACE(("remote closed connection\n"));
          ewaNetBufferFree(buffer);
          /* Free any data that was waiting to be sent to the
           * client. */
          if ( connection->pending_xmit != EWA_NET_BUFFER_NULL )
          {
            ewaNetBufferFree( connection->pending_xmit );
            connection->pending_xmit = EWA_NET_BUFFER_NULL;
          }

          /* Test whether the server has already told us to close this
           * connection. */
          if ( connection->close_pending )
          {
            /*
             * the server has already closed this context,
             * so just drop it
             */
            ewaNetHTTPEnd( connection );
          }
          else
          {
            /*
             * tell the server to shut down this context
             */
            ewsNetHTTPAbort( connection->context );
          }
        }
      }
      else
      {
        /* Buffer allocation failed - drop connection */
        EMWEB_ERROR(( "EmWeb: net buffer alloc failed @ %s:%d\n"
                      ,__FILE__
                      ,__LINE__));
        ewsNetHTTPAbort( connection->context );
      }
    } /* end of net data received */
#ifdef L7_OUTBOUND_TELNET_PACKAGE
    else if (( Handle[s] != NULL ) &&
             ( Handle[s]->context->obtActive == L7_TRUE && FD_ISSET( Handle[s]->socket, fds ))
            )  /* if OBT client socket is ready */
    {
      rc = usmdbObtClientInputHandle(unit, Handle[s]->socket, Handle[s]->context->obtSocket);

      if (rc == L7_SUCCESS)
      {
        usmDbLoginSessionUpdateObtActivityTime(unit, cliCommon[Handle[s]->handleNum].userLoginSessionIndex);
      }
      else if (rc == L7_FAILURE)  /* connection to be closed */
      {
        usmDbLoginSessionTypeGet(U_IDX, cliCommon[Handle[s]->handleNum].userLoginSessionIndex, &loginType);
        usmDbObtLoginSessionEnd(cliCommon[Handle[s]->handleNum].userLoginSessionIndex);
        usmDbTelnetDisconnect(Handle[s]->socket, Handle[s]->context->obtSocket);
        usmDbLoginSessionLogout(U_IDX, cliCommon[Handle[s]->handleNum].userLoginSessionIndex);
        Handle[s]->context->obtSocket = 0;
        Handle[s]->context->obtActive = L7_FALSE;
        if ((loginType == L7_LOGIN_TYPE_TELNET) || (loginType == L7_LOGIN_TYPE_SSH))
        {
          ewsTelnetWrite(Handle[s]->context, cliutilGetConnectionClosedMsg());
          ewsTelnetWrite(Handle[s]->context, Handle[s]->context->telnet->prompt);
          ewsFlushAll(Handle[s]->context);
        }
        if (loginType == L7_LOGIN_TYPE_SERIAL)
        {
           cliWriteSerial(cliutilGetConnectionClosedMsg());
           cliWriteSerial((L7_char8 *)(Handle[s]->context->telnet->prompt));
        }
      }
    }  /* end of client OBT Activity */
    else if (( Handle[s] != NULL ) &&
             ( Handle[s]->context->obtActive == L7_TRUE && FD_ISSET( Handle[s]->context->obtSocket, fds ))
            )  /* if OBT server socket is ready */
    {
      rc = usmdbObtServerInputHandle(unit, Handle[s]->socket, Handle[s]->context->obtSocket);

      if (rc == L7_SUCCESS)
      {
        usmDbLoginSessionUpdateObtActivityTime(unit, cliCommon[Handle[s]->handleNum].userLoginSessionIndex);
      }
      else if (rc == L7_FAILURE)  /* connection to be closed */
      {
        usmDbLoginSessionTypeGet(U_IDX, cliCommon[Handle[s]->handleNum].userLoginSessionIndex, &loginType);
        usmDbObtLoginSessionEnd(cliCommon[Handle[s]->handleNum].userLoginSessionIndex);
        usmDbTelnetDisconnect(Handle[s]->socket, Handle[s]->context->obtSocket);
        Handle[s]->context->obtSocket = 0;
        Handle[s]->context->obtActive = L7_FALSE;
        if ((loginType == L7_LOGIN_TYPE_TELNET) || (loginType == L7_LOGIN_TYPE_SSH))
        {
          ewsTelnetWrite(Handle[s]->context, cliutilGetConnectionClosedMsg());
          ewsTelnetWrite(Handle[s]->context, Handle[s]->context->telnet->prompt);
          ewsFlushAll(Handle[s]->context);
        }
        if (loginType == L7_LOGIN_TYPE_SERIAL)
        {
           cliWriteSerial(cliutilGetConnectionClosedMsg());
           cliWriteSerial((L7_char8 *)(Handle[s]->context->telnet->prompt));
        }
      }
    }  /* end of server OBT Activity */
#endif /* L7_OUTBOUND_TELNET_PACKAGE */
    else if((Handle[s] != NULL) && !(FD_ISSET( Handle[s]->socket, fds )) && (Handle[s]->socket != bspapiConsoleFdGet()))
   {
     now = time(NULL);
     if(Handle[s]->connection_type == EW_CONNECTION_HTTP || Handle[s]->connection_type == EW_CONNECTION_HTTPS)
     {
/*
        currently this fix is for only web connections.
        default session timeout for web is FD_HTTP_SESSION_SOFT_TIMEOUT_DEFAULT
        which is 5 mins. so waiting for same amount of time even for this
        socket.
*/
       if((now - Handle[s]->lastTime) > (30 * EMWEB_MAX_IDLE) )
       {
         if ( Handle[s]->close_pending )
         {
           /*
            * the server has already closed this context,
            * so just drop it
          */
          ewaNetHTTPEnd( Handle[s]);
         }
         else
        {
          ewsNetHTTPAbort(Handle[s]->context);
        }
      }
    }
  }
#if defined (EW_CONFIG_OPTION_SSL_RSA)
    else
    { /* else  data is for SSL connection */
      doSSLRecvLoop(s,connection, fds);
    }
#endif /* EW_CONFIG_OPTION_SSL_RSA */
  }
}

#ifdef EW_CONFIG_OPTION_SCHED_FC

static
void NetTransmitPendingLoop( fd_set* fds )
{
  int s;
  EwaNetHandle connection;
  EwaStatus    status;

  /*
   * Scan for write ready events
   */
  for ( s = 0; s < (int) MaxConnections; s++ )
  {
    connection = Handle[s];

#ifdef EW_CONFIG_OPTION_CLIENT
    if (   ( connection != NULL )
           && ( connection->connect_pending )
           && ( FD_ISSET( Handle[s]->socket, fds ) )
       )
    {
      connection->connect_pending = FALSE;
      ewsClientConnectConfirm( Handle[s]->context, EWA_STATUS_OK );
      continue;
    }
#endif /* EW_CONFIG_OPTION_CLIENT */

    if (   ( connection != NULL )
           && ( connection->pending_xmit != EWA_NET_BUFFER_NULL )
           && ( FD_ISSET( Handle[s]->socket, fds ) )
       )
    {

#ifdef EMWEB_SANITY
      if (connection->context == NULL)
      {
        if ( connection->close_pending == TRUE)
        {
          if ( connection->pending_xmit != EWA_NET_BUFFER_NULL )
          {
            ewaNetBufferFree( connection->pending_xmit );
            connection->pending_xmit = EWA_NET_BUFFER_NULL;
          }
        }
        EMWEB_TRACE(("transmit pending on null context \n"));
        continue;
      }
#endif /* EMWEB_SANITY */

      status = TransmitPending( connection );
      if ( status != EWA_STATUS_OK )
      {
#ifdef EW_CONFIG_OPTION_SSL_RSA
        if (connection->ssl_connection_flg == TRUE)
        {
          if (connection->ssl_state == sslStateUp)
          {

            ewsNetHTTPAbort( connection->context );
          }
          else
          {
            ewaNetHTTPEnd(connection);
          }
        }
        else
        {
          ewsNetHTTPAbort( connection->context );
        }
#else
        ewsNetHTTPAbort( connection->context );
#endif
      }
      else if ( connection->pending_xmit == EWA_NET_BUFFER_NULL )
      {
        EMWEB_TRACE(( "send on %d completed\n", connection->socket ));
        if ( connection->close_pending )
        {
          ewaNetHTTPEnd( connection );
        }
        else
        {
          ewsNetUnFlowControl( connection->context );
        }
      }
    }
  }
}
#endif /* EW_CONFIG_OPTION_SCHED_FC */


/* ################################################################
 * ewaNetHTTPSend
 *
 * Send HTTP response data to network
 *
 * net_handle   - Unix TCP socket assigned to request
 * buffer       - Chain of one or more buffers of HTTP response data
 * ################################################################ */

EwaStatus
ewaNetHTTPSend ( EwaNetHandle net_handle, EwaNetBuffer buffer )
{
  EwaStatus status;

  EMWEB_TRACE(("ewaNetHTTPSend(%d, %p)\n", net_handle->socket, buffer));

  /* Drop output sent to the discard handle. */
  if (EWA_NET_HANDLE_DISCARD == net_handle || net_handle->discard)
  {
    ewaNetBufferFree(buffer);
    return EWA_STATUS_OK;
  }

  net_handle->idle = FALSE;

  ChainPending( net_handle, buffer );
  status = TransmitPending( net_handle );
  return status;
}

static
void ChainPending( EwaNetHandle connection, EwaNetBuffer buffer )
{
  EwaNetBuffer prev;

  if ( connection->pending_xmit == EWA_NET_BUFFER_NULL )
  {
    connection->pending_xmit = buffer;
  }
  else
  {
    for ( prev = connection->pending_xmit;
        ewaNetBufferNextGet( prev ) != EWA_NET_BUFFER_NULL;
        prev = ewaNetBufferNextGet( prev )
        )
    {
      /* Walk the pending chain and put this on the end */
    }
    ewaNetBufferNextSet( prev, buffer );
  }
}

static
EwaStatus TransmitPending( EwaNetHandle connection )
{
  EwaNetBuffer buffer;
  EwaNetBuffer next_buffer;
  static int   bytes;
  EwaStatus    status;
  boolean      ok;
#ifdef EW_CONFIG_OPTION_SSL_RSA
  int          ssl_error;
#endif

  /*LVL7_P0006 start*/
  int numLines = 0;
  int copied_bytes = 0;
  int pendingSize = 0;
  int   retryCount = 0;
  int   bytesSent;
  int   errorSend;
  char *dataPtr = NULL;
  int new_expected_bytes = 0;
  int line_copied_bytes = 0;
  char *bufferPtr = NULL;
  char *bufferPtrAhead = NULL;
  char *bufferPtrStart = NULL;
  /*LVL7_P0006 end*/
  int fdout = 0;

  EMWEB_TRACE(("xmit attempt %p\n", connection));

  status = EWA_STATUS_OK;

#ifdef EW_CONFIG_OPTION_UPNP
  /* If it is a UDP connection, we just cobble up the data to see if it
     will fit into the connection's udp_xmit_buffer.  We do not actually
     send data at this point.
  */
  if (TRUE == connection->upnp_udp_connection_flg)
  {
    status = fillUdpXmitBuffer(connection);
    return(status);
  }
  else
#endif /* EW_CONFIG_OPTION_UPNP */
  { /* not a upnp connection */
    /*
     * Follow chain of buffers, outputting the contents of each.
     */
    for ( ( ok = TRUE
            ,buffer = connection->pending_xmit
          );
        (   ( ok )
            && ( buffer != EWA_NET_BUFFER_NULL )
        );
        buffer = next_buffer
        )
    {
      int bytes_to_be_sent = (int) ewaNetBufferLengthGet( buffer );
      errorSend = 0;

      /*lvl7_P0006 start*/
      if ((connection->handleNum < FD_CLI_DEFAULT_MAX_CONNECTIONS) &&
          (cliCommon[connection->handleNum].telnetConnection == TRUE || connection->handleNum == CLI_SERIAL_HANDLE_NUM))
      {
        new_expected_bytes = 0;
        bufferPtr = (char*)ewaNetBufferDataGet(buffer);
        bufferPtrStart = bufferPtr;
        copied_bytes = 0;

        while (bufferPtr != NULL)
        {
          if ((numLines >= SCROLL_BUF_LINES)&&(cliCommon[connection->handleNum].isScroll == L7_TRUE))
          {
            EMWEB_WARN(("\nMax number of lines in the scroll buffer reached. Output will be truncated."));
            bufferPtr = NULL;
          }
          else
          {
            if ((numLines == CLI_MAX_SCROLL_LINES)&& (cliCommon[connection->handleNum].isScroll == L7_TRUE))
            {
              cliCommon[connection->handleNum].scroll = TRUE;
              if (bufferPtr == bufferPtrStart)
                new_expected_bytes = 0;
              else
                new_expected_bytes = (bufferPtr - bufferPtrStart);
            }

            pendingSize = 0;
            bufferPtrAhead = strchr(bufferPtr, '\n');

            if ((bufferPtrAhead != NULL) && (bufferPtrAhead < (bufferPtrStart + bytes_to_be_sent)))
            {
              if(line_copied_bytes < SCROLL_BUF_LINE_LENGTH)
              {
                /* Calculate pending empty buffer and clear it before copying */
                pendingSize = SCROLL_BUF_LINE_LENGTH - line_copied_bytes;
                memset(&cliCommon[cliUtil.handleNum].scrollBuffer[numLines][line_copied_bytes],0x00, pendingSize);
              }
              memcpy(&cliCommon[cliUtil.handleNum].scrollBuffer[numLines][line_copied_bytes], bufferPtr, (bufferPtrAhead - bufferPtr) + 1 );  /* +1 for /n */
              line_copied_bytes = (bufferPtrAhead - bufferPtr) + 1;
              copied_bytes = (bufferPtrAhead - bufferPtr) + copied_bytes + 1;
            }
            else if (copied_bytes != bytes_to_be_sent)
            {
              if(line_copied_bytes < SCROLL_BUF_LINE_LENGTH)
              {
                /* Calculate pending empty buffer and clear it before copying */
                pendingSize = SCROLL_BUF_LINE_LENGTH - line_copied_bytes;
                memset(&cliCommon[cliUtil.handleNum].scrollBuffer[numLines][line_copied_bytes], 0x00,pendingSize);
              }
              memcpy(&cliCommon[cliUtil.handleNum].scrollBuffer[numLines][line_copied_bytes], bufferPtr, (bytes_to_be_sent - copied_bytes) );
              line_copied_bytes = bytes_to_be_sent - copied_bytes;
              copied_bytes = (bytes_to_be_sent - copied_bytes) + copied_bytes;

            }

            bufferPtr = strchr(bufferPtr, '\n');

            if ((bufferPtr != NULL) && (bufferPtrAhead < (bufferPtrStart + bytes_to_be_sent)))
            {
              line_copied_bytes = 0;
              bufferPtr++;
              numLines++;
            }
            else
              bufferPtr = NULL;
          }
        }

        if ((numLines >= CLI_MAX_SCROLL_LINES)&& (cliCommon[connection->handleNum].isScroll == L7_TRUE))
        {
          /* If the number of output lines (which includes the subsequent command prompt) is
           * the same as the page scroll limit, or is exactly one line more than the scroll
           * limit and the line preceding the command prompt contains only whitespace characters,
           * then suppress the More/Quit line since there is nothing additional to display when
           * the user asks for 'More'.
           *
           * NOTE: Only do the "one line more" case for a serial connection.  Telnet has stricter
           *       requirements for displaying in a 24rx80c window, so the More/Quit will appear
           *       even though only a blank line + command prompt remains.  This is so the first
           *       line(s) of the page won't scroll off the top of the telnet window.
           */
          if ((numLines == CLI_MAX_SCROLL_LINES) ||
              ((connection->handleNum == CLI_SERIAL_HANDLE_NUM) &&
               ((numLines == CLI_MAX_SCROLL_LINES+1) )))
      {
        if (L7_SUCCESS == cliIsBlankLine(&cliCommon[cliUtil.handleNum].scrollBuffer[numLines-1][0]))
            {
               cliCommon[connection->handleNum].scroll = FALSE;                  /*undo scrolling*/
               new_expected_bytes = 0;
        }
            else
        {
               bytes_to_be_sent =  new_expected_bytes;
        }
      }
          else
          {
          bytes_to_be_sent =  new_expected_bytes;
          cliCommon[cliUtil.handleNum].scrollLineMax = numLines;            /*set scroll linemax*/
        }
      }
      }
      /*lvl7_P0006 end*/

      /*
       * Write buffer data to SSL or TCP/IP connection
       */
#if defined (EW_CONFIG_OPTION_SSL_RSA)
      if (connection->ssl_connection_flg)
      {
        bytes = SSL_write(connection->ssl
                          ,(char *)ewaNetBufferDataGet( buffer )
                          ,bytes_to_be_sent
                         );
      }
      else
#endif /* defined (EW_CONFIG_OPTION_SSL_RSA) */
      {
        ClearErrno();
        /* LVL7_P0006 Start */
        if (bytes_to_be_sent != 0)
        {
          /* if this is the serial port */
          if (connection->socket == bspapiConsoleFdGet())
          {
            fdout = cliWebIORedirectStdOutGet();
            if (fdout != -1)
            {
              if(0 > write(fdout, (char*)ewaNetBufferDataGet( buffer ), bytes_to_be_sent)){}
              bytes = bytes_to_be_sent;
            }
            else
            {
              bytes = fwrite((char*)ewaNetBufferDataGet( buffer ),sizeof(char), bytes_to_be_sent, stdout);
              fflush(stdout);
            }
          }
#ifdef COMMENTED_OUT
          else if (connection->context->telnet->flags & EWS_TELNET_SERIAL_PORT)
          {
            bytes = write(connection->socket, (char*)ewaNetBufferDataGet(buffer), bytes_to_be_sent);
          }
#endif /* COMMENTED_OUT */
           else if(use_connection_socket_select)
          {
            dataPtr = (char *)ewaNetBufferDataGet( buffer );
            ewaSocketSend (connection->socket, dataPtr, bytes_to_be_sent);
            bytes = bytes_to_be_sent; /* either completed or error, nothing to send */
          }
          else
          {
            /* LVL7_P0006 End */

            errorSend = 0;
            bytes = 0;
            dataPtr = (char *)ewaNetBufferDataGet( buffer );
            retryCount = 0;
            while (bytes < bytes_to_be_sent)
            {
              errorSend = 0;
              if ((bytesSent = send( connection->socket,
                                     dataPtr + bytes,
                                     bytes_to_be_sent - bytes,
                                     0 ))   < 0)
              {
                errorSend = osapiErrnoGet();

                if ((errorSend == EWOULDBLOCK) || (errorSend == EAGAIN))
                {
                  if (100 > retryCount)
                  {
                    retryCount++;
                    osapiSleepMSec(100);
                  }
                  else
                  {
                    bytes = bytes_to_be_sent;  /* Ignore this send so it does not snowball */
                  }
                }
                else
                {
                  break;  /* Some other error */
                }
              }
              else
              {
                bytes += bytesSent;
              }
            }
            if (errorSend != 0)
              bytes = bytes_to_be_sent;  /* Ignore this send if there is an error */

            /* LVL7_P0006 Start */
          }
        }
        else
        {
          bytes = bytes_to_be_sent;
        }
        /* LVL7_P0006 End */
      }

      /*
       * Test for data being successfully sent and if so, update buffer
       * pointers to record it.
       */
      if ( bytes > 0 )
      {
        /*
         * Some data was sent, so adjust the buffer's pointers to record
         * that fact.
         * Beware that on VxWorks, bytes can be > 0 even if errno is set,
         * which is not strictly allowed by the manual page.  This
         * combination does not happen in most Posix implementations.
         */
        ewsBytesSent += bytes;        /* update stats */
        ewaNetBufferDataSet( buffer
                             ,ewaNetBufferDataGet( buffer ) + bytes
                           );
        ewaNetBufferLengthSet( buffer
                               ,bytes_to_be_sent - bytes
                             );
        connection->idle = FALSE; /* even a partial send is activity */
      }

      /*
       * If the entire buffer was sent, free it from the buffer chain.
       * (Note this correctly handles the unexpected case where
       * ewaNetBufferLengthGet(buffer) == 0 -- bytes will == 0, and the
       * buffer will be removed from the chain.)
       * If an error was encountered and bytes == -1, then this condition
       * will never be true, which is safe.
       */
      if ( bytes == bytes_to_be_sent )
      {
        /*
         * The entire contents of this buffer have been sent, so it should
         * be freed.
         * 'next_buffer' is the next buffer to be examined in the enclosing
         * for() loop, so we have to set it now, before we free 'buffer'.
         */
        next_buffer = ewaNetBufferNextGet( buffer );

        /* That buffer was transmitted so unchain and free it */
        ewaNetBufferNextSet( buffer, EWA_NET_BUFFER_NULL );
        ewaNetBufferFree( buffer );
      }
      else
      {
        /*
         * Not all of this buffer was accepted by send()/SSL.
         * 'next_buffer' is set to be 'buffer', so the next iteration of
         * the loop will attempt to send the remainder of the data.
         * (Except if EWOULDBLOCK (flow control) has been indicated, which
         * will be tested for below, and will cause the loop to be exited.)
         */
        next_buffer = buffer;
      }

      /*
       * Test for error conditions and flow control and respond appropriately.
       */
#if defined(EW_CONFIG_OPTION_SSL_RSA)
      if (connection->ssl_connection_flg)
      {
        ssl_error = SSL_get_error(connection->ssl, bytes);
        switch (ssl_error)
        {
        case SSL_ERROR_NONE:
          /*
           * If less than all the data was sent, RSA/SSL is trying to
           * flow-control us.
           */
          if ( bytes >= 0 && bytes < bytes_to_be_sent )
          {
            EMWEB_TRACE(("send on %p (ssl: %d) flow control on\n"
                         ,connection
                         ,connection->socket ));

#ifdef EW_CONFIG_OPTION_SCHED_FC
            ewsNetFlowControl( connection->context );
#endif /* EW_CONFIG_OPTION_SCHED_FC */
            /* Exit the 'for'. */
            ok = FALSE;
          }
          break;

        default:
          /* LVL7_P0006 - we don't want to see all these warnings
                    EMWEB_WARN(( "TransmitPending(): data send on SSL socket %d failed (ssl_error = %d)\n"
                                  ,connection->socket
                                  ,ssl_error ));
          */
          /* Exit the 'for' with an error. */
          status = EWA_STATUS_ERROR;
          ok = FALSE;
          break;
        }
      }
      else
#endif /* defined(EW_CONFIG_OPTION_SSL_RSA) */
      {
        switch ( errorSend )
        {
        case 0:
          /*
           * No error seen.
           * Unlike previous versions of this code, we do not consider
           * it a reportable event if not all the bytes in the buffer
           * were sent in this one call.  We continue to process the
           * remainder of this buffer.
           * But, if the return is zero or -1, we assume that the stack is
           * trying to flow-control us, or has an error condition.  (This
           * combination does not happen on Unix, but does on Windows.)
           * We flow-control the stream and exit from the 'for' loop (so
           * that any error conditions can be detected and handled in
           * select()).
           */
          if (0 < bytes_to_be_sent && 0 >= bytes)
          {
#ifdef EW_CONFIG_OPTION_SCHED_FC
            ewsNetFlowControl( connection->context );
#endif /* EW_CONFIG_OPTION_SCHED_FC */
            /* Exit the 'for'. */
            ok = FALSE;
          }
          break;

        case EWOULDBLOCK:
          /*
           * The TCP/IP stack indicated that it would accept no more data.
           * Throttle the sending of data until we see a write-ready
           * condition on the socket.
           */

          /* fall through to abort connection */

          /* EMWEB_TRACE(("send on %d flow control on\n",
           *             connection->socket ));
           * #ifdef EW_CONFIG_OPTION_SCHED_FC
           * ewsNetFlowControl( connection->context );
           * #endif * EW_CONFIG_OPTION_SCHED_FC */
          /* Exit the for(). */
          ok = FALSE;
          /* break; */

#if ! defined(WIN32) && ! defined(_WIN32_WCE)
        case EPIPE:
          EMWEB_TRACE(("connection dropped %p\n", connection ));
          /* fall through to abort connection */
#endif
        default:
          /* LVL7_P0006 - we don't want to see all these warnings
                    EMWEB_WARN(( "TransmitPending(): data send on socket %d failed (errno=%d)\n"
                                  ,connection->socket
                                  ,errno ));
          */
          /* Exit the for() with an error. */

          status = EWA_STATUS_ERROR;
          ok = FALSE;

          /*
           * [ASI Support #4054] fix: EPIPE and other error codes from
           * write previously did not clear any transmit pending
           * condition. But future attempts to write will also fail,
           * and we will not close the socket until condition is
           * cleared.  The bug caused an infinite loop (or worse, a
           * crash), because the socket was always selected but could
           * only generate error events.  Now we clear the transmit
           * pending condition by releasing any queued buffers and
           * setting connection->pending_xmit to EWA_NET_BUFFER_NULL.
           * This forces a socket close when the context is aborted.
           */
          if (buffer != EWA_NET_BUFFER_NULL)
          {
            if (ewaNetBufferFreeCheck( buffer ))
            ewaNetBufferFree(buffer);
            next_buffer = buffer = EWA_NET_BUFFER_NULL;
          }

          break;
        }
      } /* switch errno */
    } /* for loop */

    connection->pending_xmit = buffer;
    /* lvl7_P0006 start */
    if ((connection->handleNum < FD_CLI_DEFAULT_MAX_CONNECTIONS) &&
        (cliCommon[connection->handleNum].telnetConnection == TRUE || connection->handleNum == CLI_SERIAL_HANDLE_NUM))
    {
      if ((cliCommon[cliUtil.handleNum].scroll == TRUE) &&(cliCommon[connection->handleNum].isScroll == L7_TRUE))
      {
        cliWrite("--More-- or (q)uit");
      }
    }
    /* lvl7_P0006 End */


    /* If telnet connection...set scrolling */
    if (connection->handleNum < FD_CLI_DEFAULT_MAX_CONNECTIONS)
    {
    cliCommon[connection->handleNum].isScroll = L7_TRUE;
    }

    return status;
  }
}


/*
 * ewaNetHTTPEnd
 * EmWeb/Server calls this function when request is completed.
 * The handle is one of the pointers in the handle table.
 */
EwaStatus ewaNetHTTPEnd( EwaNetHandle handle )
{
  uintf i;
  int32 found;
#ifdef L7_CAPTIVE_PORTAL_PACKAGE
  L7_inet_addr_t remote;
#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

  /* Ignore requests to end the discard handle. */
  if (EWA_NET_HANDLE_DISCARD == handle || handle->discard)
  {
    return EWA_STATUS_OK;
  }

  /* Find the connection in the Handle table */
  for ( ( i = 0
          ,found = -1
        );
      (   ( found == -1 )
          && ( i < MaxConnections )
      );
      i++
      )
  {
    if ( Handle[i] == handle )
    {
      found = i;
      EMWEB_TRACE(("ewaNetHTTPEnd: connection %p found in Handle[%d]\n",
                   handle, i));
    }
  }
  if ( found >= 0 )
  {

    /* Clear any pending buffers */

    if ( handle->pending_xmit != EWA_NET_BUFFER_NULL )
    {
      EMWEB_TRACE(( "ewaNetHTTPEnd: connection %d closing with pending "
                    "data\n"
                    ,handle->socket
                  ));

      handle->close_pending = TRUE;
      handle->context = NULL;      /* freed by Abort */
      EMWEB_TRACE(("ewaNetHTTPEnd: setting connection(%p)->context(%p) "
                   "as part of shutdown\n",
                   handle, handle->context));

    }
    else
    {
      /*
       * Close the connection and reinitialize state
       */
#ifdef EW_CONFIG_OPTION_UPNP
      if (FALSE == handle->upnp_udp_connection_flg)
#endif /* EW_CONFIG_OPTION_UPNP */
      {

        EMWEB_TRACE(( "ewaNetHTTPEnd: Close %p\n", handle ));
        if (handle->socket != -1 && 0!=closesocket(handle->socket))
        {
          EMWEB_ERROR(("ewaNetHTTPEnd: closesocket() failed, errno=%d,set closePending=%d\n",
                       errno, handle->close_pending));

        }

        else /* else  good return code from close socket */
        {

#if defined (EW_CONFIG_OPTION_SSL_RSA)
          if (handle->ssl_connection_flg == TRUE)
          {
            /*
             * let's close SSL connection and remove BIO structure
             * RSA note:
             *        SSL_free() will free associated bio structure
             *        so  BIO_free(handle->bio) will cause trouble
             *        so DO NOT DO IT here;
             */
            SSL_shutdown(handle->ssl);
            SSL_free(handle->ssl);
          }
#endif /* EW_CONFIG_OPTION_SSL_RSA */

          Handle[found] = NULL;
          ConnectionsActive--;

#ifdef L7_CAPTIVE_PORTAL_PACKAGE
          /*
          Delete from CP connection list if and when there are no more
          handles for the given remote (IP address)
          */
          remote = ewaRemoteGet(handle);
          if (L7_FALSE==ewaHandleRemoteFind(Handle,remote))
          {
            ewaCpConnListDelete(remote);
          }

#endif /* L7_CAPTIVE_PORTAL_PACKAGE */

          if (handle->handleNum < FD_CLI_DEFAULT_MAX_CONNECTIONS)
          {
          cliCurrentHandleSet(handle->handleNum);  /* lvl7_P0006 start */
          /* only logout telnet sessions here because web sessions are not recorded */
          if (cliTelnetConnectionGet() == L7_TRUE)
          {
            usmDbLoginSessionLogout(U_IDX, cliLoginSessionIndexGet());
          }                                        /* lvl7_P0006 end */
          }
          EMWEB_TRACE(("ewaNetHTTPEnd: Closed socket=%d,setConnectionsActive=%d\n", handle->socket, ConnectionsActive));
          ewaConnectionFinish(handle);

          ewaFree(handle);
        }
      }
#ifdef EW_CONFIG_OPTION_UPNP
      else /* It is a UPnP connection. */
      {
        /* We don't want to do a close() on the socket, since we will
         * be reusing it, but we do need to call ewaNetUdpSendMsg()
         * to send the buffered data out using UDP.
         */
        EMWEB_TRACE(("ewaNetHTTPEnd: Handle->upnp_udp_connection_flg = %d, calling ewaNetUdpSendMsg\n",
                     handle->upnp_udp_connection_flg));
        ewaNetUdpSendMsg(handle);
        /* Now close the internal connection record.. */
        Handle[found] = NULL;
        ConnectionsActive--;
        EMWEB_TRACE(("ewaNetHTTPEnd: Closed context = %p, net handle = %p, socket = %d, setConnectionsActive = %d\n",
                     handle->context, handle, handle->socket,
                     ConnectionsActive));
        ewaConnectionFinish(handle);
        ewaFree( handle );
      }
#endif /* EW_CONFIG_OPTION_UPNP */
    }
  }
  else
  {
    EMWEB_ERROR(( "ewaNetHTTPEnd: internal error - handle not in Handle table @ %s:%d"
                  ,__FILE__
                  ,__LINE__ ));
    ERROR_EXIT;
  }

  return EWA_STATUS_OK;
}


#ifdef EMWEB_USE_SIGNALS
/*
 * Graceful shutdown on SIGINT
 * or immediate exit on SIGQUIT
 */
static
void sig_handler ( int sig )
{
  switch ( sig )
  {
  case SIGALRM:
    /*
     * Reset alarm signal
     */
    alarm( APPLICATION_TIMER_INTERVAL );
    signal(SIGALRM, sig_handler);

    ewaTick();

#ifdef EMWEB_POSIX_OPTION_SERVER_PUSH
    {
      int i;
      EwaNetHandle connection;

      /*
       * For each possible connection
       */
      for (i = 0; i < (int) MaxConnections; i++)
      {
        connection = Handle[i];

        /*
         * If active TCP connection established
         */
        if (   ( connection != NULL )
               && ( connection->context != NULL )
           )
        {
          /*
           * Handle server side push
           */
          if ( connection->ssp_state == SSP_STATE_WAIT )
          {
            if (--connection->ssp_timeout <= 0)
            {
              connection->ssp_state = SSP_STATE_ON;
              ewsResume(connection->context, EWA_STATUS_OK);
            }
          }
        }
      }
    }
#endif /* EMWEB_POSIX_OPTION_SERVER_PUSH */
    break;

  case SIGINT:
#ifdef EW_CONFIG_OPTION_CLEANUP
    cleanup();
#endif

    /* fall through .... */

  default:
    /*
     * Abort on anything else
     */
#if defined(WIN32) || defined(_WIN32_WCE)
    WSACleanup();     /* unload WINSOCK.DLL */
#endif

#ifdef EW_CONFIG_OPTION_UPNP
    /* close the socket for outgoing udp data */
    if (upnp_client_s)
    {
      closesocket(upnp_client_s);
    }
    if (upnp_server_s)
    {
      /* ipMreq was set up earlier in setupOptionSockets() */
      setsockopt (upnp_server_s
                  ,IPPROTO_IP
                  ,IP_DROP_MEMBERSHIP
                  ,(char *)&ipMreq
                  ,sizeof (ipMreq));
    }
#endif /* EW_CONFIG_OPTION_UPNP     */

    exit(0);
    break;
  }
}
#endif  /* EMWEB_USE_SIGNALS */

void fatal_trap( const char * file, int line )
{
  EW_UNUSED( file );
  EW_UNUSED( line );

#if defined(WIN32) || defined(_WIN32_WCE)
  WSACleanup();     /* unload WINSOCK.DLL */
#endif
  exit(1);
}


static void cleanup( void )
{

#ifdef EW_CONFIG_OPTION_CLEANUP
  if (ewsShutdown() != EWS_STATUS_OK)
  {
    EMWEB_ERROR(( "ewsShutdown() failed\n"));
  }
#endif /* EW_CONFIG_OPTION_CLEANUP */

  /* Free allocated table of network handles. */
  ewaFree(Handle);
  Handle = NULL;

  /* Free allocated buffers. */
  ewaNetBufferShutdown();
}



#ifdef EW_CONFIG_OPTION_SMTP
/******************************************************************/
/*                        EmWeb/Mail Support                      */
/******************************************************************/

void ewaSMTPConfigure( uint32      ip
                       ,uint16      port
                       ,const char* domain
                     )
{
  if ( ip )
  {
    SMTP_Ip = ip;
  }
  SMTP_Port = port ? port : SMTP_WELL_KNOWN_PORT;
  if ( NULL != domain )
  {
    EMWEB_STRCPY( SMTP_Domain, domain );
  }
}

void ewaSMTPGetAddress( uint32*      ip
                        ,uint16*      port
                      )
{
  *ip = SMTP_Ip;
  *port = SMTP_Port ? SMTP_Port : SMTP_WELL_KNOWN_PORT;
}

/*
 * ewaSMTPStart
 * This function is called by the EmWeb/Mail package to initiate a TCP
 * connection with the SMTP mail gateway.  We simply create a socket,
 * connect to the gateway, and return a network handle.
 */
EwaNetHandle /* returns new network handle, or EWA_NET_HANDLE_NULL on error */
ewaSMTPStart( EwsContext context, EwaSMTPHandle handle )
{
  EwaNetHandle connection = EWA_NET_HANDLE_NULL;

  int result;
  int i;
  int found;
  int on = 1;

  EW_UNUSED(handle);

  /*
   * Create outbound SMTP connection to configured mail host
   */
  if ( ConnectionsActive < MaxConnections )
  {
    /*
     * Allocate and initialize a new network handle to represent the SMTP
     * connection.
     */
    connection = (EwaNetHandle) ewaAlloc( sizeof( EwaNetHandle_t ) );
    if ( connection != NULL )
    {
      /*
       * Create a new socket
       */
      memset( connection, 0, sizeof( EwaNetHandle_t ) );
      connection->socket = socket(AF_INET, SOCK_STREAM, 0);
      connection->context = context;
      EMWEB_TRACE(("ewaSMTPStart: setting connection(%p)->context(%p) from context argument\n",
                   connection, connection->context));

      if (!SOCKET_IS_INVALID( connection->socket ))
      {
        /*
         * For logging, we'll indicate "SMTP" instead of an
         * HTTP client address
         */
#ifdef EWA_LOG_HOOK
        strcpy(connection->sourceAddrStr, "SMTP");
#endif

#if defined(HAVE_IOCTL_FIONBIO) && \
              defined(EW_CONFIG_OPTION_SCHED_FC) && \
                !defined(WIN32)
        /*
         * Set non-blocking I/O
         */
        osapiSocketNonBlockingModeSet(connection->socket, L7_TRUE);
#endif

        /*
         * Assign to table of network handles
         */
        for ( ( i = FD_CLI_DEFAULT_MAX_CONNECTIONS
                ,found = -1
              );
            (   ( found == -1 )
                && ( (unsigned) i < MaxConnections )
            );
            i++
            )
        {
          if ( Handle[i] == NULL )
          {
            found = i;
            break;
          }
        }

        if ( found >= 0 )
        {
          Handle[found] = connection;
          ConnectionsActive++;
          /* LVL7_P0006 start */
          if (master_socket == telnet_s)
          {
            ConnectionsActiveTelnet++;
          }
          /* LVL7_P0006 end */

          EMWEB_TRACE(( "ewaSMTPStart: Open %p %d\n"
                        ,connection
                        ,connection->socket
                      ));

          if(FALSE == ewaConnectionInit( connection ))
          {
            ewaNetHTTPEnd( connection );
            return NULL;
          }
        }
        else
        { /*
          EMWEB_ERROR(( "EmWeb: internal error - Handle table overflow @%s:%d"
                        ,__FILE__
                        ,__LINE__ ));
          ERROR_EXIT;
          */
            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                    "Handle table overflow");
            close( connection->socket );
            ewaFree( connection );
            connection = NULL;
        }

        /*
         * Establish connection to SMTP mail gateway
         */
        {
          struct sockaddr_in in;
          in.sin_family = AF_INET;
          in.sin_port = osapiHtons(SMTP_Port);
          in.sin_addr.s_addr = osapiHtonl(SMTP_Ip);
          result = connect( connection->socket
                            ,(struct sockaddr *) &in
                            ,sizeof(in)
                          );
          if (result && errno != EINPROGRESS && errno != EWOULDBLOCK)
          {
            EMWEB_WARN(("ewaSMTPStart: Connect failed\n"));
            if (0 !=closesocket( connection->socket ))
            {
              EMWEB_WARN(("ewaSMTPStart: closesocket failed for socket= %d, errno=%d\n"
                          ,connection->socket
                          ,errno));
            }
            ewaConnectionFinish(connection);
            ewaFree( connection );
            Handle[found] = NULL;
            /* LVL7_P0006 start */
            if (master_socket == telnet_s)
            {
              ConnectionsActiveTelnet--;

            }    /* LVL7_P0006 end */
            ConnectionsActive--;
            connection = EWA_NET_HANDLE_NULL;
          }
        }
      }
      else
      {
        EMWEB_WARN(( "ewaSMTPStart: socket open failed"));
        ewaConnectionFinish(connection);
        ewaFree( connection );
        connection = NULL;
      }
    }
    else
    {
      /* Error allocating the net handle */
      EMWEB_ERROR(( "EmWeb: memory allocation failed @%s:%d"
                    ,__FILE__
                    ,__LINE__ ));
      ERROR_EXIT;
    }

  }

  return connection;
}

/*
 * ewaSMTPDomainName
 * This function simply returns the name of the SMTP domain.
 */
char *
ewaSMTPDomainName ( EwsContext context, EwaSMTPHandle handle )
{
  EW_UNUSED(context);
  EW_UNUSED(handle);
  return SMTP_Domain;
}
#endif /* EW_CONFIG_OPTION_SMTP */

#ifdef EW_CONFIG_OPTION_CLIENT
/*
 * ewaClientConnectRequest
 * This function is called by the EmWeb/Client package to initiate a TCP
 * connection for an outbound HTTP request.  We simply create a socket,
 * connect to the host, and return a network handle.
 *
 * context - context of request
 * host    - "host:port" for connection, or NULL for cache connection
 */
EwaNetHandle /* returns new network handle, or EWA_NET_HANDLE_NULL on error */
ewaClientConnectRequest( EwsContext context
                         ,const char * host)
{
  EwaNetHandle connection = EWA_NET_HANDLE_NULL;

  int result;
  int i;
  int found;
  uint16 HTTP_Port = HTTP_WELL_KNOWN_PORT;
  uint32 HTTP_Ip;
  char *cp;
  struct hostent *hostentP;
  int on = 1;

  /*
   * If host specified (always, except in special case where we need
   * to attach a network handle to a context without actually creating
   * a connection during a read from cache
   */
  if (host != NULL)
  {
    /*
     * Get HTTP_Port for connection
     */
    cp = strchr(host, ':');
    if (cp != NULL)
    {
      sscanf(cp+1, "%d", &i);
      HTTP_Port = i;
      *cp = '\0';
    }

    /*
     * Get HTTP_Ip for connection
     */
    hostentP = gethostbyname(host);
    if (cp != NULL)
    {
      *cp = ':';
    }
    if (hostentP == NULL)
    {
#if defined(_WIN32_WCE)
      /* Additional attempt to find the host name because CE would not
         accept a dotted IP string as input to the gethostbyname function.
         This works for CE.
       */
      if (cp != NULL )
      {
        *cp = 0;
      }
      if ((HTTP_Ip = inet_addr(host))==INADDR_NONE)
      {
        EMWEB_WARN(("ewaClientConnectRequest: can't resolve %s\n", host));
        return EWA_NET_HANDLE_NULL;
      }
      if (cp != NULL )
      {
        *cp = ':';
      }

#else
      EMWEB_WARN(("ewaClientConnectRequest: can't resolve %s\n", host));
      return EWA_NET_HANDLE_NULL;
#endif
    }
#if defined(_WIN32_WCE)
    if (HTTP_Ip==INADDR_NONE)
#endif
      memcpy(&HTTP_Ip, hostentP->h_addr, sizeof(HTTP_Ip));
  }

  /*
   * Create outbound HTTP connection to specified host:port
   */
  if ( ConnectionsActive < MaxConnections )
  {
    /*
     * Allocate and initialize a new network handle to represent the HTTP
     * connection.
     */
    connection = (EwaNetHandle) ewaAlloc( sizeof( EwaNetHandle_t ) );
    if ( connection != NULL )
    {
      /*
       * Create a new socket
       */
      memset( connection, 0, sizeof( EwaNetHandle_t ) );
      connection->context = context;
      EMWEB_TRACE(("ewaClientConnectRequest: setting connection(%p)->context(%p) from context argument\n",
                   connection, connection->context));

      if (host != NULL)
      {
        connection->socket = socket(AF_INET, SOCK_STREAM, 0);
      }
      else
      {
        connection->socket = -1;
      }

      if (!SOCKET_IS_INVALID( connection->socket ) || host == NULL)
      {
        /*
         * For logging, we'll indicate "CLIENT" or "CACHE" instead of an
         * HTTP client address
         */
#ifdef EWA_LOG_HOOK
        strcpy(connection->sourceAddrStr
               ,host != NULL ? "CLIENT" : "CACHE" );
#endif

#if defined(HAVE_IOCTL_FIONBIO) && \
              defined(EW_CONFIG_OPTION_SCHED_FC) && \
                !defined(WIN32)
        /*
         * Set non-blocking I/O
         */
        if (host != NULL)
        {
          osapiSocketNonBlockingModeSet(connection->socket, L7_TRUE);
        }
#endif

        /*
         * Assign to table of network handles
         */
        for ( ( i = FD_CLI_DEFAULT_MAX_CONNECTIONS
                ,found = -1
              );
            (   ( found == -1 )
                && ( (unsigned) i < MaxConnections )
            );
            i++
            )
        {
          if ( Handle[i] == NULL )
          {
            found = i;
            break;
          }
        }

        if ( found >= 0 )
        {
          Handle[found] = connection;
          ConnectionsActive++;

          EMWEB_TRACE(( "Open %p %d\n"
                        ,connection
                        ,connection->socket
                      ));

          if(FALSE == ewaConnectionInit( connection ))
          {
            ewaNetHTTPEnd( connection );
            return NULL;
          }
        }
        else
        { /*
          EMWEB_ERROR(( "EmWeb: internal error - Handle table overflow @%s:%d"
                        ,__FILE__
                        ,__LINE__ ));
          ERROR_EXIT;
          */
            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_CLI_WEB_COMPONENT_ID,
                    "Handle table overflow");
            ewaConnectionFinish(connection);
            if(connection->context)
            {
              ewaFree(connection->context);
              connection->context=NULL;
            }
            close( connection->socket );
            ewaFree( connection);
            connection = EWA_NET_HANDLE_NULL;

        }

        /*
         * Establish connection to HTTP host
         */
        if (host != NULL)
        {
          struct sockaddr_in in;
          in.sin_family = AF_INET;
          in.sin_port = osapiHtons(HTTP_Port);
          in.sin_addr.s_addr = osapiHtonl(HTTP_Ip);
          connection->connect_pending = TRUE;
          result = connect( connection->socket
                            ,(struct sockaddr *) &in
                            ,sizeof(in)
                          );
          if (result && errno != EINPROGRESS && errno != EWOULDBLOCK)
          {
            EMWEB_WARN(("ewaClientConnectRequest(): Connect failed %d\n", errno));
            if (0 !=closesocket( connection->socket ))
            {
              EMWEB_WARN(("ewaClientConnectRequest() closesocket failed for socket= %d, errno=%d\n"
                          ,connection->socket
                          ,errno));
            }
            ewaConnectionFinish(connection);
            if(connection->context)
            {
              ewaFree(connection->context);
              connection->context=NULL;
            }
            ewaFree(connection );
            Handle[found] = NULL;
            ConnectionsActive--;
            connection = EWA_NET_HANDLE_NULL;
          }
        }
      }
      else
      {
        EMWEB_WARN(( "ewaClientConnectRequest() socket open failed"));
        ewaConnectionFinish(connection);
        ewaFree( connection );
        connection = NULL;
      }
    }
    else
    {
      /* Error allocating the net handle */
      EMWEB_ERROR(( "EmWeb: memory allocation failed @%s:%d"
                    ,__FILE__
                    ,__LINE__ ));
      ERROR_EXIT;
    }

  }

  return connection;
}
#endif /* EW_CONFIG_OPTION_CLIENT */


#ifdef EW_CONFIG_OPTION_IN_FLOW
/*
 * ewaNetFlowControl and ewaNetUnFlowControl
 * Regulate inbound buffers - the application may call these when,
 * for example, suspending processing of a context, to prevent TCP
 * from passing more buffers in to the server.  TCP flow control
 * will automatically propogate this to the sender.
 *
 * The EmWeb/Server does not call these itself.
 */

void ewaNetFlowControl( EwaNetHandle connection )
{
  EMWEB_TRACE(("in flow control %d\n", connection->socket));
  connection->in_flow_control = TRUE;
}

void ewaNetUnFlowControl( EwaNetHandle connection )
{
  EMWEB_TRACE(("in un flow control %d\n", connection->socket));
  connection->in_flow_control = FALSE;
}
#endif /* EW_CONFIG_OPTION_IN_FLOW */

#if defined (EW_CONFIG_OPTION_SSL_RSA)
/*****************************************************************
 *
 * PasswdCheck()
 *
 * ATTENTION: EmWeb server user may want to implement his/her own version
 * !!!!!!!!!!
 *
 *****************************************************************/
static int PasswdCheck(char *buf, int len, int verify)
{
  EW_UNUSED(buf);
  EW_UNUSED(len);
  EW_UNUSED(verify);
  return(0);
}

/*****************************************************************
 *
 * sslInit()
 *
 *****************************************************************/
static boolean sslInit( void )
{

  /* initialize SSL library */
  SSL_library_init();
  SSL_load_error_strings();

  /*
   * create SSL context (processing information, including verion
   * of SSL to be used. We want SSL v3 but for now let's also try v2),
   * can be used by many SSL connections.
   *
   * We have one SSL context per EmWeb server
   *
   */
  ssl_ctx = SSL_CTX_new(SSLv23_server_method());
  if (ssl_ctx == NULL)
  {
    EMWEB_ERROR(("SSL/RSA no global context: SSL_CTX_new() failed \n"));
    return(FALSE);
  }

  /*
   * turn on bug compatibility option
   */
  SSL_CTX_set_options(ssl_ctx, SSL_OP_ALL);


  if (SSL_CTX_set_tmp_key_mode(ssl_ctx, SSL_TMP_512_RSA, SSL_TMP_GENERATE_LATER) != 1)
  {
    EMWEB_ERROR(("SSL/RSA key mode setup: SSL_CTX_set_tmp_key_mode() failed \n"));
    return(FALSE);
  }

  if (SSL_CTX_use_certificate_ASN1 (ssl_ctx, XXX_certificate, SSL_CERTIFICATE_LEN) != 1)
  {
    EMWEB_ERROR(("SSL/RSA certificate setup: SSL_CTX_use_certificate_ASN1() failed \n"));
    return(FALSE);
  }

  /*
   *  ATTENTION: you may want to implement own PasswdCheck()
   */
  SSL_CTX_set_default_passwd_cb(ssl_ctx, PasswdCheck);

  if (SSL_CTX_use_RSAPrivateKey (ssl_ctx, get_rsa1024_priv_XXX()) != 1)
  {
    EMWEB_ERROR(("SSL/RSA key setup: SSL_CTX_use_RSAPrivateKey() failed \n"));
    return(FALSE);
  }

  if (SSL_CTX_check_private_key (ssl_ctx) != 1)
  {
    EMWEB_ERROR(("SSL/RSA key check: SSL_CTX_check_private_key() failed \n"));
    return(FALSE);
  }

  /*
   * select cipher to use.
   *
   * DEFAULT:!EXP selects all compiled ciphers (server will try to use the strongest
   * available cipher)  and exclude export ciphers
   *
   *  if (SSL_CTX_set_cipher_list(ssl_ctx, "DEFAULT:!EXP") == 0)
   *
   *  ATTENTION: you may want to select another cipher (make sure your
   *             browser will support it)
   */

  if (SSL_CTX_set_cipher_list(ssl_ctx, (char *) "DEFAULT") == 0)
  {
    EMWEB_ERROR(("SSL/RSA set cipher: SSL_CTX_set_cipher() failed \n"));
    return(FALSE);
  }

  return(TRUE);
}

/********************************************************************
 *
 * sslConnectionInit()
 *
 * There is a connection comming on SSL port.
 * Initialize SSL structures, start SSL handshake.
 *
 * NOTE: this function does not do ewsNetHTTPStart(). We will do it when
 *       SSL handshake is done (ssl_state[sslStateHandshake -> sslStateUp])
 *
 ********************************************************************/
static boolean
sslConnectionInit ( EwaNetHandle net_handle )
{
  SSL          *ssl;       /* SSL connection context */
  BIO          *ssl_bio;
  int          ssl_err;

  EMWEB_TRACE(("sslConnectionInit(%p)\n", net_handle));

  /*
   * Create structures for SLL connection
   */
  ssl = SSL_new(ssl_ctx);
  if (ssl == NULL)
  {
    EMWEB_WARN(("sslConnectionInit:  SSL_new() failed\n"));
    return(FALSE);
  }

  /*
   * do some more setups (?)
   */
  SSL_set_accept_state(ssl);
  SSL_set_session(ssl, NULL);
  SSL_clear(ssl);

  /*
   * bind SSL structure with underlaying i/o structure
   */
  ssl_bio = BIO_new_socket(net_handle->socket, BIO_NOCLOSE);
  ssl_err = BIO_set_nbio(ssl_bio, 1); /* 1 = non-blocking */
  SSL_set_bio(ssl, ssl_bio, ssl_bio);

  net_handle->bio = ssl_bio;
  net_handle->ssl = ssl;
  net_handle->ssl_connection_flg = TRUE;

#ifdef EW_CONFIG_OPTION_UPNP
  net_handle->upnp_udp_connection_flg = FALSE;
#endif

  /*
   * start handshake process
   */

  net_handle->ssl_state = sslStateHandshake;
  if ( (ssl_err = SSL_do_handshake(ssl)) != 1)
  {
    ssl_err = SSL_get_error(ssl, ssl_err);
    switch (ssl_err)
    {
    case SSL_ERROR_WANT_READ:
    case SSL_ERROR_WANT_WRITE:
    case SSL_ERROR_WANT_X509_LOOKUP:
    case SSL_ERROR_WANT_CONNECT:
      /*
       * these errors just mean that the operation would have blocked
       */
      break;
    default:
      EMWEB_WARN(("ewsNetSSLStart: SSL_do_handshake() failed, error = %d\n", ssl_err));
      return(FALSE);
    }
  }

  return(TRUE);
}

  #ifdef EW_CONFIG_OPTION_SIGSETJMP
int __sigsetjmp(void *env, int savesigs)
{
  return(setjmp((jmp_buf*)env));
}
  #endif

#endif /* EW_CONFIG_OPTION_SSL_RSA */


#ifdef EW_CONFIG_OPTION_UPNP
/******************************************************************/
/*                        EmWeb UPNP Support                      */
/******************************************************************/
/**********************************************************************
 *
 *  ewaNetUdpSendMsg
 *
 *  Purpose: Call this function when it is time to actually send the
 *           UDP data out over the network.
 *           It can be called directly by EmWeb/Server, or called by
 *           ewaNetHTTPEnd().
 *  Inputs:  EwaNetHandle - contains pointer to udp_xmit_buffer where
 *           data is actually transmitted from.
 *           contains a flag to indicate if sending it MULTICAST or
 *           using the 'fromAddr' field in the nethandle.
 *
 *  Outputs: NetHandle->udp_xmit_buffer is reset and udp_xmit_buflen=0
 *
 *  Returns: EwaStatus EWA_STATUS_OK or EWA_STATUS_ERROR
 *
 */
EwaStatus
ewaNetUdpSendMsg ( EwaNetHandle net_handle )
{
  EwaStatus status = EWA_STATUS_OK;
  int bytes;
  struct sockaddr_in sendToAddr;
  int sendToAddrLen;


  /* we should not need to do any size checking - because it should have been
     taken care of it fillUdpXmitBuffer(), but maybe add in as part of
     EMWEB_SANITY.
  */
  ClearErrno();
  /* Maybe add check for udp_xmit_buflen != 0 before actually send out the data ! */
  if (net_handle->udp_xmit_buflen <= 0)
  {
    EMWEB_TRACE(("ewaNetUdpSendMsg: udp_xmit_buflen <= 0, returning without sending\n"));
    status = EWA_STATUS_ERROR;
    return(status);
  }
  /* Now figure out if we are going to send this to the multicast address
     (i.e. it is a NOTIFY message which has been initiated by SSDP) or if
     we are *responding* to a multicast request.
     We look at the net handle flag  is_multicast_msg to determine what
     address we are goind to use. unicast or multicast
  */
  if (net_handle->isMulticastMsg)
  {
    /* Set up the destination address structure. */
    memset ((char *)&sendToAddr, 0, sizeof (sendToAddr));
    sendToAddrLen = sizeof (struct sockaddr);
    sendToAddr.sin_family      = AF_INET;
    /* initialize the address to the send */
    sendToAddr.sin_addr.s_addr = inet_addr(EWU_SSDP_MCAST_ADDR);
    /* initialize the port to send */
    sendToAddr.sin_port        = osapiHtons(EWU_SSDP_PORT);
  }
  else
  {
    sendToAddr = net_handle->fromAddr;
    sendToAddrLen = net_handle->fromAddrLen;
  }

  bytes = sendto( net_handle->socket
                  ,net_handle->udp_xmit_buffer
                  ,net_handle->udp_xmit_buflen
                  ,0 /* no flags */
                  ,(struct sockaddr *)&sendToAddr
                  ,sendToAddrLen
                );
  if (bytes >0)
  {
    ewsBytesSent +=bytes;  /* update statistics */
    if (bytes !=net_handle->udp_xmit_buflen)
    {

      EMWEB_WARN(("ewaNetUdpSendMsg(): actual bytes sent in sendto()=%d, "
                  "does not match udp_xmit_buflen specified=%d!\n"
                  ,bytes
                  ,net_handle->udp_xmit_buflen));
    }

  }
  else if (bytes < 0)
  {
    EMWEB_WARN(( "ewaNetUdpSendMsg(): data sent on socket %d failed "
                 "(errno = %d)\n"
                 ,net_handle->socket
                 ,errno ));
    if (ENETUNREACH == errno)
    {
      EMWEB_WARN(( "Check that a route exists for the multicast port "
                   EWU_SSDP_MCAST_ADDR
                   " that is directed to the interface for UPnP "
                   "communications\n" ));
      EMWEB_WARN(( "You can create one manually by something like "
                   "'route add -net 239.0.0.0 netmask 255.0.0.0 eth0'\n"
                 ));
    }
    status = EWA_STATUS_ERROR;
  }
  /* Whether there was an errno or not, let's free up the udp_xmit_buffer and
     reset udp_xmit_buflen in the net_handle. We do not RESEND the udp data and
     the calling functions do not try to do any retransmissions of this data
     either, at this point.
  */
  net_handle->udp_xmit_buflen = 0;
  if (net_handle->udp_xmit_buffer)
  {
    ewaFree(net_handle->udp_xmit_buffer);
    net_handle->udp_xmit_buffer = NULL;
  }
  return status;
}

/**********************************************************************
 *
 *  udpRecvData()
 *
 *   Purpose: This function is called to receive UDP data into the
 *          a dynamically allocated buffer and then copied into
 *          the appropriate number of network buffers which are chained
 *          together.  If this is successful, then  forward
 *          the data to EmWeb/Server.
 *          1. allocate a network buffer
 *          2. call recvfrom() twice - first to get the size of the data,
 *             second to read the data off the queue.  Uses a local buffer.
 *          3. if everything is okay, copy from local buffer to chain
 *             (if needed) of network buffers.
 *          4. if recv call was successful, forward data to EmWeb/Server.
 *          5. free up local buffer,udpRecvBufp.
 *          6. If some error occured, free up the network buffer allocated
 *             in step 1.
 *          7. Send EOF by calling ewsNetEOF().
 *  Inputs:  connection - network handle
 *
 *  Outputs: connection->bytes - actual number of udp bytes received.
 *           (-1) indicates an error.
 *
 *  Returns:  void
 *
 */
static
void udpRecvData( EwaNetHandle connection)
{
  struct sockaddr_in fromAddr;  /* the address from which the data was
                                 * received */
  EW_SIZE_T fromLen;
  EwaNetBuffer currentBuffer;   /* the network buffer to be copied into */
  EwaNetBuffer newBuffer;       /* newly allocated network buffer */
  int bytesReceived=0;              /* number of bytes received in packet */
  uint8 *udp_bufptr;             /* pointer to the udp buffer to copy
                                 * from */
  unsigned bytesRemaining;                   /* bytes of input left to copy to buffers */
  int bytesToCopy;                      /* bytes of input to copy into next buffer */
  EwaNetBuffer buffer;      /* first network buffer in the chain */
  static uint8 recv_buffer[EWU_MAX_PKT_SIZE+1]; /* rx buffer */
  EwsStatus status;


  EMWEB_TRACE(("Enter udpRecvBuffer(%p)\n",connection));

  /* initialization */
  memset(&fromAddr, 0, sizeof (fromAddr));
  fromLen = sizeof(fromAddr);
  ClearErrno();
  bytesReceived = recvfrom( connection->socket
                            ,recv_buffer
                            ,sizeof(recv_buffer)
                            ,0
                            ,(struct sockaddr *)&fromAddr
                            ,(EW_SIZE_T *) &fromLen
                          );

  if (bytesReceived <0)
  {
    EMWEB_TRACE(("udpRecvData: recvfrom() errno=%d, bytesReceived=%d"
                 ,errno
                 ,bytesReceived));
    return;
  }
  else
  {
    if (bytesReceived >= (int) sizeof (recv_buffer))
    {
      EMWEB_TRACE(("udpRecvData: Incoming UDP packet may have been "
                   "truncated at buffer length (%d), recvfrom() "
                   "return value = %d.\n"
                   ,sizeof(recv_buffer)
                   ,bytesReceived));
      bytesReceived = sizeof(recv_buffer);
    }

    connection->fromAddr = fromAddr; /* This is a structure copy. */
    connection->fromAddrLen = fromLen;

    EMWEB_TRACE(("udpRecvData: received %d bytes\n", bytesReceived));


    /*
     * Get initial buffer
     */
    buffer = ewaNetBufferAlloc();
    if (buffer == EWA_NET_BUFFER_NULL)
    {
      EMWEB_WARN(("udpRecvData: can't get initial buffer\n"));
      return;
    }

    /* Copy received data into 'buffer'.  Allocate and chain on additional
     * buffers as needed.
     * We also set connection->bytes = bytesReceived or -1 (which
     * indicates an error).
     */
    for (   currentBuffer = buffer
            ,bytesRemaining = bytesReceived
            ,udp_bufptr = recv_buffer
            ;
        ;
        )
    {
      /* Copy only as many bytes as the buffer will hold. */
      bytesToCopy =
      bytesRemaining < ewaNetBufferLengthGet(currentBuffer) ?
      bytesRemaining : ewaNetBufferLengthGet(currentBuffer);

      /* Copy the data. */
      EMWEB_TRACE(("udpRecvData: copying %d bytes into buffer %p\n",
                   bytesToCopy, currentBuffer));
      memcpy(ewaNetBufferDataGet(currentBuffer)
             ,udp_bufptr
             ,bytesToCopy);
      ewaNetBufferLengthSet(currentBuffer, bytesToCopy);
      bytesRemaining -= bytesToCopy;

      /* If we have copied all the bytes, exit this loop. */
      if (bytesRemaining == 0)
      {
        connection->bytes = bytesReceived;
        break;
      }

      /* More bytes remain to copy, so get another buffer. */
      udp_bufptr += bytesToCopy;
      newBuffer = ewaNetBufferAlloc();

      /* If no buffer is available, we have to free all buffers other
       * than 'buffer' and return as if we got an error.
       */
      if (NULL == newBuffer)
      {
        EMWEB_WARN(("udpRecvData: can't get subsequent buffer\n"));
        ewaNetBufferFree(buffer);
        return;
      }

      /* Chain new buffer to previous buffer. */
      ewaNetBufferNextSet(currentBuffer, newBuffer);
      currentBuffer = newBuffer;
    } /* for loop */
  }
  /* Send the data to the Server. */
  status = ewsNetHTTPReceive( connection->context
                              ,buffer
                            );
  if (status != EWS_STATUS_OK)
  {
    EMWEB_ERROR(( "ewsNetHTTPReceive() failed: %d\n", status));
    ewaNetBufferFree(buffer);
    return;
  }
  ewsNetEOF(connection->context);
  return;
}

/* ewaNetUdpOutStart()
   Used to establish a connection which is used to send NOTIFYs.
  Call ewaSsdpNewConnection( SOCKET master_socket, boolean isMulticastMsg );
  which is similar to ewaNewConnection().
  Note that ewaSsdpNewConnection() is also called by ewmain() when there
  the select() indicates that there is something for fd read_ready,
  and it is for the upnp_server_s socket.
  Pass in the flag TRUE to indicate it will be a multicast address.

  Returns EWA_NET_HANDLE_NULL if the connection cannot be established
  (because the internal handle table is full).
*/

EwaNetHandle ewaNetUdpOutStart(EwsContext context)
{
  boolean isMulticastMsg=TRUE; /*ssdp wants to send the msg out via MULTICAST*/
  boolean doGetContext = FALSE; /* don't make a call to ssdp to get the context
                                   since we pass context in as the arg */

  EMWEB_TRACE(("ewaNetUdpOutStart: call ewaSsdpNewConnection"));

  /* If no more connections can be accepted, reject the request. */
  if (ConnectionsActive >= MaxConnections)
  {
    return EWA_NET_HANDLE_NULL;
  }

  EMWEB_TRACE(("ewaNetUdpOutStart: call ewaSsdpNewConnection\n"));
  return ewaSsdpNewConnection(upnp_client_s, isMulticastMsg, doGetContext,
                              context);
}

/**********************************************************************
 *
 *  fillUdpXmitBuffer
 *
 *  Purpose: take the network buffers and check if all the network buffers
 *  will fit into the udp transmit buffer (which is allocated dynamically).
 *  Note the size of the data actually sent out is governed by the
 *  customer defined UPNP constant EWU_MAX_UDP_PKT_SIZE.
 *
 *  Inputs:  the net_handle (connection)
 *
 *  Returns: EwaStatus (EWA_STATUS_ERROR or EWA_STATUS_OK).
 *
 *  Note: fillUdpXmitBuffer() is called by ewaNetHTTPSend().
 *        SSDP calls ewaNetHTTPSend() for one complete notification.
 *
 */

static EwaStatus fillUdpXmitBuffer( EwaNetHandle connection)
{
  EwaNetBuffer buffer;
  EwaNetBuffer next_buffer;
  EwaStatus status=EWA_STATUS_OK;
  boolean ok;
  char *bufp;
  int current_bufferlen;
  static int udp_bytes = 0;
  int didFreePendingXmit = 0;
  EMWEB_TRACE(("Enter fillUdpXmitBuffer connection = (%p)\n",connection));

  if (connection->upnp_udp_connection_flg == FALSE)
  {
    EMWEB_ERROR(("fillUdpXferBuffer():  called erroneously for NON udp connection !\n"));
    return EWA_STATUS_ERROR;
  }

  /*
   * Follow chain of buffers, copying the contents of each to connection->udp_xmit_buffer
   * (before the actual copy, we ensure that everything will fit into the buffer).
   */
  for ( ( ok = TRUE
          ,buffer = connection->pending_xmit
        );
      (   ( ok )
          && ( buffer != EWA_NET_BUFFER_NULL )
      );
      buffer = next_buffer
      )
  { /* for loop */

    int bytes_to_be_sent = (int) ewaNetBufferLengthGet( buffer );
    ClearErrno();

    /* If it is a udp connection, cobble up the data and  copy
       it the udp_xmit_buffer in the netHandle AND keep track
       of how much data is in the buffer.  That way we
       can ensure that it will fit in a udp packet.
       We use  EWU_MAX_PKT_SIZE constant to be the max size
       acceptable.
    */
    current_bufferlen = ewaNetBufferLengthGet(buffer);
    if (current_bufferlen > EWU_MAX_PKT_SIZE)
    {
      /* we can never exceed the max udp packet size.
         Log an error message and return and error.
      */
      EMWEB_ERROR(("fillUdpXmitBuffer(): buffer to be sent (len=%d) EXCEEDS max udp len (=%d)\n",
                   current_bufferlen, EWU_MAX_PKT_SIZE));
      /* Free up the dynamically allocated buffer at this point.
         We do not want to transmit an incomplete NOTIFY message
         via ewaNetUdpSendMsg().
      */
      if (connection->udp_xmit_buffer)
      {
        ewaFree(connection->udp_xmit_buffer);
        connection->udp_xmit_buffer = NULL;
        connection->udp_xmit_buflen = 0;
      }
      status = EWA_STATUS_ERROR;
      break;
    }
    else
    { /* else we are within the max value EWU_MAX_PKT_SIZE */
      bufp = connection->udp_xmit_buffer;
      /* Let's look at the buffer length of what we already have
         in the udp buffer in the net handle.
      */
      if (0 == connection->udp_xmit_buflen)
      {
        /* first time.
           Allocate one buffer the max size allowable - EWU_MAX_PKT_SIZE.
           We will keep track of where we are in the buffer by
           setting connection->udp_xmit_buflen to indicate the current size
           of data in the buffer.
        */
        if (connection->udp_xmit_buffer == NULL)
        {
          connection->udp_xmit_buffer = (char *) ewaAlloc(EWU_MAX_PKT_SIZE);
          if (connection->udp_xmit_buffer == NULL)
          {
            EMWEB_ERROR(("fillUdpXmitBuffer(): ewaAlloc failed"));
            status = EWA_STATUS_ERROR;
            break;
          }
        }
        else
        {
          /* sanity check: connection->udp_xmit_buffer should always be NULL
             at this point ! */
          EMWEB_WARN(("fillUdpXmitBuffer(): connection->udp_xmit_buffer should be NULL and is not for first copy of data!\n"));
        }
        connection->udp_xmit_buflen = current_bufferlen;
        memcpy(connection->udp_xmit_buffer
               ,ewaNetBufferDataGet(buffer)
               ,current_bufferlen);
        udp_bytes = current_bufferlen;
      }
      else
      {
        /* connection->udp_xmit_buflen is nonzero.  Let's check that we
           will not EXCEED the maximum buffer size that we can write to.
        */
        if ((connection->udp_xmit_buflen + current_bufferlen) >
            EWU_MAX_PKT_SIZE)
        {
          EMWEB_ERROR(("fillUdpXmitBuffer(): total msg size (%d) EXCEEDS max udp len (=%d)\n",
                       current_bufferlen + connection->udp_xmit_buflen,
                       EWU_MAX_PKT_SIZE));
          status = EWA_STATUS_ERROR;
          /* Free up the dynamically allocated buffer at this point.
             We do not want to transmit an incomplete NOTIFY message
             via ewaNetUdpSendMsg().
          */
          if (connection->udp_xmit_buffer)
          {
            ewaFree(connection->udp_xmit_buffer);
            connection->udp_xmit_buffer = NULL;
            connection->udp_xmit_buflen = 0;
          }
          break;
        }
        else
        {
          memcpy(connection->udp_xmit_buffer +
                 connection->udp_xmit_buflen
                 ,ewaNetBufferDataGet(buffer)
                 ,current_bufferlen);


          connection->udp_xmit_buflen += current_bufferlen;

          udp_bytes = current_bufferlen;
        }
      }
    }
    /* If we have an error, this means we could not
       fit this buffer of data into the nethandle's udp_xmit_buffer
       so break out and return an error.
    */
    if (status != EWA_STATUS_OK)
    {
      EMWEB_ERROR(("fillUdpXmitBuffer(): cannot fit all the data into the max datagram size"));
      break;
    }
    if (udp_bytes > 0 )
    {
      /*
       * Some data was copied, so adjust the buffer's pointers to record
       * that fact.
       */
      ewsBytesSent+=udp_bytes;
      ewaNetBufferDataSet( buffer
                           ,ewaNetBufferDataGet( buffer ) + udp_bytes
                         );
      ewaNetBufferLengthSet( buffer
                             ,bytes_to_be_sent - udp_bytes
                           );
    }
    /* The entire contents of this buffer have been copied, so it should
     * be freed.
     * 'next_buffer' is the next buffer to be examined in the enclosing
     * for() loop, so we have to set it now, before we free 'buffer'.
     */
    if (udp_bytes == bytes_to_be_sent)
    {
      next_buffer = ewaNetBufferNextGet( buffer );

      /* That buffer was transmitted so unchain and free it */
      ewaNetBufferNextSet( buffer, EWA_NET_BUFFER_NULL );
      ewaNetBufferFree( buffer );
      if (buffer ==connection->pending_xmit)
      {
        didFreePendingXmit=1;
      }
    }
    else
    {
      /*
       * Not all of this buffer was copied
       * 'next_buffer' is set to be 'buffer', so the next iteration of
       * the loop will attempt to copy the remainder of the data.
       */

      next_buffer = buffer;
    }

  } /* end of for loop */
  /* we don't want to transmit any more data if we found an error.  Only if
     there were no error encountered here ! */
  if (status== EWA_STATUS_OK)
  {
    connection->pending_xmit = buffer;
  }
  if (status == EWA_STATUS_ERROR)
  {
    if (!didFreePendingXmit)
    {
      ewaNetBufferFree(connection->pending_xmit);
    }
    connection->pending_xmit = EWA_NET_BUFFER_NULL;
  }
  return(status);
} /* END function fillUdpXmitBuffer */

/*
 * Timer service routines for UPnP functions.
 *
 * Note that this implementation is NOT thread-safe; it assumes that all calls
 * are from the same thread and thus interlocked from each other.
 */


/* The null timer handle, for use by EWA_TIMER_HANDLE_NULL. */
EwaTimerHandle ewaTimerHandleNull = EWA_TIMER_HANDLE_NULL_INITIALIZER;


EwaTimerHandle ewaTimerSetEvent(uint32 timeout, EwaTimerWakeupFunc wakeupFunc,
                                EwsContext context, void *opaquePtr)
{
  EwaTimerEvent *newTimerEntry;
  EwaTimerEvent **p;
  EwaTimerHandle newHandle;
  time_t triggerTime;
  static uint32 seqNoGenerator = 0;

  /* Allocate a EwaTimerEvent structure. */
  newTimerEntry = (EwaTimerEvent *) ewaAlloc(sizeof (EwaTimerEvent));
  if (NULL == newTimerEntry)
  {
    EMWEB_ERROR(("ewaTimerSetEvent: Cannot allocate timer event "
                 "structure\n"));
    ERROR_EXIT;
  }

  /* Fill the structure. */
  newTimerEntry->triggerTime = triggerTime = time(NULL) + timeout;
  newTimerEntry->wakeupFunc = wakeupFunc;
  newTimerEntry->context = context;
  newTimerEntry->opaquePtr = opaquePtr;
  newTimerEntry->seqNo = seqNoGenerator++;
  newTimerEntry->magic = EWA_TIMER_MAGIC;

  /* Find the correct location to insert this request in the queue. */
  for (p = &timerRequestListPtr;
      *p != NULL && (*p)->triggerTime < triggerTime;
      p = &((*p)->next))
  {
    ;
  }
  newTimerEntry->next = *p;
  *p = newTimerEntry;

  EMWEB_TRACE(("ewaTimerSetEvent: handle = %p, seqNo = %d, triggerTime = %d\n",
               newTimerEntry, newTimerEntry->seqNo, (int) triggerTime));

  newHandle.event = newTimerEntry;
  newHandle.seqNo = newTimerEntry->seqNo;
  return newHandle;
}


EwaTimerHandle ewaTimerSetEventRandom(uint32 timeout,
                                      EwaTimerWakeupFunc wakeupFunc,
                                      EwsContext context, void *opaquePtr)
{
  return ewaTimerSetEvent(rand() % timeout, wakeupFunc, context, opaquePtr);
}


EwaStatus ewaTimerCancelEvent(EwaTimerHandle tHandle)
{
  EwaTimerEvent **p;

  /*
   * Check that the magic number is correct and the sequence number in the
   * handle matches the sequence number in the event structure.
   * Otherwise, we're looking at an obsolete handle and should ignore it.
   */
  if (!(   NULL != tHandle.event
           && EWA_TIMER_MAGIC == tHandle.event->magic
           && tHandle.seqNo == tHandle.event->seqNo))
  {
    return EWA_STATUS_OK;
  }

  /* Find the link pointer that points to this request in the queue. */
  for (p = &timerRequestListPtr;
      *p != NULL;
      p = &((*p)->next))
  {
    if (*p == tHandle.event)
    {
      /* p points to the link pointer that points to *tHandle. */
      *p = tHandle.event->next;
      /* Zap the magic number so any handles for this event will be
       * recognized as obsolete. */
      tHandle.event->magic = 0;
      /* Free the timer structure. */
      ewaFree(tHandle.event);
      EMWEB_TRACE(("ewaTimerClear: handle.event = %p\n", tHandle.event));
      return EWA_STATUS_OK;
    }
  }

  /* Entry not found. */
  return EWA_STATUS_ERROR;
}


/*
 * ewaTimerCheck
 * This function is called to check the linked list of timer requests.
 * If any of the requests have expired, then call the wakeup function.
 * Any requests that are activated have their timer structures deallocated.
 *
 * This function is only called by the main loop that calls the Server, so
 * it is not part of the Server's API.
 *
 * Note that wake-up functions *may* call timer*() functions.
 *
 * EwaStatus =  timerCheck();
 */
static void ewaTimerCheck(void)
{
  time_t now;

  now = time(NULL);

  /* Because the wake-up function may modify the timer queue, we cannot
   * optimize this loop in any way.  We must keep checking the queue until
   * all entries are after 'now'. */
  while (NULL != timerRequestListPtr &&
         timerRequestListPtr->triggerTime <= now)
  {
    EwaTimerEvent *p;

    /* Unlink the structure from the list first, so it can't be affected
     * by anything the wake-up function does. */
    p = timerRequestListPtr;
    timerRequestListPtr = p->next;
    EMWEB_TRACE(("ewaTimerCheck: waking up handle = %p\n", p));

    /* Zap the magic number so the handle will be recognized as obsolete. */
    p->magic = 0;

    /* Call the wakeup function. */
    p->wakeupFunc(p->context, p->opaquePtr);

    /* Free the structure. */
    ewaFree(p);
  }
}


/*
 * ewaTimerNextTimeout
 * This function tells the number of seconds until the first event on the
 * timer chain.  If there are no events, a very large positive number is
 * returned.  May return 0 (if an event is scheduled for now, or in the past),
 * but never a negative number (for an event scheduled in the past, but which
 * might be interpreted as a long time in the future).
 *
 * This function is only called by the main loop that calls the Server, so
 * it is not part of the Server's API.
 *
 * time_t t = ewaTimerNextTimeout();
 */
static time_t ewaTimerNextTimeout(void)
{
  time_t now;

  now = time(NULL);
  return timerRequestListPtr != NULL ?
  (timerRequestListPtr->triggerTime > now ?
   timerRequestListPtr->triggerTime - now :
   0) :
  EWA_TIMEOUT_NO_TIMER;
}

/*
 * Return the highest-precision clock value that we have available.
 */
uint32 ewaTimerGetClock(void)
{
  /*
   * The Posix application provides two implementations.  One uses the very
   * standard time() function.  The other uses gettimeofday(), which provides
   * microsecond resolution.  Selection between these implementations is done
   * via the symbol EMWEB_GETTIMEOFDAY, which is defined (or not) in
   * posix/posix_config.h.
   */
#ifdef EMWEB_GETTIMEOFDAY
  struct timeval tv;

  gettimeofday(&tv, NULL);
  return tv.tv_usec;
#else /* EMWEB_GETTIMEOFDAY */
  return time(NULL);
#endif /* EMWEB_GETTIMEOFDAY */
}

/*
 * Function that returns a pointer to a character string that identifies
 * this device uniquely.  In this implementation, it is the MAC address
 * of eth0 followed by the HTTP listening port.
 */
char const *ewaUPnPSystemId()
{
  return ewaUPnPSystemIdString;
}

#endif /* EW_CONFIG_OPTION_UPNP */

#ifdef EW_CONFIG_OPTION_SSL_RSA
static void doSSLRecvLoop(int s, EwaNetHandle connection, fd_set* fds )
{ /* junk */
  EwaNetBuffer buffer;
  int bytes=0;
  EwsStatus status= EWS_STATUS_OK;
#if defined(EW_CONFIG_OPTION_SSL_RSA)
  SSL *ssl;
  int ssl_error, bytes_left;
  boolean ssl_fetch_data;
#endif

  if ((Handle[s] != NULL) &&
      (Handle[s]->ssl_connection_flg))
  {
    if ( FD_ISSET( Handle[s]->socket, fds ) )
    /*
     * SSL decripts a whole block of data. If application (us)
     * read only a part of it, the rest is stored internally
     * by SSL and even though the select does not show
     * read ready, the data is there to get
     */
    {

      EMWEB_TRACE(("(ssl) network data event\n"));

      connection = Handle[s];
      connection->idle = FALSE;

      ssl_fetch_data = TRUE;
      bytes_left = 0;
      while (ssl_fetch_data)
      /* while */
      {
        /*
         * Get a network buffer
         */
        buffer = ewaNetBufferAlloc();
        if (buffer != EWA_NET_BUFFER_NULL)
        {
          /*
           * Read data into buffer
           */
          ssl = connection->ssl;
          bytes = SSL_read( ssl
                            ,(char *)ewaNetBufferDataGet(buffer)
                            ,(int)ewaNetBufferLengthGet(buffer)
                          );
          if (bytes > 0)
          {
            bytes_left = SSL_pending(ssl);
            if (connection->ssl_state != sslStateUp)
            {
              /*
               * handshake done
               */
              connection->ssl_state = sslStateUp;
              connection->context = ewsNetSSLStart( connection );
              EMWEB_TRACE(("doSSLRecvLoop: setting connection(%p)->context(%p) from return of ewsNetSSLStart\n",
                           connection, connection->context));
              if (connection->context == EWS_CONTEXT_NULL)
              {
                ewaNetBufferFree(buffer);
                EMWEB_WARN(( "ewsNetSSLStart() refused connection"));
                ewaNetHTTPEnd(connection);
                ERROR_EXIT;
              }
            }
            ewsBytesRecv += bytes;        /* update stats */

            /*
             * Forward data to EmWeb/Server
             */
            ewaNetBufferLengthSet(buffer, bytes);
            status = ewsNetHTTPReceive( connection->context
                                        ,buffer
                                      );
            if (status != EWS_STATUS_OK)
            {
              EMWEB_ERROR(( "ewsNetHTTPReceive() failed: %d\n", status));
              ERROR_EXIT;
            }
            if (bytes_left == 0)
            {
              ssl_fetch_data = FALSE;
            }
          }
          else
          {
            ssl_fetch_data = FALSE;
            ssl_error = SSL_get_error(ssl, bytes);
            ewaNetBufferFree(buffer);
            if (( bytes == 0) ||
                (ssl_error == SSL_ERROR_ZERO_RETURN))
            {
              if (connection->ssl_state != sslStateUp)
              {
                /*
                 * no data yet, wait longer for hanshake to complete
                 */
                break;
              }
            }
            if (( bytes < 0) ||
                (connection->ssl_state == sslStateUp))
            {
              /*
               * Error situation.
               * Client closed the TCP connection:
               * Release the buffer and abort the context.
               */
              EMWEB_TRACE(("remote closed connection\n"));
              if ( connection->pending_xmit != EWA_NET_BUFFER_NULL )
              {
                ewaNetBufferFree( connection->pending_xmit );
                connection->pending_xmit = EWA_NET_BUFFER_NULL;
              }

              if (    connection->close_pending
                      || NULL == connection->context )
              {
                /*
                 * Either the server has already closed
                 * this context, or SSL handshaking was not
                 * completed and no Server context has been
                 * created yet.  So close the socket and
                 * free the network handle.
                 */
                ewaNetHTTPEnd( connection );
              }
              else
              {
                /*
                 * tell the server to shut down this context
                 */
                ewsNetHTTPAbort( connection->context );
              }
            }
          }
        }
        else
        {
          /* Buffer allocation failed - drop connection */
          EMWEB_ERROR(( "EmWeb: net buffer alloc failed @ %s:%d\n"
                        ,__FILE__
                        ,__LINE__));
          /* Terminate the loop which will attempt to read more
           * data from the connection. */
          ssl_fetch_data = FALSE;
          if (connection->ssl_state == sslStateUp)
          {
            ewsNetHTTPAbort( connection->context );
          }
          else
          {
            ewaNetHTTPEnd(connection);
          }
        }
      }
      /* end while */
    }
  } /* if ((Handle[s] != NULL) && (Handle[s]->ssl_connection_flg)) */
}
#endif  /* EW_CONFIG_OPTION_SSL_RSA */


/**********************************************************************
 *
 *  setupOptionSockets
 *
 *  Purpose: If any of the options requiring socket setup, are turned
 *      on, call this function.
 *  Inputs:  listenAddr passed into main()
 *
 *  Outputs: - sets up values for global socket structures
 *
 *  Returns:
 *  ERROR EXIT if serious error and cannot obtain a socket correctly
 *
 **********************************************************************/
#if defined(EW_CONFIG_OPTION_UPNP) || defined(EW_CONFIG_OPTION_TELNET) ||defined(EW_CONFIG_OPTION_SSL_RSA)
static void setupOptionSockets(uint32 listenAddr,uint16 port)
{
  uint32               hostaddr;

#if defined (EW_CONFIG_OPTION_TELNET)
  struct linger        linger;
#endif /* EW_CONFIG_OPTION_TELNET */

  struct sockaddr_in    addr;           /* TCP/IP socket structure */
#if 0 /* one declared below for everyone */
#if defined (EW_CONFIG_OPTION_TELNET) || defined (EW_CONFIG_OPTION_SSL_RSA) ||\
    defined (EW_CONFIG_OPTION_UPNP)
  int                   one = 1;       /* used to set socket options */
#endif /* EW_CONFIG_OPTION_TELNET || SSL_RSA || UPNP */
#endif
#ifdef EW_CONFIG_OPTION_UPNP
  unsigned long inetAddrInt;
  char inetAddr[50];
#endif /* EW_CONFIG_OPTION_UPNP */
  int                   one = 1;       /* used to set socket options */

#ifdef EW_CONFIG_OPTION_TELNET


  /* Setup Internal SSH socket */

  /* Create socket */
  ClearErrno();
  ssh_s = socket(AF_INET, SOCK_STREAM, 0);

  if (SOCKET_IS_INVALID(ssh_s))
  {
    EMWEB_ERROR(( "internal ssh socket call failed: %s\n", strerror(errno)));
    ERROR_EXIT;
  }

  /* allowing address reuse allows the server to be stopped and restarted */
  ClearErrno();
  if ((setsockopt(ssh_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "internal ssh setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    ERROR_EXIT;
  }

#if defined(SO_SNDBUF) || defined(SO_RCVBUF)

    errno = 0;
    if ((setsockopt(ssh_s, SOL_SOCKET, SO_RCVBUF, (char *)&rcvBufLen, (int) sizeof(rcvBufLen))) < 0)
    {
        EMWEB_ERROR(( "ssh setsockopt SO_RCVBUF failed: %s\n", strerror(errno)));
    }

    errno = 0;
    if ((setsockopt(ssh_s, SOL_SOCKET, SO_SNDBUF, (char *)&sndBufLen, (int) sizeof(sndBufLen))) < 0)
    {
        EMWEB_ERROR(( "ssh setsockopt SO_SNDBUF failed: %s\n", strerror(errno)));
    }

#endif

  /* finish sending pending data before closing tcp connection */
  ClearErrno();

  /* tbd */
  linger.l_onoff = 1;    /* enable linger on close */
  linger.l_linger = 20;
  if ((setsockopt(ssh_s, SOL_SOCKET, SO_LINGER, (void *)&linger,
                  sizeof(linger))) < 0)
  {
    EMWEB_ERROR(( "internal ssh setsockopt LINGER failed %s\n", strerror(errno)));
  }


  /* bind the SSH listening port */
  ClearErrno();
  hostaddr = osapiHtonl(L7_SSHD_UNSECURE_SERVER_ADDR); /* For internal ssh, listen only on loopback */
  memset(&addr, 0, sizeof(addr));
  memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof(uint32));
  addr.sin_family = AF_INET;
  addr.sin_port = osapiHtons(SSH_Internal_Port);
  if (bind(ssh_s, (struct sockaddr *) &addr, sizeof(addr)) < 0)
  {
    EMWEB_ERROR(( "internal ssh bind failed: %s\n", strerror(errno)));
    ERROR_EXIT;
  }

  ClearErrno();
  if (listen(ssh_s, MaxConnections) < 0)
  {
    EMWEB_ERROR(( "internal ssh listen failed: %s\n", strerror(errno)));
    ERROR_EXIT;
  }
#endif /* EW_CONFIG_OPTION_TELNET */


#ifdef EW_CONFIG_OPTION_SSL_RSA

  /****************** SSL listening socket setup ******************/

  /*
   * initialize Secure Socket Layer
   */
  if (!sslInit())
  {
    EMWEB_ERROR(("SSL init failed\n"));
    ERROR_EXIT;
  }

  /*
   * Create socket and bind listening port
   */

  ClearErrno();
  ssl_s = socket( AF_INET, SOCK_STREAM, 0 );
  if (SOCKET_IS_INVALID(ssl_s))
  {
    EMWEB_ERROR(( "ssl_s socket call failed: %s\n", strerror(errno)));
    ERROR_EXIT;
  }

  /*
   * allowing address reuse allows the server to be stopped and restarted
   */

  ClearErrno();
  if ((setsockopt(ssl_s, SOL_SOCKET, SO_REUSEADDR, (char *)&one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "ssl setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    ERROR_EXIT;
  }

  /*
   * bind the SSL listening port
   */
  ClearErrno();
  hostaddr = osapiHtonl(EMWEB_LISTEN_IPADDR);
  memset( &addr, 0, sizeof( addr ));
  memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof(uint32) );
  addr.sin_family = AF_INET;
  addr.sin_port = osapiHtons( SSL_port );
  if (  bind(ssl_s, (struct sockaddr *) &addr, sizeof(addr))
        < 0
     )
  {
    EMWEB_ERROR(( "ssl bind failed: %s\n", strerror(errno)));
    if ( port != HTTP_WELL_KNOWN_PORT )
    {
      /* We are probably testing, so let ssl fail and continue */
      ssl_s = 0;
    }
    else
    {
      ERROR_EXIT;
    }
  }
  else
  {
    ClearErrno();
    if ( listen(ssl_s, MaxConnections ) < 0 )
    {
      EMWEB_ERROR(( "ssl listen failed: %s\n", strerror(errno)));
      ERROR_EXIT;
    }

    EMWEB_TRACE(("SSL(RSA) init DONE\n"));
  }
  /***************** End of SSL listening socket setup *****************/
#endif /* EW_CONFIG_OPTION_SSL_RSA */

#ifdef EW_CONFIG_OPTION_UPNP
  /*********************************************************************
   *
   *  For upnp, we set up TWO sockets.
   *      upnp_server_s - to RECEIVE incoming requests.
   *      upnp_client_s - to SEND out responses or SSDP NOTIFY and
   *                      M-SEARCH messages,
   *                      and RECEIVE responses to sent NOTIFYs and
   *                      M-SEARCHes
   *
   *********************************************************************/

  /***************** Start of UPNP listening socket setup *****************/

  /* Create socket */
  ClearErrno();
  upnp_server_s = socket( AF_INET, SOCK_DGRAM, 0 );
  if (SOCKET_IS_INVALID(upnp_server_s))
  {
    EMWEB_ERROR(( "setupOptionSockets: upnp server socket call failed: %s\n",
                  strerror(errno)));
    ERROR_EXIT;
  }
  EMWEB_TRACE(("setupOptionSockets: upnp_server_s = %d\n", upnp_server_s));

  /* bind the UPNP listening port */

  /* First set REUSEADDR so that more than one socket can be listening to
   * port 1900 at the same time.  This allows more than one copy of
   * UPnP to be running on one machine.
   */
  ClearErrno();
  if ((setsockopt(upnp_server_s, SOL_SOCKET, SO_REUSEADDR, (char *) &one,
                  sizeof(one))) < 0)
  {
    EMWEB_ERROR(( "UPnP setsockopt REUSEADDR failed: %s\n"
                  , strerror(errno)));
    ERROR_EXIT;
  }

  ClearErrno();
  /* We must bind the address to INADDR_ANY and use port 1900.
     If we bind to the listenAddr, and port 1900, we do not receive the
     multicast messages.
  */
  hostaddr = osapiHtonl(INADDR_ANY);
  if (port == EWU_SSDP_PORT)
  {
    /* If the UPNP port is the same as the listening port, select()
       will not work properly. You will not see the udp request.
    */
    EMWEB_ERROR(( "upnp port %d is the same as the listening port %d\n",
                  EWU_SSDP_PORT, port));
    ERROR_EXIT;
  }
  memset( &addr, 0, sizeof( addr ));
  memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof(hostaddr) );
  addr.sin_family = AF_INET;
  addr.sin_port = osapiHtons( EWU_SSDP_PORT );

  if ( bind(upnp_server_s, (struct sockaddr *) &addr, sizeof(addr))
       < 0
     )
  {
    EMWEB_ERROR(( "upnp bind failed: %s\n", strerror(errno)));
    ERROR_EXIT;
  }
  inetAddrInt = osapiNtohl(addr.sin_addr.s_addr);
  sprintf( inetAddr
           ,"%d.%d.%d.%d"
           ,(int)((inetAddrInt >> 24) & 0x000000ffL)
           ,(int)((inetAddrInt >> 16) & 0x000000ffL)
           ,(int)((inetAddrInt >> 8)  & 0x000000ffL)
           ,(int)((inetAddrInt)       & 0x000000ffL)
         );
  EMWEB_TRACE(("setupOptionSockets: UPnP server bind() to address %s, port %d\n",
               inetAddr, osapiNtohs(addr.sin_port)));
  ClearErrno();
  /* Join the multicast group
   * fill in the argument structure to join the multicast group.
   * 1. initialize the multicast address to join (imr_multiaddr.s_addr)
   * 2. initialize the UNICAST interface addr from which to receive the
   *    multicast packets (imr_interface.s_addr).
   */
  ipMreq.imr_multiaddr.s_addr = inet_addr (EWU_SSDP_MCAST_ADDR);
  ipMreq.imr_interface.s_addr = osapiHtonl(listenAddr);

  EMWEB_TRACE(("setupOptionSockets: ipMreq.imr_interface.s_addr = %x\n",
               osapiNtohl(ipMreq.imr_interface.s_addr)));
  inetAddrInt = osapiNtohl(ipMreq.imr_multiaddr.s_addr);
  sprintf( inetAddr
           ,"%d.%d.%d.%d"
           ,(int)((inetAddrInt >> 24) & 0x000000ffL)
           ,(int)((inetAddrInt >> 16) & 0x000000ffL)
           ,(int)((inetAddrInt >> 8)  & 0x000000ffL)
           ,(int)((inetAddrInt)       & 0x000000ffL)
         );
  EMWEB_TRACE(("ewmain: Multicast address is %s\n", inetAddr));

  /* set the socket option to join the MULTICAST group */
  ClearErrno();
  if (setsockopt (upnp_server_s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                  (char *)&ipMreq,
                  sizeof (ipMreq)) < 0)
  {
    EMWEB_ERROR(( "upnp IP ADD MEMBERSHIP error: %s\n", strerror(errno)));
    ERROR_EXIT;
  }
  EMWEB_TRACE(("setupOptionSockets: errno after setsockopt(IP_ADD_MEMBERSHIP) is %d\n",
               errno));

  /***************** End of UPNP listening socket setup *****************/

  /***************** Start of UPNP client socket setup *****************/

  /* Create socket */
  ClearErrno();
  upnp_client_s = socket( AF_INET, SOCK_DGRAM, 0 );
  if (SOCKET_IS_INVALID(upnp_client_s))
  {
    EMWEB_ERROR(( "setupOptionSockets: upnp client socket call failed: %s\n",
                  strerror(errno)));
    ERROR_EXIT;
  }
  EMWEB_TRACE(("setupOptionSockets: upnp_client_s = %d\n", upnp_client_s));

  /* bind the UPNP client port */
  ClearErrno();

  hostaddr = osapiHtonl(INADDR_ANY);
  memset( &addr, 0, sizeof( addr ));
  memcpy(&addr.sin_addr.s_addr, &hostaddr, sizeof (uint32) );
  addr.sin_family = AF_INET;
  /* Asking for port 0 means that the kernel should assign a port. */
  addr.sin_port = osapiHtons( 0 );

  if ( bind(upnp_client_s, (struct sockaddr *) &addr, sizeof(addr))
       < 0
     )
  {
    EMWEB_ERROR(( "setupOptionSockets: upnp client bind failed: %s\n", strerror(errno)));
    ERROR_EXIT;
  }
  inetAddrInt = osapiNtohl(addr.sin_addr.s_addr);
  sprintf( inetAddr
           ,"%d.%d.%d.%d"
           ,(int)((inetAddrInt >> 24) & 0x000000ffL)
           ,(int)((inetAddrInt >> 16) & 0x000000ffL)
           ,(int)((inetAddrInt >> 8)  & 0x000000ffL)
           ,(int)((inetAddrInt)       & 0x000000ffL)
         );
  EMWEB_TRACE(("setupOptionSockets: bind() to address %s, port %d\n",
               inetAddr, osapiNtohs(addr.sin_port)));
  /***************** End of UPNP client socket setup *****************/

#endif /* EW_CONFIG_OPTION_UPNP */
}
#endif /* options turned on */


