<html>
<head>
<title>EmWeb/Telnet+CLI</title>
<style type="text/css">
<!--
body
{
  color: black;
  background-color: white;
  margin-left: 10%;
  margin-right: 10%;
}
table, td, th
{
  color: black;
}
pre
{
  margin-left: 5%;
}
h1
{
  text-align: center;
}
.subhead
{
  font-size: smaller;
}
h2
{
  margin-left: -5%;
}
h3
{
  margin-left: -5%;
}
h4
{
  margin-left: -5%;
}
-->
</style>
</head>
<body bgcolor=white>

<h1>EmWeb/Telnet + CLI</h1>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Telnet Server">Telnet Server</a></li>
<li><a href="#Command Line Parser">Command Line Parser</a>
  <ul>
    <li><a href="#simple">Simple style(Unix-like) command lines</a></li>
    <li><a href="#tree">Tree style (Cisco-like) command lines</a></li>
    <li><a href="#depth">Changing the depth of the command line parser for sub commands</a></li>
    <li><a href="#param">Command line parameters and keystrokes</a></li>
  </ul></li>
<li><a href="#Data Access Functions">Data Access Functions</a></li>
<li><a href="#Sample Command Line Interface">Sample Command Line Interface</a></li>
<li><a href="#Installation">Installation</a></li>
</ul>

<h2><a name="Introduction">Introduction</a></h2>
  <p>The EmWeb/Telnet+CLI package provides developers with the ability to 
  build command-line interfaces to their devices quickly and easily.  The 
  package includes the following components:</p>

  <dl>
    <dt>Telnet Server</dt>
    <dd>
        The Telnet Server provides a serial interface over a network using
        the TELNET protocol as defined by RFC 854 and RFC 855.  Additionally,
        the interface provides a hook for a direct asynchronous serial 
        connection such as RS-232.  The Telnet Server makes use of the
        EmWeb Kernel for scheduling multiple Telnet, Asynchronous, and
        HTTP connections from the EmWeb task, and leverages the same 
        network interface to TCP/IP as the EmWeb HTTP server.  The
        serial data may be handled directly by the application, or through
        the Command Line Parser described below.
        Applications using the Telnet Server can read characters from
        the client and send characters to the client.  Additionally,
        text page templates with dynamic content compiled by the EmWeb 
        compiler can be sent to the client.
        </dd>
    <dt>Command Line Parser</dt>
    <dd>
        The CLI parser provides an abstraction layer between the Telnet
        Server and an application-specific command line interface.  Many
        command line interface features are provided including line 
        editing, history buffer, context-sensitive help, and command-line completion.  
        The CLI parser processes individual command lines using either a simple
        unix-style (command with argument list) or Cisco-style (parse tree), and
        dispatches commands to application-specific functions
        with arguments passed using ANSI C argc/argv conventions.
        </dd>
    <dt>Data Access Functions</dt>
    <dd>
        Dynamic objects defined by EmWeb namespaces (e.g. SNMP MIB
        variables with the EmWeb SNMP integration option) can be
        accessed by name for reading or writing.  This enables efficient
        CLI development without writing additional back-end code.
        </dd>
    <dt>Sample Command Line Interface</dt>
    <dd>
        An example CLI is shipped with the EmWeb/Telnet+CLI package
        to illustrate how easiliy a powerful CLI can be constructed.
        </dd>
  </dl>

<h2><a name="Telnet Server">Telnet Server</a></h2>

  <p>
  The Telnet Server makes use of the existing EmWeb network interfaces 
  except for notification of a new Telnet connection.  Instead of 
  calling ewsNetHTTPStart(), the application should call the following
  function to signal that a Telnet connection has been accepted:</p>
  <pre>
#ifdef EW_CONFIG_OPTION_TELNET
/*
 * ewsNetTelnetStart
 * Use instead of ewsNetHTTPStart to signal a telnet connection.
 *
 *   handle - network handle
 *   issue  - issue message (banner sent to client on connect)
 *   prompt - prompt to use after issue and send replies
 *   flags  - flags (0 = default, or one or more flags below)
 */
#      define EWS_TELNET_SERIAL_PORT  1  /* direct serial connection */
/*
 * Returns context, or NULL on error
 */
EwsContext ewsNetTelnetStart ( EwaNetHandle handle
                              ,const char   *issue
                              ,const char   *prompt
                              ,uintf        flags );
#endif /* EW_CONFIG_OPTION_TELNET */
  </pre>
  <p>
  Note that an asynchronous serial interface can be signalled as well.  In 
  this case, the application-specific network handle can be used to redirect
  other network layer APIs accordingly.  The following network APIs are used
  for both the EmWeb HTTP server and the EmWeb Telnet server:
  </p>
  <ul>
  <li>ewsNetHTTPReceive
  <li>ewsNetHTTPAbort
  <li>ewsNetFlowControl
  <li>ewsNetUnFlowControl
  <li>ewsNetHTTPSend
  <li>ewaNetHTTPEnd
  <li>ewaNetHTTPCleanup
  </ul>
  <p>
  When data is received from the client, EmWeb Telnet invokes the following
  application-provided call-out function:
  </p>
  <pre>
/*
 * ewaNetTelnetData
 * Called to pass raw telnet data up to application.
 *
 *   handle - network handle
 *   datap  - pointer to data
 *   bytesp - (input/output) pointer to number of bytes, decremented by
 *            number of bytes consumed.
 *
 * Returns string to write back to telnet.  May also call
 * ewsContextSendReply(), in which case the return value is ignored.
 */
char * ewaNetTelnetData( EwaNetHandle handle
                        ,char         *datap 
                        ,uintf        *bytesp
                        ,uintf        index );

  </pre>
  <p>
  This function may use ewsSuspend()/ewsResume() to handle asynchronous
  operations.  The Telnet server indicates one or more bytes of data
  available for consumption by the application, and the application may
  choose to consume zero or more bytes (updating *bytesp accordingly).
  The application may either return text to send back to the client,
  NULL to send nothing, or invoke ewsContextSendReply() to send an
  archive document (compiled by EmWeb compiler, complete with dynamic
  content)  to the client.</p>
  <p>
  Additionally, the following function may be invoked to write text
  directly to the telnet client that will appear before any text returned
  or caused by ewsContextSendReply:</p>

  <pre>
/*
 * ewsTelnetWrite
 * Write text to client
 *
 * context - request context
 * text    - null terminated string of content to write to port
 */
void
ewsTelnetWrite ( EwsContext context, const char * text );
  </pre>

  <p>
  The prompt can be changed at run-time by invoking the following 
  function:</p>
  <pre>
/*
 * ewsSetTelnetPrompt
 * Change the prompt to use after send reply
 *
 *   context - request context
 *   prompt  - new prompt
 */
void ewsSetTelnetPrompt ( EwsContext context, const char *prompt );
  </pre>

<p>
  To read the current prompt, use the following function:</p>
  <pre>
/*
 * ewsGetTelnetPrompt
 * Read current prompt
 *
 * context - request context
 */
const char *ewsGetTelnetPrompt ( EwsContext context );
  </pre>

<h2><a name="Command Line Parser">Command Line Parser</a></h2>

  <p>
  The command line parser is an optional module that comes with the 
  EmWeb/Telnet+CLI package and is enabled by the configuration option
  EW_CONFIG_OPTION_CLI.  In order to use the command line parser,
  the following function should be invoked from the application-provided
  ewaNetTelnetData() function described above:</p>
  <pre>
/*
 * ewsCliData
 * Called from ewaNetTelnetData().  Returned data passed through and returned
 * by ewaNetTelnetData().
 *
 *   context - request context
 *   datap   - pointer to received data
 *   bytesp  - (input/output) number of bytes available (updated)
 *   menu    - pointer to array of valid commands.
 */
const char * ewsCliData ( EwsContext           context
                         ,char                 *datap
                         ,uintf                *bytesp
                         ,EwsCliCommandP       menu
                        );

  </pre>
  <p>
  The context, datap, and bytesp arguments are passed through from the
  ewaNetTelnetData() function.  The menu argument describes a menu of
  commands.  Submenus are easily implemented by passing different menu
  descriptions depending on the state of the command line.</p>
  <p>
  EmWeb supports two different styles of command-line parsers, one of which must
  be selected at compile time by setting EW_CONFIG_OPTION_CLI_STYLE to one of the
  following values:
    <blockquote>
      <dl>
        <dt><a href="#simple">EWS_CLI_SIMPLE</a></dt>
        <dd>The simple style is similar to Unix commands in which there is a 
            command word followed by zero or more arguments.  In this configuration,
            the menu is described by a table of possible commands.  For each command,
            there may be up to EWS_CLI_MAX_ARGS arguments.  For each argument, a list
            of possible keywords, or a hint describing the argument, may be specified
            in the table.  When a command line is entered, the table is searched for 
            a matching command word.  Then, EmWeb invokes a command-specific application
            function with the command and arguments specified using ANSI C argc/argv 
            conventions.  The last entry in the table is used to catch unmatched commands.</dd>
        <dt><a href="#tree">EWS_CLI_TREE</a></dt>
        <dd>The tree style is similar to Cisco commands in which there is a parse tree.
            A particular command may be identified by a series of one or more words and
            may be followed by zero or more additional arguments.  The total number of
            words that may appear on a command line (including those describing the 
            command and any additional arguments) is EWS_CLI_MAX_ARGS. In this configuration,
            the menu is described by a tree of nodes.  Each node indicates a word, and
            may contain zero or more children representing the set of possibilities for the
            following word.  Each node may optionally indicate an application function.
            When a command line is entered, the tree is traversed for each word.  The
            last application function found (i.e. the deepest node in the tree to specify
            an application function) is invoked with the corresponding word and any 
            subsequent arguments specified using ANSI C argc/argv conventions.  The command
            specified in the root of the tree is used to catch any unmatched commands.</dd>
      </dl>
    </blockquote> 
<p>When a command line is completed, the parser will invoke the application-specified 
   function with the last word of the command and any subsequent arguments using
   ANSI C argc/argv conventions as follows:</p>
  <pre>
/*
 * Application CLI handler function:
 *
 * EwaCli_f
 *
 *   context - context of request
 *   argc    - number of arguments (including name of command)
 *   argv    - array of text arguments
 *
 * Returns text to be returned from ewaTelnetData().
 */
typedef const char * EwaCli_f ( 
                       EwsContext context
                      ,uintf      argc
                      ,const char **argv
                     );
  </pre>
  <p>Note that the command line parser parses the command line into one or
  more arguments using ANSI argc/argv conventions.  argv[0] will contain
  the name of the command.  The command is invoked from inside
  ewaNetTelnetData() and its returned value is passed back to the telnet
  server for transmission to the client.  Therefore, the action routine
  may either return text to be sent to the client, or invoke
  ewsContextSendReply() to send a text document from the archive to the
  client.</p>
<h3><a name="simple">Simple style (Unix-like) command lines</a></h3>
  <p>
  If the simple style of command lines are to be used, a menu is a list of commands described 
  by the following datastructure:</p>
  <pre>
#if EW_CONFIG_OPTION_CLI_STYLE == EWS_CLI_SIMPLE
/*
 * ALTERNATIVE #1: A simple CLI with top-level commands with zero or more 
 *                 arguments
 *
 * Command Description - A template for a command indicating an action
 * function, and a list of arguments.  The arguments are pointers to 
 * parameter descriptions (described above, represented as lists of strings).
 *
 * The list of arguments is terminated by a NULL argument.  A menu is an array
 * of command descriptions and is terminated by a NULL command.  Note
 * that the action of the terminating NULL command is invoked for command
 * lines that fail to match.
 *
 * Each argument may optionally indicate a list of keywords for command
 * line completion and possibile choices.
 */
typedef struct EwsCliCommand_s
  {
    EwaCli_f    *action;
    const char  *command;
    const char  **keywords[EWS_CLI_MAX_ARGS];
  } EwsCliCommand, *EwsCliCommandP;
  </pre>
  <p>
  The menu is an array of EwsCliCommand structures terminated with an
  entry containing a NULL value for command.  Each argument to the 
  command may optionally be described by a list of keywords in the
  form of an array of strings terminated by a NULL pointer.  The
  keywords represent possible command-line completions and/or context
  sensitive help.  When a command is parsed, the command line parser 
  invokes a specific application-provided action routine.</p>
  <p>
  If no matching command is found, the action routine associated with the
  terminating NULL command is invoked.</p>
<h3><a name="tree">Tree style (Cisco-like) command lines</a></h3>
  <p>
  If the tree style of command lines are to be used, a menu is the root node 
  of a parse tree built up and manipulated by the following functions:</p>
<pre>
#elif EW_CONFIG_OPTION_CLI_STYLE == EWS_CLI_TREE
/*
 * ALTERNATIVE #2: A Cisco-like CLI with a parse tree of commands
 * 
 * Use ewsCliAddNode() or ewsCliAddChain() to build a parse tree of commands.
 */
typedef struct EwsCliCommand_s *EwsCliCommandP;

/*
 * ewsCliAddNode
 * Create a new parse tree, or add a node to an existing parse tree
 *
 * parent  - pointer to parent node, or NULL to create a new root node
 * command - pointer to string containing command word in parse node
 * description - pointer to string containing additional description, or NULL
 * action  - application function to call, or NULL.  The action of the root 
 *           node will be called if no other action is found for a command 
 *           line (i.e. if the command line is not parsable according to the 
 *           rules).
 *
 * Returns new node.
 *
 * This function adds a new command word to the parse tree.  The EmWeb/CLI will
 * traverse the tree according to user input on the command line, handling
 * command-line completion and context-sensitive help accordingly.  When a 
 * command is executed, the deepest action will be invoked with argv[0] and argc
 * adjusted to pass the command word and any additional arguments to the 
 * application.
 *
 * The root node for a given tree is passed to ewsCliData for processing.
 */
EwsCliCommandP
ewsCliAddNode( EwsCliCommandP parent
              ,const char     *command 
              ,const char     *description 
              ,EwaCli_f       *action
             );

/*
 * ewsCliAddTree
 * This function links a tree to the bottom of a node by reference.  This is
 * helpful if a subtree can describe a common construct used by many commands
 * without replicating parts of the parse tree.  Note that this can only be
 * done to a node that currently has no children.
 */
void
ewsCliAddTree( EwsCliCommandP parent
              ,EwsCliCommandP tree
             );


/*
 * ewsCliDeleteTree
 * This function deletes a tree.
 */
void
ewsCliDeleteTree( EwsCliCommandP parent
                 ,boolean cli_shutdown
                );

/*
 * ewsCliDeleteNode
 * Remove and delete a node (and its offspring, if any).
 */
void
ewsCliDeleteNode (EwsCliCommandP node);

/*
 * ewsCliAddChain
 * Add a node or a chain of nodes (as specified in command string) to an 
 * existing parse tree.
 *
 * parent  - pointer to parent node
 * command - pointer to string containing commands in parse chain
 * description - pointer to string containing a description for the last
 *               command, or NULL
 * action - application function for the last command in chain to call,
 *          or NULL.  The action of the root node will be called if no 
 *          other action is found for a command line (i.e. if the command
 *          line is not parsable according to the rules).
 *
 * Returns last node in command chain.
 *
 * This function checks existance of each node representing a command 
 * listed in the command string. If the command is not found it will be added
 * to the parse tree. 
 */
EwsCliCommandP
ewsCliAddChain ( EwsCliCommandP parent
                ,const char     *command 
                ,const char     *description 
                ,EwaCli_f       *action
               );

/*
 * ewsCliFindNode
 * Locate a node in the tree
 *
 * parent  - pointer to node to start search from
 * command - pointer to string containing commands in parse chain
 *
 * Returns last node in command chain, or NULL if not in the tree.
 *
 */
EwsCliCommandP
ewsCliFindNode ( EwsCliCommandP parent
                ,const char     *command 
               );


#else
#error EW_CONFIG_OPTION_CLI_STYLE must be defined EWS_CLI_SIMPLE or EWS_CLI_TREE
#endif /* EW_CONFIG_OPTION_CLI_STYLE */
</pre>

<h3><a name=depth>Changing the depth of the command line parser for sub commands</a></h3>  
  <p>
  The depth of the command line in either style can be changed dynamically with the following
  function to support submenus within a menu as follows:
  </p>
  <pre>
/*
 * ewsCliDepth
 * Set the command depth.  argc/argv specify a prefix command and arguments
 * to which the arguments specified in the command line are appended.  If 
 * argc is zero, then no initial command and arguments are prepended to the
 * command line.
 */
void ewsCliDepth ( EwsContext context
                   ,uintf      argc
                   ,const char **argv
                  );
  </pre>
  <p>
  The above function specifies a command and zero or more arguments to be
  prepended to subsequent command lines.  Thus, the first argument on the
  command line becomes the argc'th argument to the command argv[0].  If 
  argc is zero, then the initial depth is restored (i.e. no commands or
  arguments are prepended to the command line).
  </p>
<h3><a name=param>Command line parameters and keystrokes</a></h3>
  <p>The following compile-time constants may be changed by redefining them
  in ew_options.h:</p>
  <pre>
#define EWS_CLI_MAX_ARGS       10 /* max arguments per command */
#define EWS_CLI_MAX_LINE       64 /* max characters per line */
#define EWS_CLI_MAX_HISTORY     8 /* max lines in history buffer */
#define EWS_CLI_POSSIBLE_WIDTH 15 /* field width of each possible completion for '?' */
#define EWS_CLI_POSSIBLE_COLS   5 /* number of possible completions to list per line for '?' */

  </pre>
  <p>The command line interpreter supports the following end-user features.
  Note that the specific control characters can also be overridden:</p>

  <table border=1>
  <tr><td>BS<br>DEL</td><td>Delete previous character</td></tr>
  <tr><td>Ctrl-A</td><td>Go to beginning of line</td></tr>
  <tr><td>Ctrl-E</td><td>Go to end of line</td></tr>
  <tr><td>Ctrl-F</td><td>Go forward one character</td></tr>
  <tr><td>Ctrl-B</td><td>Go backward one character</td></tr>
  <tr><td>Ctrl-D</td><td>Delete current character</td></tr>
  <tr><td>Ctrl-U<br>Ctrl-X</td><td>Delete to beginning of line</td></tr>
  <tr><td>Ctrl-K</td><td>Delete to end of line</td></tr>
  <tr><td>Ctrl-W</td><td>Delete previous word</td></tr>
  <tr><td>Ctrl-T</td><td>Transpose previous character</td></tr>
  <tr><td>Ctrl-P</td><td>Go to previous line in history</td></tr>
  <tr><td>Ctrl-N</td><td>Go to next line in history</td></tr>
  <tr><td>TAB</td><td>Command line completion</td></tr>
  <tr><td>?</td><td>List possible choices</td></tr>
  </table>

  <p>The CLI also supports the use of the arrow keys for cursor
  movement and command line recall:</p>

  <table border=1>
  <tr><td>Left Arrow</td><td>Move cursor backward one character.</td></tr>
  <tr><td>Right Arrow</td><td>Move cursor forward one character.</td></tr>
  <tr><td>Up Arrow</td><td>Go to previous line in history buffer.</td></tr>
  <tr><td>Down Arrow</td><td>Go to next line in history buffer.</td></tr>
  </table>


<h2><a name="Data Access Functions">Data Access Functions</a></h2>

  <p>
  As a convenience to the application designer, access functions are provided
  which may be used to access namespace data objects by name.  For example,
  if the EmWeb/SNMP package is included, MIB objects in the SNMP namespace
  may be accessed by name.</p>
  <p>In order to take advantage of this functionality, archives must be
  compiled using the &quot;--archive-symbols&quot; switch.  This will include
  symbol information in the archive. (Note that &quot;--archive-symbols&quot; only includes symbols in the archive that on  referenced on web pages.  You may need to create a web page with all the MIB objects on it as a hidden file that you want to reference from the CLI if the mib objects are not referenced elsewhere).
  Furthermore, the server configuration 
  option EW_CONFIG_OPTION_NS_LOOKUP must be defined to enable these 
  interfaces.</p>

  <p>To read the value of a namespace object or an EmWeb macro, the following
  function may be invoked from within an &lt;emweb_string&gt; tag:</p>
  <pre>
/*
 * ewsNamespaceGet
 * Called from EMWEB_STRING code fragment.  The code fragment should return
 * the value returned by this function.  This function is used to indirectly
 * access namespace schema nodes by name.
 *
 *   context - context pointer
 *   namespace - name of namespace, or EWS_NAMESPACE_EMWEB for EmWeb namespace
 *   name      - name of schema object
 *   parameters - parameters to pass to macro
 *
 * Returns result to be returned from EMWEB_STRING code fragment, or
 * EWS_NAMESPACE_GET_ERROR if the lookup failed.
 */
#define      EWS_NAMESPACE_EMWEB      NULL
#ifdef EW_CONFIG_OPTION_NS_GET
extern char *EWS_NAMESPACE_GET_ERROR;

char *
ewsNamespaceGet( EwsContext context
                ,const char *nameSpace
                ,const char *name
                ,const char *parameters );
  </pre>
  <p>
  To write the value of one or more namespace objects, the following 
  functions may be invoked.  Note that ewsNamespaceSetFinish should be
  called from a state in which ewsContextSendReply() is allowed (e.g. 
  from a command line action function):
  </p>
  <pre>
/*
 * The following functions give the user a mechanism to set the value of
 * namespace objects indirectly by name.  These functions mirror the three
 * per-namespace API functions used to implement sets.  These functions
 * can only be called from a valid context.  Note that if the per-namespace
 * set_finish function invokes ewsContextSendReply, then it should only be
 * invoked from a state in which this would be allowed.
 *
 * Note that namespace sets may not be nested.  Only one per context
 * is allowed at any given time.
 */

 /*
  * ewsNamespaceSetStart
  * Returns EWS_STATUS_OK or error
  *
  *   context    - context of request
  *   namespace  - name of namespace
  */
EwsStatus  ewsNamespaceSetStart ( EwsContext context
                                 ,const char *nameSpace );

/*
 * ewsNamespaceSet
 * Set object value
 *
 *   context    - context of request
 *   name       - name of object to set
 *   parameters - qualifying parameters
 *   value      - new value 
 *
 * Returns EWS_STATUS_OK or EWS_STATUS_NOT_FOUND
 */
EwsStatus ewsNamespaceSet ( EwsContext context
                           ,const char *name
                           ,const char *parameters
                           ,const char *value );

/*
 * ewsNamespaceSetFinish
 * Complete atomic set operation.  This should be called from a state in 
 * which ewsContextSendReply() is permitted, and should not be called from
 * a namespace form (since nesting is not allowed).
 *
 *   context - context of request
 *   status  - EWS_STATUS_OK|ABORT
 *
 * Note that abort case is handled by server.
 */
char * ewsNamespaceSetFinish ( EwsContext context, EwsStatus status );
  </pre>

<h2><a name="Sample Command Line Interface">Sample Command Line Interface</a></h2>

  <p>
  The sample command line interface includes an EmWeb archive content
  directory.  This includes text pages to return information that may be
  useful to the developer.  The rest of the CLI is included in the sample 
  ports.  In the sample ewaNetTelnetData() function, a simple password 
  login and CLI is implemented using the EmWeb command line parser.</p>

  <p><strong>NOTE:</strong> This example CLI is intended as an example for
  evaluation purposes only.  You will need to replace this with your own
  parse tree and command handlers for your particular application.
  </p>

<h2><a name="Installation">Installation</a></h2>

  <p>
  <ol start='1' type='1'>
  <li>Merge the EmWeb/Telnet+CLI package into the EmWeb source tree.</li>
  </ol>
  <ol start='2' type='1'>
  <li>Edit config.TARGET/options.mak by uncommenting the EmWeb/Telnet 
      package</li>
  </ol>
  <ol start='3' type='1'>
  <li>Edit config.TARGET/ew_options.h:
      <ol>
      <li>Define EW_CONFIG_OPTION_TELNET and 
      EW_CONFIG_OPTION_CLI.</li>
      <li>Select the parser style by defining
      EW_CONFIG_OPTION_CLI_STYLE to either EWS_CLI_SIMPLE or EWS_CLI_TREE.</li>
      </ol></li>
  </ol>
  <ol start='4' type='1'>
  <li>Edit posix/Makefile to change the invocation of the EmWeb/Compiler as
      follows:
      <ol>
      <li>Include sample CLI content archive</li>
      </ol></li>
  </ol>
  <ol start='5' type='1'>
  <li>Be sure to replace hard-wired telnet password with something
  incorporating your authentication data, and be sure to disable
  telnet connections by default as this is an inherent security risk.</li>
  </ol>
  </p>

</body>
</html>
