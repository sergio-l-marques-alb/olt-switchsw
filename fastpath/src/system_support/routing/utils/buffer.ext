/********************************************************************
 *
 * (C) Copyright Broadcom Corporation 2003-2007
 *
 * *********************************************************************
 *
 * @filename      buffer.ext
 *
 * @purpose       Buffer management public API
 *
 * @component     Routing Utils Component
 *
 * @comments
 *
 * @create        02/01/2004
 *
 *
 * @author        Jonathan Masel
 *                Igor Bryskin
 *
 * @end
 *
 * ********************************************************************/

#ifndef _BUFFER_EXT
#define _BUFFER_EXT

#include "std.h"
#include "local.h"
#include "tuning.h"

#ifndef L7_FRMCYAN

#ifdef __cplusplus
extern "C"{
#endif


/* Get the size of the BUFFER structure */
#define B_Sizeof() sizeof(t_Buffer)

/* Set buffer full field */
#define B_SETFULL(buf) ( ((t_Buffer *)(buf))->fFull = ((((t_Buffer *)(buf))->tail == ((t_Buffer *)(buf))->head || \
        (word)(((t_Buffer *)(buf))->tail - ((t_Buffer *)(buf))->head) == \
        ((t_Buffer *)(buf))->size)) )

/* Check if buffer is full */
#define B_FULL(b) (((t_Buffer *)(b))->fFull)
/*Allocate a new frame buffer */
void   *B_New(void);

void   *B_NewEx(t_Handle bufPool,    /* mem pool to allocate buffers structures*/
                t_Handle datPool,    /* mem pool to allocate data buffers      */
                word     datSize);   /* size of data buffer if datPool = NULLP */


void   *B_NewExDat(void *p_Buff,     /* data buffer to put into frame buffer , NULLP is none */
                word maxSize,       /* maximum data buffer size                             */
                word offset,        /* data in buffer beginning offset                      */
                word dataSize,      /* data size                                            */
                t_Handle bufPool,   /* mem pool to allocate buffers structures              */
                t_Handle datPool);  /* mem pool to allocate data buffers                    */

/* Allocate n frame buffers */

#define  B_NewN(n,Array)\
{\
   word i;\
   for(i=0; i<n; i++) Array[i] = B_New();\
}

#define  B_NewNEx( n, Array, bufPool, datPool, datSize)\
{\
   word i;\
   for(i=0; i<n; i++) Array[i] = B_NewEx(bufPool, datPool, datSize);\
}

/*Delete frame buffer */
void   *B_Delete( void *pBuff,           /* pointer to a frame buffer          */
                  Bool DelData);         /* flag to delete data buffer as well */
void   *B_DeleteEx( void *pBuff,         /* pointer to a frame buffer          */
                    Bool DelData,        /* flag to delete data buffer as well */
                    t_Handle *poolData); /* pointer to put data mem pool,      */
                                         /*   if data is not to be released    */

/*Delete data buffer */
void    B_DeleteData( byte *pData );
void    B_DeleteDataEx( byte *pData,
                        t_Handle poolData); /* mem pool data belongs to */


/* Set data offset in an empty frame buffer */
#define B_SetOffset( pBuf, Offset )\
       if(  !(((t_Buffer *)(pBuf))->fFull) &&\
        ( ((t_Buffer *)(pBuf))->head == ((t_Buffer *)(pBuf))->tail )) \
           ((t_Buffer *)(pBuf))->head = ((t_Buffer *)(pBuf))->tail = Offset

/* Get data offset in buffer */
#define B_GetOffset( pBuf )    (((t_Buffer *)(pBuf))->head )

#define BufDecOffset(buf,off) (((t_Buffer *)buf)->head -= (off))
#define BufIncOffset(buf,off) (((t_Buffer *)buf)->head += (off))
/*Create link to the frame buffer */
#define B_Link(pBuf)       \
      ( ((t_Buffer *)(pBuf))->useCount++ )

/* Get data buffer full size */
#define B_GetSize(pBuf) ( ((t_Buffer *)(pBuf))->size )

/* Set / get data length */
#define B_SetLength(pBuf,len)   \
{\
       if( ((t_Buffer *)(pBuf))->head+(len) <= ((t_Buffer *)(pBuf))->size)\
        ((t_Buffer *)(pBuf))->tail = ((t_Buffer *)(pBuf))->head + (len);\
       else\
        ((t_Buffer *)(pBuf))->tail = (len) - ((t_Buffer *)(pBuf))->size + ((t_Buffer *)(pBuf))->head;\
       ((t_Buffer *)(pBuf))->fFull = ((len)==((t_Buffer *)(pBuf))->size); \
}

/* Get the total user data size in the buffer */
#define B_GetLength(pBuf)       \
       (((t_Buffer *)(pBuf))->fFull ? ((t_Buffer *)(pBuf))->size :\
       ((((t_Buffer *)(pBuf))->head <= ((t_Buffer *)(pBuf))->tail) ? \
         ((t_Buffer *)(pBuf))->tail - ((t_Buffer *)(pBuf))->head :\
         ((t_Buffer *)(pBuf))->tail + ((t_Buffer *)(pBuf))->size - ((t_Buffer *)(pBuf))->head))

/*Get pointer to data */
#define B_GetData(pBuf)  ((void *)(((t_Buffer*)(pBuf))->data + ((t_Buffer*)(pBuf))->head))

/*Get pointer to data (tail part of the buffer)*/
/* only for not BIG_TAIL buffers !             */
#define B_GetDataTail(pBuf) (((t_Buffer *)(pBuf))->data)

/* Get the length of the tail part of the buffer */
/* only for not BIG_TAIL buffers !               */
#define B_GetDataTailLength(pBuf) (((t_Buffer *)(pBuf))->tail)

/* Check if buffer is bigTail */
#define B_BIG_TAIL(b)  ( (((t_Buffer *)(b))->tail > ((t_Buffer *)(b))->head)\
 || ( B_GetDataTailLength(b) == 0 ) )

/* Get some buffer's attributes                                                    */
void *B_GetDataEx(void *pBuf,
                  word *size,         /* a pointer to put data size                */
                  Bool *bigTail,      /* a pointer to put flag wether tail > head  */
                  t_Handle *datPool); /* a pointer to put mem pool data belongs to */

/* Rewrap full buffer */
void *B_ReWrap(void *pBuf);

#define B_ADDBYTETOSTART(pBuf, d) \
   ( \
    ((t_Buffer *)(pBuf))->head != 0 ? \
    (*(((t_Buffer *)(pBuf))->data + (--((t_Buffer *)(pBuf))->head))=d) :\
    (*(((t_Buffer *)(pBuf))->data + \
                  (((t_Buffer *)(pBuf))->head=((t_Buffer *)(pBuf))->size-1))=d),\
    B_SETFULL(pBuf),1 \
   )


/* Add byte to start of the buffer */
#ifdef ERRCHK
#define B_AddByteToStart(pBuf, d) \
   ( ASSERT(B_GetLength (pBuf) < ((t_Buffer *)(pBuf))->size), \
      B_ADDBYTETOSTART(pBuf, d) )
#else
#define B_AddByteToStart(pBuf, d) B_ADDBYTETOSTART(pBuf, d)
#endif

/* Add array to start of the buffer*/

word    B_AddToStart( void *pBuf, byte *pData, word Length );

#define B_ADDTOSTART(buf, pData, len)\
{\
 word ll;\
 if((buf)->head<(ll=len))\
 {\
  if((buf)->head)\
  {\
    if(pData)\
    memcpy((buf)->data, (pData)+ll-(buf)->head, (buf)->head);\
    ll-=(buf)->head;\
  }\
  (buf)->head = (buf)->size;\
 }\
 (buf)->head-=ll;\
 if(pData)\
 memcpy((buf)->data + (buf)->head, (pData), ll);\
 B_SETFULL(buf);\
}

#define B_ADDBYTETOEND(pBuf, d) \
   (  (((t_Buffer *)(pBuf))->tail == ((t_Buffer *)(pBuf))->size) ? \
          ((t_Buffer *)(pBuf))->tail = 0 : TRUE, \
        *(((t_Buffer *)(pBuf))->data + ((t_Buffer *)(pBuf))->tail++)=(d),\
        B_SETFULL(pBuf), 1 \
    )

/* Add byte to end  of the buffer */
#ifdef ERRCHK
#define B_AddByteToEnd(pBuf, d) \
   (ASSERT(B_GetLength (pBuf) < ((t_Buffer *)(pBuf))->size), \
      B_ADDBYTETOEND(pBuf, d) )
#else
#define B_AddByteToEnd(pBuf, d) B_ADDBYTETOEND(pBuf, d)
#endif

/* Add array to end  of the buffer */
word    B_AddToEnd( void *pBuf, byte *pData, word Length );

#define B_ADDTOEND(buf, pData, length)\
{\
 word ll, tt;\
 byte *p = (pData);\
 if((tt=(buf)->size - (buf)->tail)<(ll=length))\
 {\
  if(tt)\
  {\
    if(p)\
    {\
    memcpy((buf)->data+(buf)->tail, p, tt);\
    p+=tt;\
  }\
    ll-=tt;\
  }\
  (buf)->tail = 0;\
 }\
 if(p)\
 memcpy((buf)->data + (buf)->tail, p, ll);\
 (buf)->tail+=ll;\
 B_SETFULL(buf);\
}

/* Remove data from the start of the buffer   */
word    B_CutFromStart( void *pBuff, word Length );

#define B_CUTFROMSTART(buf, length)\
{\
 word ll, tt;\
 if((tt=(buf)->size - (buf)->head)<(ll=length))\
 {\
  ll-=tt;\
  (buf)->head =0;\
 }\
 if(((buf)->head+=ll)==(buf)->size)\
      (buf)->head = 0;\
 (buf)->fFull = FALSE;\
}

/* Remove data from the end of the buffer */
word    B_CutFromEnd( void *pBuff, word Length );

#define B_CUTFROMEND(buf, length)\
{\
 word ll;\
 if((buf)->tail<(ll=length))\
 {\
  ll-=(buf)->tail;\
  (buf)->tail  = (buf)->size;\
 }\
 (buf)->tail-=ll;\
 (buf)->fFull =FALSE;\
}


/* Remove slice from specified offset in the buffer */
word B_CutSlice( void *p_Buf, word offset, word Length);

/* Read array from the specified offset in the buffer */
word  B_Read(void *p, void *p_Buf, word offset, word Length);

#define B_READ(p, buf, off, length)\
{\
 word ll, tt, o;\
 byte *d = (byte *)(p);\
 o=off;\
 if((o = (buf)->head+off)>(buf)->size)\
  o-=(buf)->size;\
 if((tt=(buf)->size - o) < (ll=length))\
 {\
  memcpy(d, (buf)->data+o, tt);\
  d+=tt;\
  o = 0;\
  ll-=tt;\
 }\
 memcpy(d, (buf)->data+o, ll);\
}

/* Overwrite data in the buffer beginning from the specified offset from array */
word  B_Write(void *p, void *p_Buf, word offset, word Length);

#define B_WRITE(p, buf, off, length)\
{\
 word ll, tt, o;\
 byte *s = (byte *)(p);\
 o=off;\
 if((o = (buf)->head+off)>(buf)->size)\
  o-=(buf)->size;\
 if((tt=(buf)->size - o) < (ll=length))\
 {\
  memcpy((buf)->data+o, s, tt);\
  s+=tt;\
  o = 0;\
  ll-=tt;\
 }\
 memcpy((buf)->data+o, s, ll);\
}

/* Read array from start and remove data from the buffer */
word  B_ReadStartRemove(void *p, void *p_Buf, word Length);

#define B_READSTARTREMOVE(p, buf, length)\
{\
 word ll, tt;\
 byte *d = (byte *)(p);\
 if (length) { \
  if((tt=(buf)->size - (buf)->head) < (ll=length))\
  {\
   memcpy(d, (buf)->data+buf->head, tt);\
   d+=tt;\
   (buf)->head = 0;\
   ll-=tt;\
  }\
  memcpy(d, (buf)->data+(buf)->head, ll);\
 if(((buf)->head+=ll)==(buf)->size)\
      (buf)->head = 0;\
  (buf)->fFull =FALSE;\
 }\
}


/* Read array from end and remove data from the buffer */
word  B_ReadEndRemove(void *p, void *p_Buf,word Length);
#define B_READENDREMOVE(p, buf, length)\
{\
 word ll;\
 byte *d = (byte *)p;\
 if (length) { \
  if((buf)->tail < (ll=length))\
  {\
   memcpy(d+ll-(buf)->tail, (buf)->data, (buf)->tail);\
   ll-=(buf)->tail;\
   (buf)->tail = (buf)->size;\
  }\
  memcpy(d, (buf)->data+(buf)->tail-ll, ll);\
  (buf)->tail-=ll;\
  (buf)->fFull = FALSE;\
 } \
}

/* Read one byte from the buffer */
#define  B_Peek(p, buf, offset )\
 (*(byte *)p = ((word)((t_Buffer *)buf)->head+offset)>=((t_Buffer *)buf)->size ?\
              *(((t_Buffer *)buf)->data+((t_Buffer *)buf)->head+offset-((t_Buffer *)buf)->size) :\
              *(((t_Buffer *)buf)->data+((t_Buffer *)buf)->head+offset), 1)

/* Replace one byte in the buffer */
#define  B_Replace(d, buf, offset )\
 (*((buf)->data+ (buf)->head + ((word)((buf)->head+offset)>=(buf)->size ? \
                                    offset-(buf)->size : offset))=d, 1)

/* Copy one buffer to another */
word B_Copy(void *destbuf, void *srcbuf);
#define B_COPY(dbuf, sbuf)\
{\
  dbuf->head = sbuf->head;\
  dbuf->tail = sbuf->tail;\
  dbuf->fFull= sbuf->fFull;\
\
 if((sbuf)->fFull || (sbuf)->head != (sbuf)->tail)\
  if((sbuf)->head<(sbuf)->tail)\
  {\
   memcpy((dbuf)->data+(dbuf)->head, (sbuf)->data+(sbuf)->head, (sbuf)->tail - (sbuf)->head);\
  }\
  else\
  {\
   memcpy((dbuf)->data+(dbuf)->head, (sbuf)->data+(sbuf)->head, (sbuf)->size-(sbuf)->head);\
   memcpy((dbuf)->data, (sbuf)->data, (sbuf)->tail);\
  }\
}

void *B_GetNextBuffer (void* ,Bool* );

#define B_GetNext(buf)  (void *)(((t_Buffer *)(buf))->next)

#define B_GET_DATA_POOL(b) (((t_Buffer *)(b))->datPool)

#if BUFOBJ_FREELIST
/* Initialization of free buffer list */
void B_FreeListInit( void );

/* Release all buffers from buffer free list */
void B_FreeListFlush( void );
#endif

t_Handle  B_DataPool( void );


#ifdef __cplusplus
}
#endif

#endif  /* #ifndef L7_FRMCYAN */

#endif  /*_BUFFER_EXT */
